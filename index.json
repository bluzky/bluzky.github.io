[{"categories":["elixir","phoenix"],"contents":"In this post, you\u0026rsquo;ll learn how to implement JWT-based authentication using Phoenix.Token.\nIn our previous projects, we use guardian library to implement JWT authentication. Guardian is a great library which provides lots of method and tool to work with aunthentication. But sometime we don\u0026rsquo;t need them all. And recently, I found Phoenix.Token module shipped with phoenix framework that helps me to implement JWT authentication with few lines of code.\nLet\u0026rsquo;s do it.\n1. Implement JwtToken module Here is the document of Phoenix.Token.\nWe just wrap sign and verify function from Phoenix.Token to create and check for valid JWT token.\n1defmodule MyApp.JwtToken do 2 @signing_salt \u0026#34;octosell_api\u0026#34; 3 # token for 2 week 4 @token_age_secs 14 * 86_400 5 6 @doc \u0026#34;\u0026#34;\u0026#34; 7Create token for given data 8\u0026#34;\u0026#34;\u0026#34; 9 @spec sign(map()) :: binary() 10 def sign(data) do 11 Phoenix.Token.sign(MyAppWeb.Endpoint, @signing_salt, data) 12 end 13 14 15 @doc \u0026#34;\u0026#34;\u0026#34; 16Verify given token by: 17- Check if this token is issued and stored in Redis 18- Verify token signature 19- Verify expiration time 20\u0026#34;\u0026#34;\u0026#34; 21 @spec verify(String.t()) :: {:ok, any()} | {:error, :unauthenticated} 22 def verify(token) do 23 case Phoenix.Token.verify(MyAppWeb.Endpoint, @signing_salt, token, 24 max_age: @token_age_secs 25 ) do 26 {:ok, data} -\u0026gt; {:ok, data} 27 _error -\u0026gt; {:error, :unauthenticated} 28 end 29 end 30end Here we wrap in JwtToken module to simplify API. We pass MyAppWeb.Endpoint here to use secret key that config for endpoint. You can pass secret key from config as firt argument.\n2. Generate JWT token 1defmodule MyAppWeb.SessionController do 2 ... 3 def new(conn, %{\u0026#34;email\u0026#34; =\u0026gt; email, \u0026#34;password\u0026#34; =\u0026gt; password}) do 4 with {:ok, user} \u0026lt;- Account.authenticate_user(email, password), 5 {:ok, token} \u0026lt;- MyApp.JwtToken.sign(%{user_id: user.id}) do 6 ... 7 # return token to client 8 else 9 _ -\u0026gt; 10 {:error, gettext(\u0026#34;email or password is in correct\u0026#34;)} 11 end 12 end 13end 14 Here we create JWT token with a map %{user_id: user.id} and return to client.\n3. Build Plug to verify token Client sent jwt token to server via header Authorization. We extract token and call JwtToken.verify to check if jwt token is valid and not expired.\n1defmodule MyApp.Plug.Authenticate do 2 import Plug.Conn 3 require Logger 4 5 def init(opts) do 6 opts 7 end 8 9 def call(conn, _opts) do 10 with [\u0026#34;Bearer \u0026#34; \u0026lt;\u0026gt; token] \u0026lt;- get_req_header(conn, \u0026#34;authorization\u0026#34;), 11 {:ok, data} \u0026lt;- MyApp.JwtToken.verify(token) do 12 conn 13 |\u0026gt; assign(:current_user, MyApp.Account.get_user(data.user_id)) 14 else 15 error -\u0026gt; 16 conn 17 |\u0026gt; put_status(:unauthorized) 18 |\u0026gt; Phoenix.Controller.put_view(MyAppWeb.ErrorView) 19 |\u0026gt; Phoenix.Controller.render(:\u0026#34;401\u0026#34;) 20 |\u0026gt; halt() 21 end 22 end 23end 4. Add plug to router 1defmodule MyAppWeb.Router do 2 use MyAppWeb, :router 3 4 pipeline :api do 5 plug :accepts, [\u0026#34;json\u0026#34;] 6 end 7 8 pipeline :authenticated do 9 plug MyAppWeb.Plug.Authenticate 10 end 11 12 scope \u0026#34;/api\u0026#34;, MyAppWeb do 13 pipe_through :api 14 post \u0026#34;/auth/login\u0026#34;, SessionController, :new 15 end 16 17 scope \u0026#34;/api\u0026#34;, MyAppWeb do 18 pipe_through [:api, :authenticated] 19 delete \u0026#34;/auth/logout\u0026#34;, SessionController, :delete 20 ... 21 end 22end 23 We have done with it. Just a few line of code\nConclusion Implement JWT authentication with Phoenix is so easy and you may not need Guardian for your application. In this post I only implement simple version of JWT authentication. In real application, you should store jwt token signature in database or redis and\n In Authenticate plug check if the token exists in database. When user logout, clear it from database/redis to make sure that token cannot be used to make request anymore.  Thanks for reading.\n","date":"26","image":"/img/jwt-phoenix.png","permalink":"https://bluzky.github.io/blog/2021-08-26-jwt-auth-with-phoenix-token/","tags":["elixir","phoenix","jwt","authentication"],"title":"JWT Auth with Phoenix.Token"},{"categories":null,"contents":"If your data is encrypted, even if it\u0026rsquo;s leaked, no one know what is the data. That\u0026rsquo;s great.\nIn this post, I\u0026rsquo;m going to show you how to encrypt data with Ecto. Ecto allows developer to define their own types. And we will define a type called EncryptedText which encrypts data before persiting to database and decrypts data after loading.\n1. Define encrypt/decrypt methods This is a simple version of crypto module:\n1defmodule Crypto do 2 @block_size 16 3 4 def generate_secret do 5 :crypto.strong_rand_bytes(@block_size) 6 |\u0026gt; Base.encode64() 7 end 8 9 def encrypt(plaintext, secret_key) do 10 with {:ok, secret_key} \u0026lt;- decode_key(secret_key) do 11 iv = :crypto.strong_rand_bytes(@block_size) 12 plaintext = pad(plaintext, @block_size) 13 ciphertext = :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, plaintext, true) 14 15 {:ok, Base.encode64(iv \u0026lt;\u0026gt; ciphertext)} 16 end 17 end 18 19 def decrypt(ciphertext, secret_key) do 20 with {:ok, secret_key} \u0026lt;- decode_key(secret_key), 21 {:ok, \u0026lt;\u0026lt;iv::binary-@block_size, ciphertext::binary\u0026gt;\u0026gt;} \u0026lt;- Base.decode64(ciphertext) do 22 plaintext = 23 :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, ciphertext, false) 24 |\u0026gt; unpad 25 26 {:ok, plaintext} 27 else 28 {:error, _} = err -\u0026gt; err 29 _ -\u0026gt; {:error, \u0026#34;Bad encrypted data\u0026#34;} 30 end 31 end 32 33 defp pad(data, block_size) do 34 to_add = block_size - rem(byte_size(data), block_size) 35 data \u0026lt;\u0026gt; :binary.copy(\u0026lt;\u0026lt;to_add\u0026gt;\u0026gt;, to_add) 36 end 37 38 defp unpad(data) do 39 to_remove = :binary.last(data) 40 :binary.part(data, 0, byte_size(data) - to_remove) 41 end 42end Let go through the code\n1 def generate_secret do 2 :crypto.strong_rand_bytes(@block_size) 3 |\u0026gt; Base.encode64() 4 end This function generate a 16 bytes secret key and encode base 64 string so you can add it to config.\n encrypt/2 function  1 def encrypt(plaintext, secret_key) do 2 # check the key size 3 with {:ok, secret_key} \u0026lt;- decode_key(secret_key) do 4 5 # random initial vector 6 iv = :crypto.strong_rand_bytes(@block_size) 7 # if length of text is not multiple of @block_size 8 # we add more data until it meets condition 9 plaintext = pad(plaintext, @block_size) 10 # encrypt here 11 ciphertext = :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, plaintext, true) 12 13 {:ok, Base.encode64(iv \u0026lt;\u0026gt; ciphertext)} 14 end 15 end This is the most important line\n1ciphertext = :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, plaintext, true)  iv is initial vector. AES-128 algorithms encrypts data by block of 16 bytes, so we need initial vector to make sure that the output of blocks with same data are different from each other. The last parameter is set to true to encrypt, set to false to decrypt data  And then we encode output to base 64 string. Here we concatenate iv and ciphertext so that we can extract iv to use for decrypting\n1{:ok, Base.encode64(iv \u0026lt;\u0026gt; ciphertext)}  decrypt/2 function  1def decrypt(ciphertext, secret_key) do 2 # check the key 3 with {:ok, secret_key} \u0026lt;- decode_key(secret_key), 4 {:ok, \u0026lt;\u0026lt;iv::binary-@block_size, ciphertext::binary\u0026gt;\u0026gt;} \u0026lt;- Base.decode64(ciphertext) do 5 plaintext = 6 :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, ciphertext, false) 7 |\u0026gt; unpad 8 9 {:ok, plaintext} 10 else 11 {:error, _} = err -\u0026gt; err 12 _ -\u0026gt; {:error, \u0026#34;Bad encrypted data\u0026#34;} 13 end 14 end We extract iv and encrypted data from input\n1{:ok, \u0026lt;\u0026lt;iv::binary-@block_size, ciphertext::binary\u0026gt;\u0026gt;} \u0026lt;- Base.decode64(ciphertext) We use pattern matching to extract first 16 byte and assign to iv and assign remaining data to ciphertext. Then decrypting data\n1plaintext = 2 :crypto.crypto_one_time(:aes_128_cbc, secret_key, iv, ciphertext, false) 3 |\u0026gt; unpad This line is similar to the line which encrypts data, the difference is here we replace plaintext by ciphertext and last parameter is set to false. After data is decrypted, we need to remove padding to get the original data.\n2. Build EncryptedText type I define a type to store binary data, you can define a EncryptedMap to store map data. The most important function are dump and load where we encrypt before persisting and decrypt after loading.\n1defmodule EncryptedText do 2 use Ecto.Type 3 4 # we store data as string 5 def type, do: :string 6 7 def cast(value) when is_binary(value) do 8 {:ok, value} 9 end 10 def cast(_), do: :error 11 12 def dump(nil), do: nil 13 # encrypt data before persist to database 14 def dump(data) when is_binary(data) do 15 with {:ok, secret_key} \u0026lt;- Application.fetch_env(:myapp, :ecto_secret_key), 16 {:ok, data} \u0026lt;- Crypto.encrypt(data, secret_key) do 17 {:ok, data} 18 else 19 _ -\u0026gt; :error 20 end 21 end 22 23 def dump(_), do: :error 24 25 def load(nil), do: nil 26 # decrypt data after loaded from database 27 def load(data) when is_binary(data) do 28 secret_key = Application.fetch_env!(:myapp, :ecto_secret_key) 29 case Crypto.decrypt(data, secret_key) do 30 {:error, _} -\u0026gt; :error 31 ok -\u0026gt; ok 32 end 33 end 34 35 def load(_), do: :error 36 37 def embed_as(_), do: :dump 38end 39 3. Use it in your schema  You must add secret key to your app config first.  1config :myapp, :ecto_secret_key, \u0026#34;your key using Crypto.generate_secret\u0026#34;  Add to schema  1schema \u0026#34;users\u0026#34; do 2 field :name, :string 3 ... 4 field :secret, EncryptedText 5 ... 6end Your data are safe now.\n4. Conclusion With Crypto you can implement encrypted field for any type of data you want.\nThere is an issue when you want to change your secret key, you have to load your data row by row, decrypt and then encrypt with new key and update to database.\nI found this article which explains very well about crypto if you are interested https://www.thegreatcodeadventure.com/elixir-encryption-with-erlang-crypto/ Although she uses old crypto API so it will throw some warnings.\nI implemented encrypted type for text and map for my company project here if you want to use it:\nGithub\nThanks for reading.\n","date":"20","image":"/img/encrypt-data-ecto.png","permalink":"https://bluzky.github.io/blog/2021-08-20-encrypt-data-with-ecto/","tags":["elixir","ecto","crypto"],"title":"How to encrypt your data with Ecto"},{"categories":null,"contents":" Credit: filter image taken from svgrepo.com\n In web developments, server receives lots of request data from client side. And when working with request params from client, my first rule is:\n Don\u0026rsquo;t believe the client\n Imagine that you provide API to list all post using the filter from client, and user may add user_id which point to other user, and you don\u0026rsquo;t remove that unexpected field from request params. If you don\u0026rsquo;t handle your logic carefully, you may accidentally leak data.\nSo every request should be cleaned from unexpected params, casted to the proper data type, and validated before passing to business layer.\nYou can achieve this by:\nUsing Ecto If you are building a web server using Phoenix, I guess Ecto is already in your dependencies. Just use it.\nThank to Ecto schemaless, you can build changeset from a dynamic schema:\n1defmodule MyApp.PostController do 2 ... 3 defp index_params(params) do 4 default = %{ 5 status: nil, 6 q: nil, 7 is_published: true 8 } 9 10 types = %{ 11 status: :string, 12 q: :string, 13 is_published: :boolean 14 } 15 16 changeset = 17 {default, types} 18 |\u0026gt; Ecto.Changeset.cast(params, Map.keys(types)) 19 20 if changeset.valid? do 21 {:ok, Ecto.Changeset.apply_changes(changeset)} 22 else 23 {:error, changeset} 24 end 25 end 26 27 def index(conn, params) do 28 with {:ok, valid_params} \u0026lt;- index_params(params) do 29 # do your logic 30 end 31 end 32 ... 33end With Ecto you can do validation on your params as you do with your schema changeset.\nThis way is simple and most of you are familiar with it. But you have to write much code and cannot cast and validate nested params.\nUse library Tarams This library provide a simple way to define schema. Let\u0026rsquo;s rewrite example above using tarams.\nFirst add this to your dependency list:\n{:tarams, \u0026quot;~\u0026gt; 1.0.0\u0026quot;} 1defmodule MyApp.PostController do 2 ... 3 @index_params %{ 4 status: :string, 5 q: :string 6 is_published: [type: :boolean, default: true], 7 page: [type: :integer, number: [min: 1]], 8 size: [type: :integer, number: [min: 10, max: 100]] 9 } 10 def index(conn, params) do 11 with {:ok, valid_params} \u0026lt;- Tarams.cast(params, @index_params) do 12 # do your logic 13 end 14 end 15 ... 16end And it support nested params too\n1defmodule MyApp.PostController do 2 ... 3 @create_params %{ 4 title: [type: :string, required: true], 5 content: [type: :string, required: true], 6 tags: [type: {:array, :string}], 7 published_at: :naive_datetime, 8 meta: %{ 9 tile: :string, 10 description: :string, 11 image: :string 12 } 13 } 14 def create(conn, params) do 15 with {:ok, valid_params} \u0026lt;- Tarams.cast(params, @create_params) do 16 MyApp.Content.create_post(valid_params) 17 end 18 end 19 ... 20end Conclusion All request params should be casted and validated at controller. Then you only work with data that you know what it is, and you don\u0026rsquo;t have to worry about unexpected parameters.\nThanks for reading, hope it can helps.\n","date":"14","image":"/img/validate-request-params.png","permalink":"https://bluzky.github.io/blog/2021-08-14-validate-request-params-with-phoenix/","tags":["elixir","phoenix","param validation"],"title":"How to validate request params in Phoenix"},{"categories":null,"contents":" Credit: this icon is from flaticon.com\n In previous article, I shown you how to implement you own validation module. I you haven\u0026rsquo;t read it, you can find it here How to build an Elixir validator from scratch \nAnd I think some of you may want a ready to use library so I wrapped it up, added some useful api and published on hex.pm and github repo here.\nThis post is just showcases of what it can do. (not too much fancy) First, add dependencies to your mix.exs and you are ready to go.\n1{:valdi, \u0026#34;~\u0026gt; 0.2.0\u0026#34;} And this is how it works.\nValidate using a specific validation function\n1iex(1)\u0026gt; age = 20 220 3iex(2)\u0026gt; Valdi.validate_number(age, min: 18, max: 60) 4:ok But most of the time you don\u0026rsquo;t do this, you will want to combine multiple validations at a time.\n1iex(4)\u0026gt; Valdi.validate(\u0026#34;20\u0026#34;, type: :integer, number: [min: 18, max: 60]) 2{:error, \u0026#34;is not a integer\u0026#34;} And you may want to validate a list of value too:\n1iex(1)\u0026gt; Valdi.validate_list([\u0026#34;hi\u0026#34;, \u0026#34;how\u0026#34;, \u0026#34;are\u0026#34;, \u0026#34;you\u0026#34;, 100], type: :string, length: [min: 3]) 2{:error, 3 [[0, \u0026#34;length must be greater than or equal to 3\u0026#34;], [4, \u0026#34;is not a string\u0026#34;]]} If validation failed, you got a list of error and index of error item.\nValdi supports you to validate a simple map with given specification:\n1product_spec = %{ 2 name: [type: :string, required: true], 3 sku: [type: :string, required: true], 4 price: [type: :integer, number: [min: 0]] 5} 6Valdi.validate_map(%{ 7 name: \u0026#34;A magic pen\u0026#34;, 8 sku: nil, 9 price: -1 10}, product_spec) 11 12# {:error, %{price: \u0026#34;must be greater than or equal to 0\u0026#34;, sku: \u0026#34;is required\u0026#34;}} Valdi does not support nested map validation.\nYou might want to take a look at Contrak, it extended Valdi by providing a simple way to define and validate nested schema.\nWhy I didn\u0026rsquo;t put those in just one library? I think data validation and schema validation are quite different, so I want to keep libraries simple and do its best thing.\nHere you can define your own validation\n1Valdi.validate(\u0026#34;as008x8234\u0026#34;, type: :string, func: fn value -\u0026gt; 2 if String.match?(value, ~r/^\\d{4}$/), do: :ok, else: {:error, \u0026#34;not a year string\u0026#34;} 3end) 4 5# {:error, \u0026#34;not a year string\u0026#34;} Hope this small library can help. If you have any suggestion please comment. Thank you.\n","date":"06","image":"/img/valdi-data-validator.webp","permalink":"https://bluzky.github.io/blog/2021-08-06-valdi-elixir-validator/","tags":["elixir","validation"],"title":"Easy data validation with with Valdi in Elixir"},{"categories":null,"contents":"Validation is a must have part of web application. You have to validate request parameter before processing, you validate data before inserting to database, and many more.\nNormally, I use Ecto.Changeset to do validation job. But it comes with changeset, I have to build schema, changeset then do the validation. Sometime you just don\u0026rsquo;t need too much thing like that.\nSo today we are going to build a simple validation module to use without changeset, or in some project you don\u0026rsquo;t use Ecto, or just for learning.\nWhat our validation module includes:  Type validation Number validation Length validation for map, list, string String format validation using regex Inclusion, exclusion validations  That\u0026rsquo;s is quite enough, you can define more if you want. And the module will support a simple API to validate a value\n1validate(value::any(), validations::keyword()) :: :ok | {:error, String.t()} Let\u0026rsquo;s start.\nType validation Let\u0026rsquo;s call our module Checky. Type check is quite straight forward. Elixir support most of type check guard that we need:\n1defmodule Checky do 2 def validate_type(value, :boolean) when is_boolean(value), do: :ok 3 def validate_type(value, :integer) when is_integer(value), do: :ok 4 def validate_type(value, :float) when is_float(value), do: :ok 5 def validate_type(value, :number) when is_number(value), do: :ok 6 def validate_type(value, :string) when is_binary(value), do: :ok 7 def validate_type(value, :binary) when is_binary(value), do: :ok 8 def validate_type(value, :tuple) when is_tuple(value), do: :ok 9 def validate_type(value, :array) when is_list(value), do: :ok 10 def validate_type(value, :list) when is_list(value), do: :ok 11 def validate_type(value, :atom) when is_atom(value), do: :ok 12 def validate_type(value, :function) when is_function(value), do: :ok 13 def validate_type(value, :map) when is_map(value), do: :ok 14 # we will add some more validation here 15 def validate_type(_, type), do: {:error, \u0026#34;is not a #{type}\u0026#34;} 16end Easy, right? Now let\u0026rsquo;s support checking for struct:\n1defmodule Checky do 2 3 ... 4 # from Elixir 1.12 you can do this 5 def validate_type(value, struct_name) when is_struct(value, struct_name), do: :ok 6 # this is for Elixir before 1.12 7 def validate_type(%{__struct__: struct}, struct_name) when struct == struct_name, do: :ok 8 ... 9end  Here we check for keyword  1defmodule Checky do 2 ... 3 # empty list is also a empty keyword 4 def validate_type([] = _check_item, :keyword), do: :ok 5 # if list item is a tuple of 2 and first element is atom then it is a keyword list 6 def validate_type(items, :keyword) when is_list(items) do 7 valid? = Enum.all(item, fn 8 {key, _} when is_atom(key) -\u0026gt; true 9 _ -\u0026gt; false 10 end) 11 12 if valid? do 13 :ok 14 else 15 {:error, \u0026#34;is not a keyword\u0026#34;} 16 end 17 end 18 ... 19end  Now let support array check {:array, type} which is similar to Ecto.Schema.  1defmodule Checky do 2 ... 3 def validate_type(value, {:array, type}) when is_list(value) do 4 # We will check type for each value in the list 5 array(value, \u0026amp;validate_type(\u0026amp;1, type)) 6 end 7 ... 8 # loop and validate element in array using `validate_func` 9 defp array(data, validate_func) 10 11 defp array([], _) do 12 :ok 13 end 14 15 # validate recursively, and return error if any vadation failed 16 defp array([h | t], validate_func) do 17 case validate_func.(h) do 18 :ok -\u0026gt; 19 array(t, validate_func) 20 err -\u0026gt; 21 err 22 end 23 end 24end Phew! We have done with type validation. You can add more type validation if you want.\nFormat Validation This validation is super easy, Regex do that for us:\n1defmodule Checky end 2 def validate_format(value, check) when is_binary(value) do 3 if Regex.match?(check, value), do: :ok, else: {:error, \u0026#34;does not match format\u0026#34;} 4 end 5 6 def validate_format(_value, _check) do 7 {:error, \u0026#34;format check only support string\u0026#34;} 8 end 9end Inclusion and exclusion validation These are trivial checks too. Just make sure it is implement Enumerable protocol.\n1defmodule Checky do 2 def validate_inclusion(value, enum) do 3 if Enumerable.impl_for(enum) do 4 if Enum.member?(enum, value) do 5 :ok 6 else 7 {:error, \u0026#34;not be in the inclusion list\u0026#34;} 8 end 9 else 10 {:error, \u0026#34;given condition does not implement protocol Enumerable\u0026#34;} 11 end 12 end 13 14 @doc \u0026#34;\u0026#34;\u0026#34; 15Check if value is **not** included in the given enumerable. Similar to `validate_inclusion/2` 16\u0026#34;\u0026#34;\u0026#34; 17 def validate_exclusion(value, enum) do 18 if Enumerable.impl_for(enum) do 19 if Enum.member?(enum, value) do 20 {:error, \u0026#34;must not be in the exclusion list\u0026#34;} 21 else 22 :ok 23 end 24 else 25 {:error, \u0026#34;given condition does not implement protocol Enumerable\u0026#34;} 26 end 27 end 28end Number validation This is one of the most complicated part of our module. It\u0026rsquo;s not difficult, it\u0026rsquo;s just long. We will support following checks:\n equal_to greater_than_or_equal_to | min greater_than less_than less_than_or_equal_to | max  And it should support multiple check like this:\n1 validate_number(x, [min: 10, max: 20]) First we code validation function for single condition like this\n1 def validate_number(number, {:equal_to, check_value}) do 2 if number == check_value do 3 :ok 4 else 5 {:error, \u0026#34;must be equal to #{check_value}\u0026#34;} 6 end 7 end As I said, it\u0026rsquo;s so simple. You can fill the remaining check right? Or you can check the final code at the end of the post. After implementing all validation fucntion for number, it\u0026rsquo;s time to support multiple condtion check.\n1 @spec validate_number(integer() | float(), keyword()) :: :ok | error 2 def validate_number(value, checks) when is_list(checks) do 3 if is_number(value) do 4 checks 5 |\u0026gt; Enum.reduce(:ok, fn 6 check, :ok -\u0026gt; 7 validate_number(value, check) 8 9 _, error -\u0026gt; 10 error 11 end) 12 else 13 {:error, \u0026#34;must be a number\u0026#34;} 14 end 15 end Length validation Length is just a number, so we can reuse number validation. We just have to check if given value is one of support types: list, map, string, and tuple\nWe will implement get_length/1 function to get data length first.\n1 @spec get_length(any) :: pos_integer() | {:error, :wrong_type} 2 defp get_length(param) when is_list(param), do: length(param) 3 defp get_length(param) when is_binary(param), do: String.length(param) 4 defp get_length(param) when is_map(param), do: param |\u0026gt; Map.keys() |\u0026gt; get_length() 5 defp get_length(param) when is_tuple(param), do: tuple_size(param) 6 defp get_length(_param), do: {:error, :wrong_type} Then we do number validation on the length value\n1 @spec validate_length(support_length_types, keyword()) :: :ok | error 2 def validate_length(value, checks) do 3 with length when is_integer(length) \u0026lt;- get_length(value), 4 # validation length number 5 :ok \u0026lt;- validate_number(length, checks) do 6 :ok 7 else 8 {:error, :wrong_type} -\u0026gt; 9 {:error, \u0026#34;length check supports only lists, binaries, maps and tuples\u0026#34;} 10 11 {:error, msg} -\u0026gt; 12 # we prepend length to message return by validation number to get full message 13 # like: \u0026#34;length must be equal to x\u0026#34; 14 {:error, \u0026#34;length #{msg}\u0026#34;} 15 end 16 end Combine all validation Most of time you want to use multiple valitions on the data. So we will add a function that do multiple validation\nWe define a simple structure for validation first. This is our validate function spec\n1 @spec validate(any(), keyword()) :: :ok | {:error, messages} Then we can use it like this:\n1Checky.validate(value, type: :string, format: ~r/\\d\\d.+/, length: [min: 8, max: 20]) Validations is a keyword list with short name for validation:\n :type -\u0026gt; validate_type :format -\u0026gt; validate_format :in -\u0026gt; validate_inclusion :not_in -\u0026gt; validate_exclusion :number -\u0026gt; validate_number :length -\u0026gt; validate_length  Define mapping function:\n1 defp get_validator(:type), do: \u0026amp;validate_type/2 2 defp get_validator(:format), do: \u0026amp;validate_format/2 3 defp get_validator(:number), do: \u0026amp;validate_number/2 4 defp get_validator(:length), do: \u0026amp;validate_length/2 5 defp get_validator(:in), do: \u0026amp;validate_inclusion/2 6 defp get_validator(:not_in), do: \u0026amp;validate_exclusion/2 7 defp get_validator(name), do: {:error, \u0026#34;validate_#{name}is not support\u0026#34;} 8 Go checking validations one by one\n1 def validate(value, validators) do 2 do_validate(value, validators, :ok) 3 end 4 5 defp do_validate(_, [], acc), do: acc 6 7 # check validations one by one 8 defp do_validate(value, [h | t] = _validators, acc) do 9 case do_validate(value, h) do 10 :ok -\u0026gt; do_validate(value, t, acc) 11 error -\u0026gt; error 12 end 13 end 14 15 # validate single validation 16 defp do_validate(value, {validator, opts}) do 17 case get_validator(validator) do 18 {:error, _} = err -\u0026gt; err 19 validate_func -\u0026gt; validate_func.(value, opts) 20 end 21 end Conclusion Writing a validation module is not so hard. Now you can add more validations to fit your need. As I promised, this is the full source of the module with custom validation fucntion. https://github.com/bluzky/valdi/blob/main/lib/valdi.ex\nThank you for reading to the end of this post. Please leave me a comment.\n","date":"31","image":"/img/build-json-validator.webp","permalink":"https://bluzky.github.io/blog/2021-07-31-build-elixir-validator-from-scratch/","tags":["elixir","validation"],"title":"How to build an Elixir validator from scratch"},{"categories":null,"contents":"In my previous article, I introduced my library call JsonView to render json response easier. You can read it here: Render Ecto schema to json with relationships with JsonView\nToday I will guide you to write your own Json render view. Let\u0026rsquo;s start.\nNow for example I have a Blog app with User Category , Post and Comment schemas.\nThis is PostView which is generated by Phoenix\n1defmodule MyBlogWeb.PostView do 2 use MyBlogWeb, :view 3 alias MyBlogWeb.PostView 4 5 def render(\u0026#34;index.json\u0026#34;, %{posts: posts}) do 6 %{data: render_many(posts, PostView, \u0026#34;post.json\u0026#34;)} 7 end 8 9 def render(\u0026#34;show.json\u0026#34;, %{post: post}) do 10 %{data: render_one(post, PostView, \u0026#34;post.json\u0026#34;)} 11 end 12 13 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 14 %{id: post.id, 15 title: post.title, 16 description: post.description, 17 content: post.content, 18 cover: post.cover, 19 is_published: post.is_published} 20 end 21end 22 Let\u0026rsquo;s improve it\n1. Use Map.take 1... 2def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 3\tMap.take(post, [:id, :title, :description, :content, :cover, :is_published]) 4end 5... This way you don\u0026rsquo;t have to write much code every time you add a new attribute.\n2. Render custom field You may want to:\n Format some field value instead of return original value Calculate virtual field  Normally you will do this:\n1\tdef render(\u0026#34;post.json\u0026#34;, %{post: post}) do 2 post 3 |\u0026gt; Map.take([:id, :title, :description, :content, :cover, :is_published]) 4 |\u0026gt; Map.merge(%{ 5 comment_count: render_comment_count(post), 6 author_name: render_author_name(post) 7 }) 8 end 9 10 def render_comment_count(post) do 11 ... 12 end 13 14 def render_author_name(post) do 15 ... 16 end Or you can reduce a bit of code by using pattern matching to render custom field value\n1\tdef render(\u0026#34;post.json\u0026#34;, %{post: post}) do 2 post 3 |\u0026gt; Map.take([:id, :title, :description, :content, :cover, :is_published]) 4 |\u0026gt; Map.merge(render_custom_fields(post, [:comment_count, :author_name])) 5 end 6 7 defp render_custom_fields(struct, fields) do 8 Enum.map(fields, fn field -\u0026gt; 9 {field, render_field(field, struct)} 10 end) 11 |\u0026gt; Enum.into(%{}) 12 end 13 14 defp render_field(:comment_count, post) do 15 ... 16 end 17 18 defp render_field(:author_name, post) do 19 ... 20 end Now every time you add a new custom field, just add field name to the list, and define a render_field/2 function\n3. Render relation ship You may want to return the whole object of author. For example you have a view UserView so you can do:\n1 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 2 post 3 ... 4 |\u0026gt; Map.merge(%{ 5 author: render_one(post.author, MyBlogWeb.UserView, \u0026#34;user.json\u0026#34;) 6 }) 7 end It requires that author must be loaded, if not, you will get this error\n** (KeyError) key :id not found in: #Ecto.Association.NotLoaded\u0026lt;association :author is not loaded\u0026gt; You can handle it by pattern matching against Ecto.Association.NotLoaded\n1 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 2 post 3 ... 4 |\u0026gt; Map.merge(%{ 5 author: render_relationship(post.author, MyBlogWeb.UserView, \u0026#34;user.json\u0026#34;) 6 }) 7 end 8 9 defp render_relationship(%Ecto.Association.NotLoaded{}, _, _), do: nil 10 11 defp render_relationship(relation, view, template) do 12 render_one(relation, view, template) 13 end And it only render relations struct if loaded, otherwise it is set to nil.\nNow you can improve it to render list of relationships\n1def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 2 post 3 ... 4 |\u0026gt; Map.merge( 5 render_relationship(post, [ 6 {:author, MyBlogWeb.UserView, \u0026#34;user.json\u0026#34;}, 7 {:comments, MyBlogWeb.CommentView, \u0026#34;comment.json\u0026#34;} 8 ]) 9 ) 10end 11 12defp render_relationship(struct, relationships) do 13 Enum.map(relationships, fn {field, view, template} -\u0026gt; 14 {field, render_relationship(Map.get(struct, field), view, template)} 15 end) 16 |\u0026gt; Enum.into(%{}) 17end 18 19defp render_relationship(%Ecto.Association.NotLoaded{}, _, _), do: nil 20 21defp render_relationship(relations, view, template) when is_list(relations) do 22 render_many(relations, view, template) 23end 24 25defp render_relationship(relation, view, template) do 26 render_one(relation, view, template) 27end With this way you can handle both single struct and list of struct.\n4. Combines these helper functions You can combine them all in one function and only need to pass field definition to this function\n1@fields [:id, :title, :description, :content, :cover, :is_published] 2 @custom_fiels [:comment_count, :author_name] 3 @relationships [ 4 {:author, MyBlogWeb.UserView, \u0026#34;user.json\u0026#34;}, 5 {:comments, MyBlogWeb.CommentView, \u0026#34;comment.json\u0026#34;} 6 ] 7 8 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 9 render_json(post, @fields, @custom_fiels, @relationships) 10 end 11 12 def render_json(struct, fields, custom_fields \\\\ [], relationships \\\\ []) do 13 struct 14 |\u0026gt; Map.take(fields) 15 |\u0026gt; Map.merge(render_custom_fields(struct, custom_fields)) 16 |\u0026gt; Map.merge(render_relationship(struct, relationships)) 17 end Move them to a helper These functions are the same for every view, so let\u0026rsquo;s move these code to a helper module JsonViewHelper\n1defmodule JsonViewHelper do 2 import Phoenix.View, only: [render_one: 3, render_many: 3] 3 4 def render_json(struct, view, fields, custom_fields \\\\ [], relationships \\\\ []) do 5 struct 6 |\u0026gt; Map.take(fields) 7 |\u0026gt; Map.merge(render_custom_fields(struct, view, custom_fields)) 8 |\u0026gt; Map.merge(render_relationship(struct, relationships)) 9 end 10 11 defp render_custom_fields(struct, view, fields) do 12 Enum.map(fields, fn field -\u0026gt; 13 {field, view.render_field(field, struct)} 14 end) 15 |\u0026gt; Enum.into(%{}) 16 end 17 18 defp render_relationship(struct, relationships) do 19 Enum.map(relationships, fn {field, view, template} -\u0026gt; 20 {field, render_relationship(Map.get(struct, field), view, template)} 21 end) 22 |\u0026gt; Enum.into(%{}) 23 end 24 25 defp render_relationship(%Ecto.Association.NotLoaded{}, _, _), do: nil 26 27 defp render_relationship(relations, view, template) when is_list(relations) do 28 render_many(relations, view, template) 29 end 30 31 defp render_relationship(relation, view, template) do 32 render_one(relation, view, template) 33 end 34end Here I modify render_custom_fields a bit, because we call render_field to render custom field, so we have pass the view module as second parameter, so we can use the module to invoke those render_field that we define.\nAnd now render json response is much simple:\n1defmodule BlogeeWeb.PostView do 2\t... 3 @fields [:id, :title, :description, :content, :cover] 4 @custom_fields [:status] 5 @relationships [ 6 {:author, BlogeeWeb.UserView, \u0026#34;basic_info.json\u0026#34;}, 7 {:category, BlogeeWeb.CategoryView, \u0026#34;category.json\u0026#34;} 8 ] 9 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 10 JsonViewHelper.render_json(post, __MODULE__, @fields, @custom_fields, @relationships) 11 end 12 13 def render_field(:status, post) do 14 if post.is_published do 15 \u0026#34;published\u0026#34; 16 else 17 \u0026#34;draft\u0026#34; 18 end 19 end 20end Hooray Thank you for reading to the end of this article. Hope that this can help. If you want to use render hook, take a look at my github for full code\nhttps://github.com/bluzky/json_view\n","date":"23","image":"/img/build-a-json-view.png","permalink":"https://bluzky.github.io/blog/2021-07-23-build-a-json-view-yourself/","tags":["elixir","phoenix","json view"],"title":"Build your own library to render json response in Phoenix"},{"categories":null,"contents":"When writing API with Phoenix and render json to client,\n For some fields I want to keep it original value. For some fields, I want to do some calculation or format data before returning. And I want to render Ecto association too.  An while working on an project at OnPoint I have build a little module that helps to do this easier.\nI have extract that module and release as a package named JsonView. Its source code is hosted on github:\nhttps://github.com/bluzky/json_view\nYou can use it with Phoenix.View or use it independently. It helps to manipulate data, and handle rendering association automatically.\nI have published an article on how to write it A better way to render json response in Elixir Phoenix\nLet\u0026rsquo;s take a look.\nFirst define view modules\n1 defmodule MyApp.UserView do 2 use JsonView 3 def render(\u0026#34;user.json\u0026#34;, %{user: user}) do 4 render_json(user, [:first_name, :last_name, :vatar], [], []) 5 end 6 end 7 8 defmodule MyApp.PostView do 9 use JsonView 10 11 # define which fields return without modifying 12 @fields [:title, :content, :excerpt, :cover] 13 # define which fields that need to format or calculate, you have to define `render_field/2` below 14 @custom_fields [:like_count] 15 # define which view used to render relationship 16 @relationships [author: MyApp.UserView] 17 18 def render(\u0026#34;post.json\u0026#34;, %{post: post}) do 19 # 1st way if `use JsonView` 20 render_json(post, @fields, @custom_fields, @relationships) 21 end 22 23 def render_field(:like_count, item) do 24 # load like_count from some where 25 end 26 end And then use it\n1post = %Post{ 2\ttitle: \u0026#34;Hello JsonView\u0026#34;, 3\texcerpt: \u0026#34;Now you can render Json easier\u0026#34;, 4\tcontent: \u0026#34;Install and put it to work\u0026#34;, 5\tcover: nil, 6\tinserted_at: ~N[2021-07-05 00:00:00], 7\tupdated_at: ~N[2021-07-09 00:00:00], 8\tauthor: %User{ 9\tfirst_name: \u0026#34;Daniel\u0026#34;, 10\tlast_name: \u0026#34;James\u0026#34;, 11\temail: \u0026#34;daniel@example.com\u0026#34;, 12\tavatar: nil, 13\tinserted_at: ~N[2021-06-30 00:00:00] 14\tupdated_at: ~N[2021-07-02 00:00:00] 15\t} 16} 17 18MyApp.PostView.render(\u0026#34;post.json\u0026#34;, %{post: post}) 19 20# or invoke from PostController 21render(conn, \u0026#34;post.json\u0026#34;, post: post) This is the result that you can use to return from PhoenixController\n1%{ 2\ttitle: \u0026#34;Hello JsonView\u0026#34;, 3\texcerpt: \u0026#34;Now you can render Json easier\u0026#34;, 4\tcontent: \u0026#34;Install and put it to work\u0026#34;, 5\tcover: nil, 6 like_count: nil, 7\tauthor: %{ 8\tfirst_name: \u0026#34;Daniel\u0026#34;, 9\tlast_name: \u0026#34;James\u0026#34; 10\t} 11} If you have any feedback, please comment or create an issue.\nIn the next post I will go through step by step to write this library.\n","date":"10","image":"/img/json-view.png","permalink":"https://bluzky.github.io/blog/2021-07-10-render-response-json-view/","tags":["elixir","phoenix","json view","ecto"],"title":"Elixir phoenix - Render Ecto schema to json with relationships"},{"categories":null,"contents":"What is Guard in Elixir In previous post, I explain what is Pattern Matching and how to use it.\nElixir pattern matching in a nutshell\nPattern matching is so cool but some time I want to do some more complicated checking. With pattern matching I can easily do this\n1def can_access?(%User{paid_user: true}), do: true Yes, Pattern matching can do check value with exact value easily. But for example, I want to allow user with level \u0026gt; 25 to access.\nHow to do that check with Pattern matching?\nPattern matching as it\u0026rsquo;s named, it is used to match data against pattern. If you want to do more complex check, you need another guy. That is where guard shines, it is complement for Pattern Matching\n1def can_access?(%User{level: level}) when level \u0026gt; 25, do: true What is guard   Guard is a complement to your pattern matching to do more complex check.\n  Guard expression is invoke after pattern mattching\n  In many cases, Guard and Pattern matching can produce the same result, so use which you like.\n  1# sum on empty list 2# pattern matching 3def sum_list([] = _input), do: 0 4 5# guard 6def sum_list(input) when input == [], do: 0 Some example\n  Check primitive type\n1def sum(a, b) when is_integer(a) and is_integer(b) do 2\ta + b 3end   Check value is nil/ not nil\n1def string_length(string) when not is_nil(string) do 2\t# your code 3end   Check if input in a list of allowed values\n1def can_edit?(%User{role: role}) when role in [\u0026#34;admin\u0026#34;, \u0026#34;moderator\u0026#34;] do 2\ttrue 3end   And many more \u0026hellip;\n  Where to use guard? Where you can use Pattern Matching, you can use Guard\n  case block\n1case value do 2\tx when is_binary(x) -\u0026gt; String.to_integer(x) 3\tx when is_integer(x) -\u0026gt; x 4\t_ -\u0026gt; raise \u0026#34;Invalid value\u0026#34; 5end   with block\n1with user when not is_nil(user) \u0026lt;- find_user(id) do 2\t# your code block 3end   function clause as our example above\n  Why my guard not work? Not all expression will work with guard. Only a list of built-in guard and combination of them work in guard expression.\nCheck this from https://hexdocs.pm/elixir/guards.html#list-of-allowed-expressions\n  comparison operators (==, !=, ===, !==, \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=) strictly boolean operators (and, or, not). Note \u0026amp;\u0026amp;, ||, and ! sibling operators are not allowed as they\u0026rsquo;re not strictly boolean - meaning they don\u0026rsquo;t require arguments to be booleans arithmetic unary and binary operators (+, -, +, -, *, /) in and not in operators (as long as the right-hand side is a list or a range) \u0026ldquo;type-check\u0026rdquo; functions (is_list/1, is_number/1, etc.) functions that work on built-in datatypes (abs/1, map_size/1, etc.)   Can I define my own guard? Yes you can define a guard with defguard/1 and defguardp/1 . But you should only define your own guard if you have a really really reasonable reason to do so.\nIn my experience, I have never defined a guard my own, built-in guards are too enough.\nConclustion With Pattern matching and Guard, you have a super powerful combo in your hand. Let\u0026rsquo;s code!\n","date":"30","image":"/img/elixir-guard.webp","permalink":"https://bluzky.github.io/blog/2021-06-30-elixir-for-beginner-all-you-need-to-know-about-guard/","tags":["elixir","elixir-beginner"],"title":"Elixir for Beginner - All you need to know about guard"},{"categories":null,"contents":"If you are new to Elixir, Pattern Matching may be something strange to you. When you get familiar with it, you will know how powerful it is. And I\u0026rsquo;m sure that you will definite love it. Pattern matching is used everywhere in your elixlir code . And I would bring it to other language that I use ( if I can :D)\nBut it\u0026rsquo;s not so hard.\nWhat does Pattern Matching do? Give you a variable/value, you might want\n Check if data type is match your expected data type Check if structure of data match your expected data structure Assign matching part of data to a variable  And pattern matching do all these thing for you. Just look at some example.\nWhen you try these example, it will raise exception if data doesn\u0026rsquo;t match against the pattern. In real Elixir app, you won\u0026rsquo;t use it this way, check Where it is used at the end of this article\nPattern matching with Map/Struct 1. Check if this data is a map\n1%{} = params 2. Check if data is a map and has key email and email value is zoo@example.com\n1%{\u0026#34;email\u0026#34; =\u0026gt; \u0026#34;zoo@example.com\u0026#34;} = params 3. Check if data is a map and has key email, if matchs pattern, assign value of key email to variable my_email\n1%{\u0026#34;email\u0026#34; =\u0026gt; my_email} = params 4. Check if data is a map and has key email, I don\u0026rsquo;t want to extract value\nuse _ to ignore value\n1%{\u0026#34;email\u0026#34; =\u0026gt; _} = params 5. Pattern matching nested map\n1%{\u0026#34;address\u0026#34; =\u0026gt; %{\u0026#34;city\u0026#34; =\u0026gt; city}} = params 6. Check if data is type struct User\n1%User{} = params  The rest is same with map. Struct is basically a map with atom key.\n Pattern matching with List 1. Check if data is empty lis\n1[] = params 2. Check if data is a list and not empty\n1[_|_] = params 3. Check if data is exact list\n1[1, 2] = params 4. Check if data is list and extract first element and remaining\n1[first_element | remaining] = params Pattern matching with Tuple You don\u0026rsquo;t have much pattern to match against tuple\n1. Check if data is tuple of 2 elements\n1{_, _} = params 2. Check if data is tuple and has specific value\n1{:ok, data} = result 2# you use this most of time Where to use pattern matching 1. case clause\n1case user do 2\t%User{is_active: true} -\u0026gt; \u0026#34;Log you in\u0026#34; 3\t%User{is_active: false} -\u0026gt; \u0026#34;Check your email\u0026#34; 4\t_others -\u0026gt; \u0026#34;Not a user\u0026#34; 5end 2. with clause\n1with {:ok, user} \u0026lt;- create_user(params) do 2\t# your code 3end 3. function\n1def is_admin(%User{role: \u0026#34;admin\u0026#34;}), do: true 2def is_admin(%User{role: _}), do: false 3def is_admin(_), do: raise \u0026#34;Not a user\u0026#34; Conclusion At first, it\u0026rsquo;s a bit strange to grasp, but gradually you can live without it. It is one of Elixir\u0026rsquo;s features that I love most. And I think you will. Using it more and its power is in your hand.\n","date":"29","image":"/img/pattern-matching.png","permalink":"https://bluzky.github.io/blog/2021-06-29-elixir-pattern-matching-in-a-nut-shell/","tags":["elixir","elixir-beginning"],"title":"Elixir Pattern Matching in a nut shell"},{"categories":null,"contents":"The story At our company, OnPoint, we are building an ecommerce website using Phoenix Framework. And I am working on admin to manage product, orders \u0026hellip; All the listing pages need a filter and this filter change frequently, operation team wants to add this field, order by that field. And each time they change their requirements I have to update query code.\nMy team use Django Admin before, they support an easy way to compose query directly from the URL. You don\u0026rsquo;t have to change code on the back-end. It\u0026rsquo;ll be great if I can do it with Phoenix.\nWhat it should have:\n Support basic query operator: \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=, =, !=, like, ilike, in Query join table Can sort result  This is the result after some night of work:\nhttps://github.com/bluzky/querie\nHow it work  I define a simple rule for passing parameter from client side. The key must follow format [column]__[operator]=[value]. On the server side, it is parsed to {operator, {column, value}} with appropriate data type Then it is passed to a filter function to build Ecto query dynamically  You can try with example project to see how it works.\nHow to use it 1. Define a filter schema For example you have a Post schema:\n1defmodule Example.Content.Post do 2 use Ecto.Schema 3 import Ecto.Changeset 4 5 def state_enum(), do: ~w(draft published archived trash) 6 7 schema \u0026#34;posts\u0026#34; do 8 field(:content, :string) 9 field(:state, :string, default: \u0026#34;draft\u0026#34;) 10 field(:title, :string) 11 field(:view_count, :integer, default: 0) 12 belongs_to(:category, Example.PostMeta.Category) 13 belongs_to(:author, Example.Account.User) 14 end 15end And you want to filter the Post by title, state, view_count. This is the filter schema:\n1@schema %{ 2 title: :string, 3 state: :string, # short form 4 view_count: [type: :integer] # long form 5} 2. Parse request parameters and build the query Use Querie.parse/2 to parse request parameters with your schema\n1alias Example.Content.Post 2 3def index(conn, params) do 4 with {:ok, filter} \u0026lt;- Querie.parse(@schema, params) do 5\tquery = Querie.filter(Post, filter) 6\t# Or you can pass a query like this 7\t# query = from(p in Post, where: ....) 8\t# query = Querie.filter(query, filter) 9\tposts = Repo.all(query) 10\t# do the rendering here 11 else 12 {:error, errors} -\u0026gt; 13\tIO.puts(inspect(errors) 14\t# or do anything with error 15\t# error is a list of tuple {field, message} 16 end 17end 3. Compose URL Then from client side you can send a form:\n1\u0026lt;form action=\u0026#34;/posts\u0026#34;\u0026gt; 2 \u0026lt;label\u0026gt;Titlte\u0026lt;/label\u0026gt; 3 \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title__icontains\u0026#34;\u0026gt; 4 \u0026lt;label\u0026gt;State\u0026lt;/label\u0026gt; 5 \u0026lt;select name=\u0026#34;state\u0026#34;\u0026gt; 6 \u0026lt;option value=\u0026#34;draft\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; 7 \u0026lt;option value=\u0026#34;published\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; 8 \u0026lt;option value=\u0026#34;trashed\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; 9 \u0026lt;/select\u0026gt; 10 \u0026lt;label\u0026gt;View count greater than\u0026lt;/label\u0026gt; 11 \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;view_count__ge\u0026#34;\u0026gt; 12\u0026lt;/form\u0026gt; Or directly from URL with data like this:\nhttp://localhost:4000/posts?title__icontains=elixir\u0026amp;state=published\u0026amp;view_count__ge=100 Enter and see the result\nQuery joined table It quite simple to filter result with filter on joined tables.\n1. Update your query Querie support ref operator to join tables. For example you want to query Post by author whose email contains sam the query would be:\n?author__ref[email__icontains]=sam 2. Update your schema 1alias Example.Account.User 2 3@schema %{ 4 title: :string, 5 state: :string, 6 view_count: [type: :integer], 7 author: [ 8\ttype: :ref, # this references to another schema 9\tmodel: User, # which schema to query 10\tschema: %{ # define filter schema for User 11\temail: :string 12\t} 13\t] 14} For more query options, please read document\nIf you have any suggestion, please leave a comment or open an issuse on Github.\nThanks for reading.\n","date":"30","image":"/img/request-to-query.png","permalink":"https://bluzky.github.io/blog/2020-10-30-compose-ecto-query-from-client/","tags":["elixir","phoenix","query","ecto","querie"],"title":"Compose Ecto Query From Client"},{"categories":null,"contents":"**Version mới của thư viện Tarams không tương thích với bản cũ. Các bạn đọc bài mới ở đây nhé How to validate request params in Phoenix\nYêu cầu chuẩn hoá và validate các tham số truyền lên từ client là yêu cầu cơ bản khi xây dựng API Web. Mình đã có một bài hướng dẫn sử dụng Ecto.Changeset để chuẩn hoá trong bài viết này:\nParse và validate request param trong Phoenix với Ecto \nTrong bài viết này, mình sẽ hướng dẫn một cách ngắn và đơn giản hơn bằng cách sử dụng thư viện sẵn có Tarams. Thư viện này thực ra là sử dụng lại Ecto.Changeset nhưng nó giúp cho chúng ta không phải lặp lại quá nhiều code như khi dùng Ecto.Changeset\nMột vài tính năng thú vị của Tarams:\n Cung cấp cách thức đơn giản để định nghĩa các cấu trúc tham số Cho phép định nghĩa các giá trị default động Cho phép định nghĩa các hàm để cast giá trị về đúng kiểu dữ liệu Định nghĩa hàm để validate dữ liệu  Sau đây là cách sử dụng Tarams. Ví dụ chúng ta đang viết API để cập nhật profile của nhân viên. Yêu cầu là\nemail: bắt buộc, đúng định dạng first_name: bắt buộc last_name: bắt buộc birthday: không bắt buộc, kiểu ngày tháng title: không bắt buộc start_date: ngày bắt đầu làm việc, ngày tháng, mặc định là ngày hiện tại 1. Định nghĩa cấu trúc của tham số truyền lên khá đơn giản 1@schema %{ 2 email: [type: :string], 3 first_name: [type: :string], 4 last_name: [type: :string], 5 title: :string, 6 birth_day: [type: :date], 7 start_date: [type: :date] 8} Schema đơn giản chỉ là một map với key là tên field và value là 1 list option của field đó.\n2. Bây giờ thêm các ràng buộc  Để đánh dấu 1 trường là bắt buộc, thêm option required: true Taram cũng cho phép validate data sử dụng lại các hàm validate của Changeset  1@schema %{ 2 email: [type: :string, required: true, validate: {:format, ~r/@/}], 3 first_name: [type: :string, required: true], 4 last_name: [type: :string, required: true], 5 title: :string, 6 birth_day: [type: :date], 7 start_date: [type: :date] 8} 3. Bây giờ thì set các giá trị default default có thể là 1 giá trị hoặc 1 hàm. Mỗi khi parse tham số thì hàm này sẽ được gọi để lấy giá trị mặc định\n1@schema %{ 2 ... 3 title: [type: :string, default: \u0026#34;staff\u0026#34;], 4 birth_day: [type: :date], 5 start_date: [type: :date, default: \u0026amp;Timex.today/0] 6} 4. Cast các giá trị tham số về đúng kiểu Nhiều các giá trị tham số truyền lên phải được chuyển về đúng các loại dữ liệu phức tạp như ngày tháng, list. Ví dụ ngày tháng truyền lên là string 01/12/1994 thì phải chuyển về kiểu date để sử dụng lại được. Tarams hỗ trợ định nghĩa 1 hàm custom để cast giá trị, hàm này trả về\n {:ok, value} nếu parse thành công {:error, error_message} nếu thất bại  1def parse_date(date_str) do 2 Timex.parse(date_str, \u0026#34;{0D}/{0M}/{YYYY}\u0026#34;) 3end 4 5@schema %{ 6 ... 7 title: [type: :string, default: \u0026#34;staff\u0026#34;], 8 birth_day: [type: :date, cast_func: \u0026amp;parse_date/1], 9 start_date: [type: :date, default: \u0026amp;Timex.today/0] 10} 5. Bây giờ sử dụng nào 1def update(conn, params) do 2 with {:ok, user_data} \u0026lt;- Tarams.parse(@schema, params) do 3 # do anything with your params 4 # access data bằng atom key: user_data.email 5 else 6 {:error, changset} -\u0026gt; # return params error 7 end 8end Hàm parse sẽ parse và validate dữ liệu. Nếu mọi thứ đều ổn, sẽ trả về {:ok, data} và ngược lại thì trả về {:error, changeset}.\nDone! Code của bạn sẽ trở nên đơn giản và ngắn gọn hơn nhiều\n","date":"01","image":"/img/tarams-parse.png","permalink":"https://bluzky.github.io/blog/2020-10-01parse-validate-data-with-tarams/","tags":["elixir","ecto","phoenix","tarams"],"title":"Chuẩn hoá và validate dữ liệu trong Phoenix với thư viện Tarams"},{"categories":null,"contents":"Khi viết các API hoặc cả các endpoint thì thông thường chúng ta sẽ có một số nhu cầu:\n Chỉ cho phép một số các tham số xác định được truyền vào. Chuyển các tham số về kiểu dữ liệu mong muốn Validate các tham số theo yêu cầu  Bài viết này sẽ hướng dẫn các bạn giải quyết các vấn đề trên sử dụng Ecto.Changeset\nThư viện Ecto đã cung cấp sẵn cho chúng ta module Changeset. Nó hỗ trợ việc cast các tham số về đúng kiểu dữ liệu mong muốn, nó cũng hỗ trợ các phương thức để validate các tham số yêu cầu, và nó cũng cho phép bạn giới hạn tham số nào được truyền vào.\nVà sau đây là một ví dụ sử dụng Chageset để validate các tham số khi filter các đơn hàng.\n1. Đầu tiên bạn phải định nghĩa một schema 1defmodule MyApp.OrderFilterParams do 2 use Ecto.Schema 3 import Ecto.Changeset 4 5 schema \u0026#34;order_filter_params\u0026#34; do 6 field :keyword, :string 7 field :category_id, :integer 8 field :status, :string 9 field :start_date, :utc_datetime 10 field :end_date, :utc_datetime 11 end 12end 2. Cast và validate Sau đó phải định nghĩa một hàm để thực hiện việc cast tham số và validate changeset.\n1defmodule MyApp.OrderFilterParams do 2 3 ... 4 5 @required ~w(category_id start_date) 6 @optional ~w(keyword status end_date) 7 8 def changeset(changeset_or_model, params) do 9 cast(changeset_or_model, params, @required ++ @optional) 10 |\u0026gt; validate_required(@required) 11 end 12end 3. Set giá trị default động Nếu bạn muốn sử dụng các giá trị default động, ví dụ như mặc định ngày kết thúc là ngày hiện tại, các bạn phải định nghĩa một function để set giá trị mong muốn.\n1defmodule MyApp.OrderFilterParams do 2 3 ... 4 5 def changeset(changeset_or_model, params) do 6 cast(changeset_or_model, params, @required ++ @optional) 7 |\u0026gt; validate_required(@required) 8 |\u0026gt; set_default_end_date() 9 end 10 11 defp set_defaut_end_date(changeset) do 12 end_date = get_change(changeset, :end_date) 13 if is_nil(end_date) do 14 put_change(changeset, :end_date, Timex.today()) 15 else 16 changeset 17 end 18 end 19end 4. Sử dụng Params schema 1defmodule MyApp.OrderController do 2 use MyApp, :controller 3 alias MyApp.OrderFilterParams 4 5 def index(conn, params) do 6 changeset = OrderFilterParams.changeset(%OrderFilterParams{}, params) 7 8 if changeset.valid? do 9 strong_params = Ecto.Changeset.apply_changes(changeset) 10\tIO.put(strong_params.keyword) 11 # Do something with your params 12 else 13 # handle error 14 end 15 end 16end 17 Rất đơn giản đúng không, nếu bạn đã sử dụng Ecto thì việc này chỉ là ruồi muỗi. Tuy nhiên đơn giản thì phải có thứ đánh đổi chứ.\nVài thứ mà bạn sẽ thấy bất tiện 1. Lượng code mà bạn phải viết quá nhiều. Thử tưởng tượng mỗi API bạn lại phải định nghĩa thêm một Module params cho nó thì phức tạp vl.\nBạn có thể sử dụng schemaless, nhưng mà function của bạn sẽ rối nùi lên vì code logic và code xử lý params nó không liên quan gì tới nhau cả. Và bạn thì kiểu như đổ sting vào cơm để ăn vậy.\n2. Thiếu linh hoạt. Điều này cũng đúng vì mục đích chính của Ecto là phục vụ cho việc định nghĩa các schema cho database.\nĐơn giản như việc định nghĩa giá trị default động như trên, bạn phải viết luôn 1 hàm mới\nTuy nhiên nó cũng có một ưu điểm là bạn không phải sử dụng thêm thư viện của bên thứ ba.\nKết Nếu bạn không cần phải xử lý nhiều ràng buộc liên quan đến tham số của request thì đơn giản là cứ dùng Changeset thôi.\nNếu bạn muốn nhanh gọn hơn thì trên Hex có một số thư viện để hỗ trợ định nghĩa param đơn giản hơn, ví dụ như https://github.com/bluzky/tarams/\nThư viện này cung cấp cách thức đơn giản và nhanh chóng hơn để định nghĩa param cho API. Mình sẽ viết bài hướng dẫn sau.\n","date":"26","image":"/img/parse-ecto-phoenix.png","permalink":"https://bluzky.github.io/blog/validate-request-params-phoenix-ecto/","tags":["elixir","ecto","phoenix"],"title":"Parse và validate request param trong Phoenix với Ecto"},{"categories":null,"contents":" Bài viết này sẽ hướng dẫn các bạn sử dụng ETS như là bộ nhớ cache để tăng tốc các ứng dụng web Phoenix\n Dành cho các bạn chưa biết:\n ETS (Erlang Term Storage) là cơ sở dữ liệu dạng key-value lưu trữ trên RAM, tương tự như Memcache và Redis, với ưu điểm là tốc độ truy xuất cực nhanh. Đọc thêm về ETS Cache là việc lưu lại các kết quả xử lý của request vào bộ nhớ và trả về cho các request sau mà không cần phải tính toán lại -\u0026gt; giảm response time.  1. Setup project   Tạo 1 project mới\n1mix phx.new phoenix_cache 2mix deps.get   Thêm chức năng tạo/xoá/sửa bài viết\n1mix phx.gen.html Posts Post posts title:string summary:text content:text 2mix ecto.create 3mix ecto.migrate   Vào http://0.0.0.0:4000/posts để xem chức năng bài viết. Thêm vài bài viết để có dữ liệu test   2. Tạo một module để quản lý cache Do table trong ETS sẽ bị huỷ khi process khởi tạo table kết thúc, nên cần phải có 1 process luôn luôn chạy để table không bị xoá. Sử dụng GenServer để quản lý Cache là tiện nhất vì nó được cung cấp sẵn bởi Elixir. Đọc thêm về GenServer\n2.1 Tạo module Tạo một file mới phoenix_cache/lib/phoenix_cache/bucket.ex\n1defmodule PhoenixCache.Bucket do 2 use GenServer 3 alias :ets, as: Ets 4 5 # thời gian sống của 1 entry mặc định là 6 phút 6 @expired_after 6 * 60 7 8 def start_link(args \\\\ []) do 9 GenServer.start_link(__MODULE__, args, name: __MODULE__) 10 end 11end 2.2 Khởi tạo cache table khi bắt đầu chạy GenServer 1def init(state) do 2 Ets.new(:simple_cache, [:set, :protected, :named_table, read_concurrency: true]) 3 {:ok, state} 4end Module cache sẽ hỗ trợ 3 thao tác:\n set: lưu data vào bộ nhớ cache get: lấy data từ bộ nhớ cache delete: xoá data khỏi cache (cái này có vẻ không cần lắm thì phải)  2.3 Thêm data vào cache 1 2 def set(key, value) do 3 GenServer.cast(__MODULE__, {:set, key, value}) 4 end 5 6 @doc \u0026#34;\u0026#34;\u0026#34; 7Default TTL 8\u0026#34;\u0026#34;\u0026#34; 9 def handle_cast({:set, key, val}, state) do 10 expired_at = 11 NaiveDateTime.utc_now() 12 |\u0026gt; NaiveDateTime.add(@expired_after, :second) 13 14 Ets.insert(:simple_cache, {key, val, expired_at}) 15 {:noreply, state} 16 end Ở đây chúng ta sẽ tạo tính toán thời điểm expire/hết hạn của giá trị cache, tính từ thời điểm hiện tại, sử dụng giá trị TTL(thời gian sống) mặc định là 6phút. Bạn có thể cấu hình lưu TTL mặc định vào config hoặc biến môi trường. Mình lưu vào thuộc tính module cho tiện.\n2.4 Thêm data vào cache và thiết lập thời gian sống của data Để có thể thoải mái thiết lập TTL, ta thêm 1 hàm cho phép truyền vào tham số TTL\n1@doc \u0026#34;\u0026#34;\u0026#34; 2Custom TTL for cache entry 3ttl: Time to live in second 4\u0026#34;\u0026#34;\u0026#34; 5 def set(key, value, ttl) do 6 GenServer.cast(__MODULE__, {:set, key, value, ttl}) 7 end 8 9 @doc \u0026#34;\u0026#34;\u0026#34; 10Custom TTL 11\u0026#34;\u0026#34;\u0026#34; 12 def handle_cast({:set, key, val, ttl}, state) do 13 inserted_at = 14 NaiveDateTime.utc_now() 15 |\u0026gt; NaiveDateTime.add(ttl, :second) 16 17 Ets.insert(:simple_cache, {key, val, inserted_at}) 18 {:noreply, state} 19 end Cũng tương tự như trên nhưng hàm set sẽ nhận thêm tham số thứ 3 là TTL thay vì xài giá trị mặc định.\n2.5 Truy xuất dữ liệu từ cache Có vào thì phải có lấy ra chứ nhỉ, bây giờ ta sẽ thêm code để truy xuất data từ cache.\n1 def get(key) do 2\t# lấy giá trị đầu tiên tìm đuợc 3 rs = Ets.lookup(:simple_cache, key) |\u0026gt; List.first() 4 5\t# Nếu không tìm thấy thì trả về lỗi 6 if rs == nil do 7 {:error, :not_found} 8 else 9 expired_at = elem(rs, 2) 10\t11\t# So sánh thời điểm hết hạn với hiện tại, nếu hết hạn thì trả về lỗi 12 cond do 13 NaiveDateTime.diff(NaiveDateTime.utc_now(), expired_at) \u0026gt; 0 -\u0026gt; 14 {:error, :expired} 15 16 true -\u0026gt; 17 {:ok, elem(rs, 1)} 18 end 19 end 20 end Note: Nhờ feedback của bác @HQC, chỗ này mình đọc trực tiếp từ table, thay vì dùng GenServer.call như trước vì khi send request vào GenServer thì code sẽ được chạy sync/đồng bộ. Do vậy sẽ tạo nên ngẽn cổ chai. Mình sửa lại ở phần tạo table thêm read_concurrency: true và đưa phần code query dữ liệu ra ngoài GenServer\n2.6 Xoá dữ liệu khỏi cache 1 def delete(key) do 2 GenServer.cast(__MODULE__, {:delete, key}) 3 end 4 5 def handle_cast({:delete, key}, state) do 6 Ets.delete(:simple_cache, key) 7 {:noreply, state} 8 end 2.7 Module hoàn chỉnh 1defmodule PhoenixCache.Bucket do 2 use GenServer 3 alias :ets, as: Ets 4 5 @expired_after 6 * 60 6 7 def start_link(args \\\\ []) do 8 GenServer.start_link(__MODULE__, args, name: __MODULE__) 9 end 10 11 def set(key, value) do 12 GenServer.cast(__MODULE__, {:set, key, value}) 13 end 14 15 @doc \u0026#34;\u0026#34;\u0026#34; 16Custom TTL for cache entry 17ttl: Time to live in second 18\u0026#34;\u0026#34;\u0026#34; 19 def set(key, value, ttl) do 20 GenServer.cast(__MODULE__, {:set, key, value, ttl}) 21 end 22 23 def get(key) do 24 rs = Ets.lookup(:simple_cache, key) |\u0026gt; List.first() 25 26 if rs == nil do 27 {:error, :not_found} 28 else 29 expired_at = elem(rs, 2) 30 31 cond do 32 NaiveDateTime.diff(NaiveDateTime.utc_now(), expired_at) \u0026gt; 0 -\u0026gt; 33 {:error, :expired} 34 35 true -\u0026gt; 36 {:ok, elem(rs, 1)} 37 end 38 end 39 end 40 41 def delete(key) do 42 GenServer.cast(__MODULE__, {:delete, key}) 43 end 44 45 # Server callbacks 46 # Server (callbacks) 47 48 @impl true 49 def init(state) do 50 Ets.new(:simple_cache, [:set, :protected, :named_table, read_concurrency: true]) 51 {:ok, state} 52 end 53 54 @doc \u0026#34;\u0026#34;\u0026#34; 55Default TTL 56\u0026#34;\u0026#34;\u0026#34; 57 def handle_cast({:set, key, val}, state) do 58 expired_at = 59 NaiveDateTime.utc_now() 60 |\u0026gt; NaiveDateTime.add(@expired_after, :second) 61 62 Ets.insert(:simple_cache, {key, val, expired_at}) 63 {:noreply, state} 64 end 65 66 @doc \u0026#34;\u0026#34;\u0026#34; 67Custom TTL 68\u0026#34;\u0026#34;\u0026#34; 69 def handle_cast({:set, key, val, ttl}, state) do 70 inserted_at = 71 NaiveDateTime.utc_now() 72 |\u0026gt; NaiveDateTime.add(ttl, :second) 73 74 Ets.insert(:simple_cache, {key, val, inserted_at}) 75 {:noreply, state} 76 end 77 78 @impl true 79 def handle_cast({:delete, key}, state) do 80 Ets.delete(:simple_cache, key) 81 {:noreply, state} 82 end 83end 84 3. Setup cache Ta đã tạo xong module cache rồi, nhưng làm sao để cache tự động chạy khi chạy server?\nThêm worker vào file phoenix_cache/lib/phoenix_cache/application.ex\n1children = [ 2 ... 3 worker(PhoenixCache.Bucket, []) 4 ] Khi Supervisor khởi chạy, nó sẽ start các children và quản lý chúng. Để hiểu rõ hơn, đọc thêm tại https://hexdocs.pm/elixir/Supervisor.html\n4. Xài cache Olala, ta đã tạo module cache và thiết lập để chạy cùng với server, bây giờ tới lúc xài nó rồi.\nThử dùng cache cho chức năng xem bài viết:\n1def show(conn, %{\u0026#34;id\u0026#34; =\u0026gt; id}) do 2 post = 3 # lấy nội dung post từ cache 4 case PhoenixCache.Bucket.get(\u0026#34;posts-#{id}\u0026#34;) do 5 # Nếu có ròi thì khỏi cần đọc DB 6 {:ok, post} -\u0026gt; 7 IO.puts(\u0026#34;HIT\u0026#34;) 8 post 9 10 {:error, _} -\u0026gt; 11 IO.puts(\u0026#34;MISS\u0026#34;) 12 # Chưa cache thì đọc từ DB 13 post = Posts.get_post!(id) 14 15 # cache bài viết 60s 16 PhoenixCache.Bucket.set(\u0026#34;posts-#{id}\u0026#34;, post, 60) 17 post 18 end 19 20 render(conn, \u0026#34;show.html\u0026#34;, post: post) 21 end 22 Kết quả request:\n1[info] GET /posts/1 2MISS 3... 4[info] GET /posts/1 5HIT 6... Lần request đầu tiên, bài viết chưa được cache nên phải truy xuất database và cache lại, lần thứ 2 thì đã có trong cache nên không cần phải đọc từ database nữa.\nỞ ví dụ này có thể bạn sẽ chưa thấy sự khác biệt lắm về tốc độ response, nhưng nếu như thay vì load 1 bài viết bằng việc xử lý thống kê dữ liệu thì sự khác biệt sẽ rất lớn.\n5. Plug cache Nếu cứ mỗi chức năng đều phải thêm code để kiểm tra cache thì sẽ lặp lại rất nhiều. Để phát huy cái sự lười biếng thì ta sẽ tạo một plug đơn giản để khỏi phải code nhiều lần.\n1defmodule PhoenixCache.Plug.Cache do 2 import Plug.Conn 3 4 # 6 minute 5 @default_ttl 6 * 60 6 7 def init(ttl \\\\ nil), do: ttl 8 9 def call(conn, ttl \\\\ nil) do 10 ttl = ttl || @default_ttl 11 12 # Chỉ cache với GET request 13 if conn.method == \u0026#34;GET\u0026#34; do 14 # tạo key từ request path và query param, thông thường 15 # thì cùng path và cùng param thì kết quả là giống nhau 16 key = \u0026#34;#{conn.request_path}-#{conn.query_string}\u0026#34; 17 18 case PhoenixCache.Bucket.get(key) do 19 {:ok, body} -\u0026gt; 20 IO.puts(\u0026#34;PLUG HIT\u0026#34;) 21\t22\t# nếu đã cache thì trả về ngay 23 conn 24 |\u0026gt; send_resp(200, body) 25 |\u0026gt; halt 26 27 _ -\u0026gt; 28 IO.puts(\u0026#34;PLUG MISS\u0026#34;) 29\t# nếu chưa cache thì xử lý như bình thường 30 conn 31 |\u0026gt; assign(:ttl, ttl) 32 |\u0026gt; register_before_send(\u0026amp;cache_before_send/1) # gọi hàm này trước khi trả về 33 end 34 else 35 conn 36 end 37 end 38 39 def cache_before_send(conn) do 40 # nếu request đuợc xử lý thành công thì cache 41 if conn.status == 200 do 42 key = \u0026#34;#{conn.request_path}-#{conn.query_string}\u0026#34; 43 data = conn.resp_body 44 PhoenixCache.Bucket.set(key, data, conn.assigns[:ttl] || @default_ttl) 45 conn 46 47 else 48 # không thì kệ chúng mày 49 conn 50 end 51 end 52end 53 Đây chỉ là một plug đơn giản, bạn có thể viết lại theo nhu cầu.\nSử dụng Plug: plug(PhoenixCache.Plug.Cache, TTL )\n1pipeline :browser do 2 ... 3 plug(PhoenixCache.Plug.Cache, 100) # cache 100s 4 end 6. Kết luận Vậy là bạn đã có thể sử dụng ETS như là bộ nhớ cache cho ứng dụng Phoenix của mình mà không cần phải cài thêm phần mềm/dịch vụ khác.\nHi vọng sẽ giúp ích cho các bạn\nSource code project https://github.com/bluzky/phoenix_ets_cache_example\n","date":"18","image":null,"permalink":"https://bluzky.github.io/blog/2018-05-17-ets-as-cache-phoenix/","tags":["elixir","phoenix","ETS"],"title":"Sử dụng ETS để tăng tốc ứng dụng với Phoenix"},{"categories":null,"contents":"ETS là gì? Có lẽ các bạn đã nghe qua về redis hoặc memcache, hoặc là cả hai. Còn nếu bạn chưa nghe tới bao giờ thì đó là những cơ sở dữ liệu lưu trữ trên RAM với ưu điểm là tốc độ truy xuất cực kỳ nhanh. ETS - Erlang Term Service - cũng là một CSDL lưu trữ trên RAM (in-ram DB) nhưng khác ở chỗ là ETS có sẵn khi cài Elixir/Erlang và bạn chẳng phải mất công cài đặt, cấu hình như 2 anh trên kia, nhà trồng được việc gì phải ngại.\nĐặc điểm của em nó là:\n Không cần cài đặt Dữ liệu lưu trữ trên RAM và mất đi khi process kết thúc Dữ liệu lưu trữ dạng key-value value có thể là set, ordered_set, bag, duplicated_bag Kiểu dữ liệu của value trên cùng 1 bảng là giống nhau và đuợc khai báo khi tạo bảng.  Các thao tác trong ETS 1. Tạo bảng 1iex\u0026gt; :ets.new(:cache, [:set, :protected, :named_table]) **Syntax: ** :ets.new(ten_bang, [type, access, name_table])\n type là kiểu dữ liệu của value lưu trong bảng  set là kiểu dữ liệu, chú này chung thuỷ chỉ có 1 value cho 1 key và key là duy nhất, không bị trùng. ordered_set thằng em nghiêm túc của set, khác thằng anh ở chỗ đuợc tự động order khi thêm data vào. bag khác với set ở chỗ chú này chơi harem, cho phép nhiều value cho cùng 1 key, tuy nhiên các value không đuợc trùng nhau. duplicated_bag thằng này ăn tạp giống bag nhưng cho phép value trùng nhau   access giới hạn khả năng truy xuất dữ liệu từ bảng, cũng khá dễ nhớ  public: hàng công cộng, chú process nào thích nhìn (đọc), sờ (ghi) gì anh cho hết protected: các chú chỉ đuợc nhìn thôi, anh sở hữu thì anh đuợc sờ private: anh giấu hết, chỉ có anh mới đuợc nhìn và sờ, các chú đi ra chỗ khác   named_table Cái này tuỳ chọn, bình thuờng thì sẽ trả về 1 id dùng để truy xuất vào table. Nếu thêm option này vào thì có thể dùng ten_bang để truy xuất vào table.  Đã xong phần khởi tạo, giờ phần hay ho nhất đây.\n2. Insert và update dữ liệu   Insert dữ liệu nếu key đã có chủ thì ghi đè (đập chậu cuớp bông)\n1iex\u0026gt; :ets.insert(:cache, {\u0026#34;post-1\u0026#34;, \u0026#34;world!\u0026#34;, %{view: 1}}) 2true    Insert dữ liệu, nếu key đã có chủ thì bỏ qua.\n1iex\u0026gt; :ets.insert_new(:cache, {\u0026#34;post-1\u0026#34;, \u0026#34;Lao!\u0026#34;, %{view: 2}}) 2false 3iex\u0026gt; :ets.insert_new(:cache, {\u0026#34;post-2\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 999}}) 4true    Dữ liệu cho hàm insert/2 và insert_new/2 là 1 tuple, phần tử đầu tiên của tuple mặc định được dùng làm key.\n3. Query dữ liệu 3.1 Query đơn giản: tìm kiếm dữ liệu theo key dùng hàm lookup/2\n1iex\u0026gt; :ets.lookup(:cache, \u0026#34;post-1\u0026#34;) 2[{\u0026#34;post-1\u0026#34;, \u0026#34;world!\u0026#34;, %{view: 1}}] 3.2 Query với nhiều trường dữ liệu với hàm match_object/2\n1iex\u0026gt; :ets.match_object(:cache, {:\u0026#34;_\u0026#34;, \u0026#34;Vietnam!\u0026#34;, :\u0026#34;_\u0026#34;}) 2[{\u0026#34;post-2\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 999}}]  Note :\u0026quot;_\u0026quot; đánh dấu tại vị trí này sẽ không xài để match dữ liệu, truờng này chứa dữ liệu gì cũng đuợc, anh không quan tâm  3.3 Select trường dữ liệu nào sẽ trả về với match/2\n1iex\u0026gt; :ets.match_object(:cache, {:\u0026#34;$1\u0026#34;, :\u0026#34;$2\u0026#34;, :\u0026#34;_\u0026#34;}) 2[{\u0026#34;post-1\u0026#34;, \u0026#34;world!\u0026#34;}, {\u0026#34;post-2\u0026#34;, \u0026#34;Vietnam!\u0026#34;}]  Note :\u0026quot;$N\u0026quot; dùng để select kết quả trả về, N là một số nguyên dùng để xác định vị trí của dữ liệu trong kết quả.  1iex\u0026gt; :ets.match_object(:cache, {:\u0026#34;$30\u0026#34;, :\u0026#34;$2\u0026#34;, :\u0026#34;_\u0026#34;}) 2[{\u0026#34;world!\u0026#34;, \u0026#34;post-1\u0026#34;}, {\u0026#34;Vietnam!\u0026#34;, \u0026#34;post-2\u0026#34;}] 3.4 Giới hạn kết quả tra về\nSử dụng hàm match/3 hoặc match_object/3 tương tự như match/2 và match_object/2, trong đó tham số thứ 3 là số lượng phần tử sẽ trả về.\n1# them 1 phan tu 2iex\u0026gt; :ets.insert_new(:cache, {\u0026#34;post-3\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 1000}}) 3true 4 5# khong limit 6iex\u0026gt; :ets.match_object(:cache, {:\u0026#34;_\u0026#34;, \u0026#34;Vietnam!\u0026#34;, :\u0026#34;_\u0026#34;}) 7[{\u0026#34;post-2\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 999}}, {\u0026#34;post-3\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 1000}}] 8 9# co limit 10iex\u0026gt; :ets.match_object(:cache, {:\u0026#34;_\u0026#34;, \u0026#34;Vietnam!\u0026#34;, :\u0026#34;_\u0026#34;}, 1) 11[{\u0026#34;post-2\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 999}}] 4. Xoá dữ liệu Xoá theo key\n1iex\u0026gt; :ets.delete(:cache, \u0026#34;post-1\u0026#34;) 2true Match dữ liệu và xoá. Cách match giống như trong query dữ liệu\n1iex\u0026gt; :ets.match_delete(:cache, {:\u0026#34;_\u0026#34;, \u0026#34;Vietnam!\u0026#34;, :\u0026#34;_\u0026#34;}) 2true 5. Xoá bảng 1iex\u0026gt; :ets.delete(:cache) 2true Nếu không xoá thì dữ liệu sẽ tồn tại cho đến khi process kết thúc mới bị mất đi.\n6. Các hàm hay xài  member/2 kiểm tra xem key đã tồn taị trong bảng hay chưa tab2list: đọc tất cả dữ liệu của bảng vào 1 list tab2file: lưu tất cả dữ liệu trên bảng vào 1 file, bạn có thể lưu dữ liệu lại truớc khi process kết thúc và có thể xài lại dữ liệu sau. file2tab : đọc 1 file đuợc lưu bởi tab2file và tạo lại bảng tương ứng to_dest/2: copy toàn bộ dữ liệu từ bảng ETS qua bảng DETS (lưu dữ liệu trên ổ cứng) from_dest/2: copy toàn bộ dữ liệu từ bảng DETS qua bảng ETS  Tham khảo  http://erlang.org/doc/man/ets.html xem nhiều trò hay http://learnyousomeerlang.com/ets Ngoài ra Erlang còn hỗ trợ DETS (disk-based term storage) lưu trên ổ cứng với API tương tự http://erlang.org/doc/man/dets.html  ","date":"12","image":null,"permalink":"https://bluzky.github.io/blog/2018-05-12-erlang-term-storage/","tags":["elixir","erlang"],"title":"Elixir - Lưu trữ dữ liệu trên RAM với ETS"},{"categories":null,"contents":"Trong quá trình tìm hiểu về lập trình chat bot sử dụng các API của Facebook Messenger thì việt test chat bot trên localhost là một trở ngại.\nKhi tạo một subscription cho app chat bot, Facebook sẽ gửi một request đến server mà chat bot đang chạy để xác nhận có đúng là chat bot của bạn không. Cũng như sau đó, tất cả những tin nhắn của nguời dùng sẽ đuợc gửi tới chat bot thông qua callback url. Và vấn đề là khi dev và test trên localhost thì làm sao để server local của bạn có thể nhận và phản hồi request của Facebook.\nMột giải pháp đơn giản là sử dụng dịch vụ của https://ngrok.com để chuyển các request về máy localhost. ngrok.com cung cấp gói miễn phí test vô tư, hơn nữa ngrok hỗ trợ cả https. Điều này rất quan trọng, bởi vì từ 2018 thì tất cả các callback url khi đăng ký ứng dụng trên Facebook Developer đều phải sử dụng kết nối TLS.\nBuớc 1: Đăng ký tài khoản  Đăng ký tại https://ngrok.com/pricing Vì là tài khoản miễn phí nên sẽ có một số giới hạn: 40 kết nối / phút Mỗi lần chỉ chạy được 1 ngrok process  Bước 2: Download ngrok và cấu hình API key  Download tại https://ngrok.com/download Giải nén file vừa Download bạn sẽ có file ngrok Thêm token vào ngrok config bằng lệnh  1$ ./ngrok authtoken \u0026lt;YOUR_AUTH_TOKEN\u0026gt; Bạn có thể copy command trên từ Dashboard trong phần Connect your account\nBước 3: Khởi chạy ngrok process Chạy lệnh\n1./ngrok http \u0026lt;PORT\u0026gt; trong đó PORT là port number của server localhost mà bạn muốn test.\nOuput mẫu của ngrok\nngrok cung cấp cho bạn 2 public URL để kết nối vào server localhost. 1 URL với giao thức http và 1 URL với https. Ngon không nào!\nBây giờ bạn đã có thể cấu hình Facebook để test trên localhost rồi.\nLưu ý:\nKhi sử dụng tài khoản Free, mỗi lần chạy ngrok thì forwarding URL sẽ khác nhau nên sẽ phải sửa lại sửa lại cấu hình app trên Facebook Developer. Đồ chùa thường là đồ chua mà. Khi sử dụng gói có phí bạn có thể cấu hình forwarding URL theo ý mình. Mình nghèo nên chịu khó thôi.\n","date":"08","image":null,"permalink":"https://bluzky.github.io/blog/2018-05-08-test-fb-bot-localhost/","tags":["tech","til"],"title":"Cấu hình kết nối HTTPS để test Facebook app trên localhost"},{"categories":null,"contents":" Từ tháng 04/2018 tất cả các app mới tạo trên Facebook chỉ chấp nhận callback url có sử dụng SSL. Đây là những bước đơn giản để có thể sử dụng giao thức https trên localhost đối với Phoenix\n 1. Tạo chứng chỉ\nRun command\n1openssl genrsa 1024 \u0026gt; app.key \u0026amp;\u0026amp; 2openssl req -new -x509 -nodes -sha1 -days 365 -key ~/app.key \u0026gt; ~/app.cert 2. Copy file\napp.key and app.cert file to priv/keys\n3. Chỉnh sửa cấu hình\nfile dev.exs\n1config :my_app, MyAppWeb.Endpoint, 2 http: [port: 4000], 3 https: [port: 4443, keyfile: \u0026#34;priv/keys/app.key\u0026#34;, certfile: \u0026#34;priv/keys/app.cert\u0026#34;], Access https://localhost:4443 to use SSL connection\n","date":"02","image":null,"permalink":"https://bluzky.github.io/blog/2018-05-02-phoenix-local-ssl/","tags":["elixir","til"],"title":"Chạy server Phoenix với SSL trên localhost"},{"categories":null,"contents":"1. Memcache  Memcache là một cơ sở dữ liệu dạng key-value, các dữ liệu đuợc ghi nhớ trên RAM giúp tối ưu thời gian truy xuất.\n 2. Đặc điểm  Dữ liệu lưu trữ dạng key-value Value là dữ liệu dạng string Kích thuớc của Value giới hạn là 1MB Dữ liệu sẽ bị mất khi tắt máy/ tắt memcache Truy xuất dữ liệu nhanh  3. Ứng dụng Memcache thường đuợc dùng đễ cache dữ liệu trên các web server giúp giảm thời gian xử lý các request giống nhau, thay vào đó chỉ cần đọc dữ liệu từ bộ nhớ và trả về ngay lập tức.\n4. Ưu - Nhược điểm Ưu điểm\n Dữ liệu truy xuất nhanh Sử dụng phổ biến  Nhược điểm\n Khi dữ liệu bị xoá, dữ liệu không đuợc phục hồi Chỉ hỗ trợ dữ liệu kiểu string Kích thước dữ liệu giới hạn chỉ 1MB Không hỗ trợ lưu dữ liệu persistent  5. Cách sử dụng Ví dụ sử dụng trong Elixir:\n1def get_post(conn, %{\u0026#34;id\u0026#34; =\u0026gt; id}) do 2 response = Memcache.Client.get(\u0026#34;post-#{id}\u0026#34;) 3 4 case response.status do 5 :ok -\u0026gt; 6 # trả về ngay nếu tìm thấy trong cache 7 json(conn, Poison.decode!(response.value)) 8 9 status -\u0026gt; 10 # Nếu không thấy, truy xuất dữ liệu mới 11 data = get_post_data(id) 12 13 # Lưu dữ liệu mới vào cache 14 json_data = Poison.encode!(data) 15 Memcache.Client.set(\u0026#34;post-#{id}\u0026#34;, json_data) 16 json(conn, data) 17 end 18end 6. Refs  Trang chủ memcached.org So sánh Memcache và Redis trên Stack overflow  ","date":"01","image":null,"permalink":"https://bluzky.github.io/blog/2018-05-01-what-is-mem-cache/","tags":["tech","til"],"title":"Memcache là gì?"},{"categories":null,"contents":"Khi chuyển qua dùng các hệ điều hành Unix và Mac, việc sử dụng các command line là một phần không thể thiếu, đặc biệt là các công việc liên quan tới Web dev và devops.\nTuy nhiên phần lớn là đụng tới đâu cần thì mới search, hoặc là do xài quen rồi nên cũng lười tìm cách làm khác. Chỉ cần dành 1 phút để đọc qua bài viết này, các bạn sẽ thực sự bất ngờ vì có những thứ cool đến không ngờ.\nNguồn dwmkerr.com\n","date":"24","image":null,"permalink":"https://bluzky.github.io/blog/2018-04-24-terminal-tips/","tags":["tips","til","terminal"],"title":"Terminal tips - Một số command hay dùng"},{"categories":null,"contents":"1. Tìm hiểu về FSM  FSM(Finite state machine) - Máy trạng thái hữu hạn là một mô hình toán học biểu diễn trạng thái của hệ, trong đó số trạng thái là hữu hạn. Từ mỗi trạng thái, máy có thể chuyển đổi qua 1 số trạng thái cố định khác, dựa trên các sự kiện, input.\n Fsm được biểu diễn như 1 đồ thị có hướng.\nVí dụ:\nMáy trạng thái thể hiện trạng thái của 1 bài báo trên trang tin tức\n draft, in review published là các trạng thái của bài viết review, approve, reject, unpublish là các sự kiện( event ). Các sự kiện này phát sinh khi nhận các input như click lên button, … Các sự kiện này gây ra việc chuyển trạng thái (ví dụ từ Draft -\u0026gt; In review), gọi là quá trình chuyển đổi (transition)  Đặc điểm\nTrong mô hình sử dụng DFS máy trạng thái đơn định.\n Tại mỗi thời điểm máy chỉ ở 1 trạng thái duy nhất Tại mỗi trạng thái, chỉ có thể chuyển qua những trạng thái được cho phép Từ trạng thái hiện tại, có thể biết được những trạng thái kế tiếp mà máy có thể chuyển qua  2. Ứng dụng của FSM trong lập trình   FSM mô tả các trạng thái, sự kiện và quá trình chuyển đổi giữa các trạng thái, nên FSM có thể được sử dụng để quản lý trạng thái của object, hoặc workflow.\n  Ví dụ: Quản lý trạng thái đơn hàng, quản lý trạng thái của ticket, quản lý trạng thái của nhân vật trong game, \u0026hellip;\n​\nTrong ví dụ trên, mỗi bài viết, chỉ có thể có một trạng thái tại một thời điểm, và từ 1 trạng thái chỉ có thể chuyển đổi qua một số trạng thái được quy định trước:\n Từ draft chỉ có thể chuyển qua in review Từ draft không thể chuyển qua published    2.1 Khi không dùng FSM Khi không sử dụng FSM thì code sẽ phải dùng tới rất nhiều điều kiện if … else… hoặc case (switch ... case … trong các ngôn ngữ khác)\n1defmodule Post do 2\tdefstruct content: \u0026#34;sample content\u0026#34;, status: \u0026#34;draft\u0026#34; 3\t4\tdef all_status, do: [\u0026#34;draft\u0026#34;, \u0026#34;in_review\u0026#34;, \u0026#34;published\u0026#34;] 5 6 def update_status(%{status: \u0026#34;draft\u0026#34;} = post, status) do 7 if status == \u0026#34;in_review\u0026#34; do 8 IO.put(\u0026#34;Update post status to in_review\u0026#34;) 9 Map.put(post, :status, \u0026#34;in_review\u0026#34;) 10 else 11 IO.put(\u0026#34;Cannot update to #{status}from draft\u0026#34;) 12 post 13 end 14 end 15 16 def update_status(%{status: \u0026#34;in_review\u0026#34;} = post, status) do 17 case status do 18\t\u0026#34;draft\u0026#34; -\u0026gt; 19\tIO.put(\u0026#34;Reject the post\u0026#34;) 20 Map.put(post, :status, \u0026#34;draft\u0026#34;) 21 22 \u0026#34;published\u0026#34; 23 IO.put(\u0026#34;Publish the post\u0026#34;) 24 Map.put(post, :status, \u0026#34;published\u0026#34;) 25 true -\u0026gt; 26 IO.put(\u0026#34;Cannot update to #{status}from in_review\u0026#34;) 27 post 28 end 29 end 30 31 def update_status(%{status: \u0026#34;published\u0026#34;} = post, status) do 32 if status == \u0026#34;draft\u0026#34; do 33 IO.put(\u0026#34;Unpublish the post\u0026#34;) 34 Map.put(post, :status, \u0026#34;draft\u0026#34;) 35 else 36 IO.put(\u0026#34;Cannot update to #{status}from published\u0026#34;) 37 post 38 end 39 end 40end **Vấn đề: **\n  Code dài, khó mở rộng, dễ xảy ra lỗi\n  Nếu thêm nhiều trạng thái khác cho post, phải update toàn bộ các hàm update_status\n  Nếu có nhiều cách chuyển đổi giữa các trạng thái, phải update toàn bộ\n  Làm sao biết từ trạng thái hiện tại có thể chuyển qua trạng thái nào khác?\n  Làm sao đảm bảo luồng dữ liệu/ logic chạy đúng\n  2.2 Sử dụng FSM Trong ví dụ này sử dụng thư viện as_fsm hỗ trợ việc implement máy trạng thái trên ngôn ngữ elixir\n1defmodule Post do 2 # define state, event and transition  3 use AsFsm, 4 states: [:draft, :in_review, :published], 5 events: [ 6 review: [ 7 name: \u0026#34;In review\u0026#34;, 8 from: [:draft], 9 to: :in_review, 10 on_transition: fn(post, params) -\u0026gt; 11 # thực ra việc gán trạng thái mới được tự động thực hiện bởi thư viện 12 # code này chỉ để mục đích cho dễ hiểu 13 post = Map.put(post, :status, :in_review) 14 {:ok, post} 15 end 16 ], 17 approve: [ 18 name: \u0026#34;Approve\u0026#34;, 19 from: [:in_review], 20 to: :published 21 on_transition: fn(post, params) -\u0026gt; 22 post = Map.put(post, :status, :published) 23 {:ok, post} 24 end 25 ], 26 reject: [ 27 name: \u0026#34;Reject\u0026#34;, 28 from: [:in_review], 29 to: :draft, 30 on_transition: fn(post, params) -\u0026gt; 31 post = Map.put(post, :status, :draft) 32 {:ok, post} 33 end 34 ], 35 unpublish: [ 36 name: \u0026#34;Unpublish\u0026#34;, 37 from: [:published], 38 to: :draft, 39 on_transition: fn(post, params) -\u0026gt; 40 post = Map.put(post, :status, :draft) 41 {:ok, post} 42 end 43 ] 44 ] 45 46 defstruct content: \u0026#34;sample content\u0026#34;, status: \u0026#34;draft\u0026#34; 47end 48 49# gọi thực hiện  50iex \u0026gt; post = %Post{content: \u0026#34;test content\u0026#34;, status: \u0026#34;draft\u0026#34;} 51iex \u0026gt; post = Post.review(post) 52# hoac 53iex \u0026gt; post = Post.trigger(post, :review)  Việc implement FSM cũng không quá phức tạp nhưng có thể tái sử dụng được nhiều lần Việc thêm mới các trạng thái (state) hoặc các bước chuyển tiếp (transition) không cần thay đổi quá nhiều code các luồng xử lý, event được thể hiện rõ trên cấu hình trạng thái  3. Tham khảo   Học thêm về FSM trên Brilliant\n  Finite-state machine in web-development\n  Thư viện FSM cho ecto model ecto_state_machine\n  Slide State Machine Workflow: Esoteric Techniques \u0026amp; Patterns\n​\n  ","date":"13","image":null,"permalink":"https://bluzky.github.io/blog/2018-04-13-finite-state-machine-web-development/","tags":["elixir","tech"],"title":"Finite state machine trong lập trình"},{"categories":null,"contents":" Từ cơn sốt tiền ảo, công nghệ Blockchain được tung hô và được xem như là công nghệ sẽ làm thay đổi tương lại, thậm chí đến cả công ty thực phẩm thêm chữ Blockchain vào tên sản phẩm cũng đủ làm giá cổ phiếu tăng mấy chục lần. Vậy Blockchain là gì và nó có thực sự là thứ sẽ làm thay đổi tương lai công nghệ? Để trả lời thắc mắc của chính mình, tôi đã dành thời gian để tìm hiểu về Blockchain. Có thể có một số sai sót không tránh khỏi. Rất mong nhận được sự góp ý.\n I. Blockchain là gì? 1. Định nghĩa Khó có thể đưa ra một định nghĩa chính xác cho Blockchain\nBlockchain là một công nghệ xác thực, xử lý và lưu trữ các giao dịch trên mạng internet dựa trên hệ thống phân tán.\nNguồn gốc tên gọi Blockchain xuất phát từ công nghệ lưu trữ dữ liệu thành các khối block, sau đó các khối này được kết nối lại với nhau thành một chuỗi chain.\n2. Cách tổ chức dữ liệu Tất cả dữ liệu trong hệ thống Blockchain sẽ được đóng gói thành các khối, các khối này liên kết với nhau tạo thành một chuỗi duy nhất và thống nhất trên toàn bộ hệ thống.\nMỗi block chứa nhiều giao dịch (transaction) khác nhau và Mỗi block có chứa mã hash của block trước nó. Mã hash được tạo ra nhờ các thuật toán phức tạp như SHA256, MD5, … giá trị của mã hash là khác nhau cho các dữ liệu khác nhau. Chỉ cần một sự thay đổi nhỏ trong dữ liệu cũng sẽ làm thay đổi giá trị của mã hash. Nhờ mã hash này mà việc thay đổi giá trị của một block sẽ khiến mã hash nó thay đổi và không còn trùng với mã hash được lưu ở block sau nó. Nhờ mã hash mà hệ thống có thể kiểm tra và loại bỏ những thông tin bị cố tình thay đổi.\nTransaction là thông tin của các giao dịch. Giao dịch ở đây không giới hạn trong chuyển tiền, transaction có thể chứa bất cứ thông tin gì như hình ảnh, âm thanh, ….\n3. Blockchain network Để hiện thực công nghệ blockchain cần có một hệ thống các máy tính kết nối với mạng internet và chạy một ứng dụng khách client.\nMỗi máy tính trong network được gọi là node. Mỗi node có thể chứa bản sao (hoặc một phần) dữ liệu của hệ thống blockchain. Điều này giúp tránh việt mất mát dữ liệu và đảm bảo an toàn cho hệ thống.\n4. Lưu trữ dữ liệu Blockchain sử dụng công nghệ lưu trữ dữ liệu gọi là sổ cái phân tán (distributed ledger). Trong đó dữ liệu sẽ được lưu trên tất cả các node trong network, mỗi node sẽ chứa bản sao của blockchain. Khi có một thay đổi trên blockchain, thay đổi này sẽ được đồng bộ hoá trong toàn bộ hệ thống. Sau 1 thời gian thì toàn bộ các node trên hệ thống sẽ đồng bộ trở lại và toàn bộ các bản sao trong hệ thống sẽ hoàn toàn giống nhau.\n5. Đặc điểm của hệ thống Blockchain  Dữ liệu một khi đã lưu trữ thì hầu như không thể sửa đổi được Luôn có thể truy vết nguồn gốc của dữ liệu qua tất cả các giao dịch trước đó Dữ liệu trên toàn bộ hệ thống thống nhất với nhau Phi tập trung: việc xác nhận và thực thi các giao dịch không cần phụ thuộc vào một bên trung gian thứ 3 cụ thể, mà được xác nhận bởi toàn bộ hệ thống. Dữ liệu được lưu trữ phân tán trên toàn bộ hệ thống Sử dụng các cơ chế đồng thuận để xác nhận giao dịch Mỗi giao dịch cần có sự tham gia của toàn bộ hệ thống  6. Ưu điểm   Ổn định : Khác với hệ thống tập trung, khi một phần dịch vụ ngưng hoạt động sẽ ảnh hưởng toàn bộ hệ thống. Khi một vài node trong hệ thống bị dừng hoặc mất mát dữ liệu, toàn bộ hệ thống vẫn hoạt động bình thường.\n  An toàn dữ liệu: Một khi dữ liệu đã được lưu vào trong hệ thống thì hầu như không thể thay đổi\n  Bảo mật: Dữ liệu không thể thay đổi, việc thêm mới dữ liệu cần có sự xác nhận và đồng thuận của toàn bộ hệ thống nên khó để giả mạo thông tin.\n  Thống nhất: Dữ liệu được lưu trữ trên các node được đồng bộ và thống nhất với nhau. Không cần trung gian/ không cần tin tưởng: Việc xác nhận các giao dịch do toàn bộ các node trong hệ thống thực hiện nên không cần phải thông qua một bên thứ 3 được tin tưởng. Ví dụ: thông thường chuyển tiền qua ngân hàng cần 2 bên tin tưởng tuyệt đối vào ngân hàng. Trong blockchain, các giao dịch được thực hiện trực tiếp\n  Giảm bớt chi phí, thời gian: Các giao dịch không cần khoản phí rất nhỏ do không phải trả cho bên trung gian. Thời gian giao dịch nhanh, không cần đợi xác nhận từ ngân hàng, không phải chờ ngày cuối tuần, \u0026hellip;\n  Hạn chế lỗi phát sinh do con người: Toàn bộ các hoạt động của blockchain do hệ thống tự vận hành, không có sự can thiệp của con người.\n​\n  7. Nhược điểm  Lãng phí: việc xử lý tính toán được thực hiện bởi tất cả các node trong hệ thống nhưng chỉ kết quả của 1 node được sử dụng, chi phí tính toán của tất cả node còn lại bị lãng phí. Khó mở rộng: Việc xác nhận các giao dịch và đóng gói dữ liệu được thực hiện bởi toàn bộ các node trong hệ thống. Nếu lượng giao dịch quá lớn trong khoảng thời gian ngắn thì hệ thống không thể đáp ứng việc xử lý đồng thời quá nhiều Vấn đề lưu trữ dữ liệu: Khi hệ thống trở nên lớn hơn thì lượng dữ liệu cần lưu trữ sẽ ngày càng lớn. Như Ethereum mỗi năm dữ liệu tăng khoảng 55GB, nếu tất cả các node đều lưu trữ dữ liệu này thì các node sẽ cần khả năng xử lý cao hơn và điều này không thực tế. Nếu chỉ có một số node lưu trữ full data thì việc tấn công sẽ dễ hơn bởi vì chỉ cần tấn công một số ít node. Tích hợp phức tạp: Blockchain là công nghệ hoàn toàn mới nên việc tích hợp vào các hệ thống cũ sẽ rất khó khăn Chưa hoàn thiện: Hiện nay công nghệ blockchain vẫn đang trong giai đoạn phát triển và chưa có một ứng dụng nào áp dụng công nghệ blockchain thành công ngoài lĩnh vực tiền ảo  8. Các ứng dụng của blockchain / Các vấn đề mà blockchain có thể xử lý  Truy xuất nguồn gốc sản phẩm (vật lý hay kỹ thuật số) Giảm chi phí trung gian Giải quyết vấn đề giao dịch không cần tin tưởng lẫn nhau Hợp đồng thông minh smart contract tự động thực thi điều khoản hợp đồng khi các điều kiện được đáp ứng, tránh việc chây ỳ, phá hợp đồng.  II. Smart contract 1. Smart contract là gì? Smart contract là một chương trình máy tính được lưu trữ trong blockchain, có khả năng thực thi các thoả thuận tự động mà không cần sự can thiệp từ con người.\nSmart contract nói một cách chính xác hơn là giao dịch có điều kiện conditional transaction. Nghĩa là khi 2 bên đồng ý các điều khoản với nhau thì sẽ lập nên một smart contract/transaction với các điều kiện ràng buộc. Khi các điều kiện này thoả thì sẽ thực hiện giao dịch (transaction)/ hoặc huỷ giao dịch tuỳ điều kiện.\nSmart contract được hỗ trợ bởi hầu hết các nền tảng blockchain hiện tại nhưng Ethereum là nền tảng được sử dụng nhiều nhất bởi sự linh hoạt và các tính năng mà nó hỗ trợ.\nVí dụ:\nKhi A mua hàng sách online tại Shop P, cuốn sách trị giá 200k, A và Shop P lập 1 smart contract\n 200k của A sẽ được lưu trong smart contract điều kiện là khi A nhận được cuốn sách từ Shop P -\u0026gt; chuyển 200k vào tài khoản shop P.  2. Smart contract hoạt động như thế nào? implement smart contract Ethereum\nLàm thử rồi hiểu\n3. Ưu và nhược điểm của Smart contract Ưu điểm:\n Không cần sự can thiệp của con người trong việc thực thi hợp đồng Giảm bớt chi phí trung gian: luật sư, phí giao dịch ngân hàng Không cần tin tưởng đối tác Tự động thực thi  Nhược điểm:\n  Để kiểm tra điều kiện của smart contract thì toàn bộ hệ thống phải truy xuất vào cùng 1 nguồn dữ liệu\n Việc này giống như tấn công DDOS Không có gì đảm bảo tất cả các kết quả trả về là giống nhau, vd: nguồn ko hoạt động, bị thay đổi    Smart contract không thể cập nhật các điều khoản\n  Không thể huỷ bỏ\n  Tính chính xác của smart contract phụ thuộc vào người thiết lập các điều khoản (thường là lập trình viên)\n Lập trình viên là con người và có xác suất lỗi Lập trình viên phải hoàn toàn hiểu các điều khoản để chuyển thành chương trình Phải hoàn toàn tin tưởng vào lập trình viên. 👹(they can be evil)    Nguồn dữ liệu để kiểm tra các điều kiện có thể đến từ thế giới thực (vd xác nhận đã nhận hàng) thì vẫn có thể bị tấn công, giả mạo các thông tin đầu vào, hoặc phụ thuộc vào 1 bên thứ 3 được tin tưởng tuyệt đối\n  4. Ứng dụng của Smart contract Tất cả những hoạt động giao dịch có điều kiện đều có thể sử dụng smart contract\n  Tạo ra các token mới, có thể sử dụng như 1 loại tiền điện tử\n  Xổ số\n  Mua hàng online\n  Bảo hiểm\n  Mua nhà\n  Giao hàng\n  Cá độ\n  …..\n  III. Fork, Hard fork vs soft fork? 1 Fork là gì? Như đã biết Blockchain là một chuỗi các khối liên kết với nhau, và các chuỗi này là giống nhau trên toàn bộ hệ thống. Các node  trong hệ thống thông qua một cơ chế đồng thuận  consensus để xác định khối nào sẽ được thêm vào blockchain. Fork  xảy ra khi một hệ thống không đạt được sự đống thuận trong việc ghi các khối mới và blockchain bị chia tách thành 2 nhánh khách nhau.\nNguyên nhân của fork là do:\n Thêm các tính năng mới để cải tiến chức năng của hệ thống blockchain hiện tại. Sửa đổi các rule (quy định) trong quá trình xác nhận giao dịch và tạo khối (Vd: kích thước của 1 block)  Do những thay đổi này là permanent(lâu dài) nên khi thực hiện fork các node trong hệ thống cần phải cập nhật ứng dụng client để tích hợp các rule mới.\nFork được chia làm 3 loại:\n Soft fork Hard fork Spin-off coin  2 Soft fork Soft fork là những cập nhật phần mềm có tương thích với phiên bản cũ , nghĩa là các node không cần cập nhật phần mềm mới vẫn có thể thực hiện việc kiểm tra (validate) và xác nhận(verify) các giao dịch. Để hoàn thành soft fork chỉ cần phần lớn các node trong hệ thống cập nhật phiên bản mới, các node cũ vẫn có thể tiếp tục xác nhận các block mới tạo.\nSoft fork là thực hiện việc cập nhật từ từ và không ảnh hưởng nhiều đến chức năng của hệ thống.\nVí dụ:\nThay đổi kích thước block từ 1MB lên 2MB, các node chưa cập nhật vẫn có thể tiếp nhận và xử lý các giao dịch, tuy nhiên các block do các node này tạo ra sẽ bị hệ thống bỏ qua, không cho ghi vào blockchain, nên công sức xử lý của các node này coi như là bị lãng phí.\n3 Hard fork Hard fork là những cập nhật phần mềm tạo nên sự không tương thích với các phiên bản cũ. Để hoàn toàn cập nhật, tất cả các node phải cập nhật phần mềm lên phiên bản mới. Những node không cập nhật sẽ vẫn tiếp tục hoạt động theo các rule cũ. Các node mới và node cũ sẽ tạo nên 2 phiên bản khác nhau từ 1 blockchain ban đầu.\nViệc thực hiện Hard fork có thể là do có kế hoạch trước hoặc là do sự chia rẽ trong cộng đồng sử dụng, bảo trì blockchain.\n3.1 Hard fork có kế hoạch  Là những cập nhật trong giao thức đã được lên kế hoạch từ trước và có sự đồng thuận từ toàn bộ cộng đồng. Tất cả các node sẽ dần chuyển hoàn toàn qua nhánh mới tách ra. Nhánh cũ sẽ bị bỏ đi Việc cập nhật sẽ không gây ảnh hưởng tới giá trị của coin  3.2 Hard fork do tranh cãi  Thông thường là do sự bất đồng ý kiến trong cộng đồng trong việc xác định những thay đổi mà mỗi bên cho là tốt nhất đối với blockchain hiện tại. Blockchain sẽ chia tách thành 2 phiên bản khác nhau cùng tồn tại song song với nhau. Các node trong mạng lưới ban đầu cũng sẽ tách thành 2 mạng lưới khác nhau: mỗi bên sử dụng 1 bản cập nhật khác nhau. Các giao dịch trước khi chia tách sẽ tồn tại trong cả 2 blockchain  Ví dụ\nViệc hard fork Bitcoin thành Bitcoin và Bitcoin Cash, do 1 bên muốn giữ kích thước Block 1MB và 1 bên muốn nâng kích thước block lên 8MB để tăng khả năng mở rộng của Bitcoin (thực hiện nhiều giao dịch hơn trong cùng thời gian)\n4 Spin-off coin Sử dụng mã nguồn của những coin có sẵn và thay đổi để tạo nên blockchain mới với những tính năng mới thêm vào.\nVí dụ\nLitecoin là một coin dựa trên mã nguồn của Bitcoin với các thay đổi:\n Thời gian xử lý block trung bình là 2.5 phút so với 10 phút của Bitcoin Sử dụng thuật toán Scrypt thay vì SHA256 Giới hạn tổng số coin là 84 triệu so với 21 triệu Bitcoin  IV. Coin vs Token 1. Coin là gì? Coin là một loại tiền mã hoá (crypto currency) được tạo ra và vận hành một cách độc lập dựa trên một nền tảng blockchain của riêng nó.\nCoin là từ dùng để chỉ chung các loại tiền ảo như : Bitcoin, Ethereum, \u0026hellip;\nAltcoin dùng để chỉ các loại tiền ảo ngoài Bitcoin\n2. Token là gì ? Tạo token mới từ Ethereum\nToken là các đơn vị có thể được sử dụng để dao dịch như coin, tuy nhiên token được tạo ra và hoạt động dựa trên cơ chế Smart contract mà các nền tảng Blockchain như Ethereum hay Omni cung cấp.\nHiện nay hơn 80% các loại token được tạo ra dựa trên nền tảng Ethereum\n3. Phân loại token Không có phân loại cụ thể cho token. Một token có thể sử dụng cho một hoặc nhiều mục đích:\n Sử dụng như đơn vị tiền tệ Tài sản số (digital) Công cụ kế toán Công cụ phân chia cổ phần nắm giữ trong các start-up Một phương pháp để chống tấn công Một dạng điểm, reward cho user \u0026hellip;  ","date":"11","image":"/img/blockchain.jpg","permalink":"https://bluzky.github.io/blog/2018-04-11-blockchain/","tags":["others","tech","blockchain"],"title":"Tìm hiểu về công nghệ Blockchain"},{"categories":null,"contents":"  Vừa mới hoàn thành các chức năng cơ bản cho hệ thống OKR nội bộ công ty. Sau quá trình tìm hiểu các phương pháp áp dụng OKR vào trong một tổ chức, mình thấy nó rất là hay và đơn giản, dễ áp dụng. Ngoài việc áp dụng cho công ty, có thể áp dụng các nguyên tắc của OKR để thiết lập kế hoạch cá nhân. Đây là tóm tắt một số nội dung cơ bản về OKR, có thể có một số sai sót mong nhận được sự góp ý.   1. OKR là gì? OKR - Objectives and Key Results - tạm dịch Mục tiêu và Kết quả then chôt.\nOKR là một phương pháp thiết lập mục tiêu giúp tạo sự thống nhất giữa mục tiêu của từng cá nhân với mục tiêu của toàn công ty, tập trung động lực của toàn bộ công ty để đạt được mục tiêu đề ra.\nOKR đã được áp dụng bởi các công ty hàng đầu như Intel, Google (từ 1999), Oracle, Linked in, \u0026hellip;\nĐiểm khác biệt của OKR so với các phương pháp truyền thống:\n OKR được thiết lập thường xuyên (thông thường là mỗi quý) Quá trình thực hiện OKR bao gồm việc liên tục theo dõi và đánh giá kết quả thực hiện được. OKR đơn giản, theo nhịp điệu nhanh (do thời gian thực hiện OKR ngắn) và khuyến khích sự tham gia của các nhân viên.  2. Các lợi ích khi áp dụng OKR  Tạo nên sự thống nhất trong công ty: mục tiêu của mỗi cá nhân đều theo định hướng của mục tiêu công ty, khi mỗi cá nhân đạt được mục tiêu thì công ty sẽ đạt được mục tiêu. Sự rõ ràng và tập trung: Mục tiêu cá nhân ít và rõ ràng, giúp nhân viên biết rõ mục tiêu của mình và cần làm gì để đạt được mục tiêu. Kết nối nhân viên với sứ mệnh công ty: khi mục tiêu của mỗi nhân viên gắn với mục tiêu công ty, mỗi người sẽ ý thức được sự đóng góp của cá nhân cho sự phát triển của công ty. Tạo nên sự trong suốt: nghĩa là mỗi nhân viên có thể thấy được mục tiêu của những nhân viên khác, qua đó thúc đẩy sự hợp tác/hỗ trợ để đạt được mục tiêu chung. Đơn giản, dễ áp dụng, không tốn nhiều thời gian  3. OKR hoạt động như thế nào OKR dựa trên các khái niệm\n Objective: Mục tiêu muốn đạt được. (Bạn muốn đi đến đâu?) Key Result: các kết quả then chốt dùng để đo lường mức độ hoàn thành của mục tiêu. (Làm sao để biết là bạn đạt được mục tiêu hay chưa?)  Bước 1: Xây dựng mục tiêu cho toàn công ty Mục tiêu của công ty nên được thiết lập mỗi quý 1 lần. Dựa trên mục tiêu của công ty, các phòng ban thiết lập mục tiêu phòng ban theo định hướng công ty, tương tự thiết lập mục tiêu xuống các cấp thấp hơn. Các mục tiêu phải được cụ thể hoá bằng các kết quả then chốt\n  Mục tiêu (Objective)\n Mỗi cá nhân/ công ty chỉ nên có 3-5 mục tiêu. Các mục tiêu nên mang tính tham vọng, lớn hơn khả năng. Các nghiên cứu chứng minh rằng nếu đặt mục tiêu cao thì sẽ có khả năng đạt được kết quả cao hơn. Mỗi mục tiêu chỉ nên có 3-4 kết quả then chốt. Nhiều kết quả then chốt sẽ dễ tạo nên sự mất tập trung. Mục tiêu của cấp thấp hơn (vd phòng ban) sẽ dựa trên mục tiêu của cấp cao hơn(vd công ty). Mỗi cá nhân tự đặt ra mục tiêu của mình và thảo luận với cấp trên trực tiếp để thống nhất mục tiêu theo đúng định hướng.    Kết quả then chốt (key result) cần phải\n Cụ thể: Có thể đo lường được (có thể tính bằng con số cụ thể hoặc %) Có xác định thời gian deadline Không nên cảm tính, cần dựa trên tình hình cụ thể của công ty    Bước 2: Thực hiện  Ở mức độ cá nhân, các Key Result nên được chia thành các Task (Tác vụ) thực hiện trong ngày hoặc tuần.  Bước 3: Đánh giá liên tục (Check - in)  Check - in nên được thực hiện hàng tuần, có thể kết hợp với các buổi họp khác như 15' stand-up meeting Mục đích của Check - in  Đánh giá lại các công việc đã làm Giải quyết các vướng mắc/ khó khăn gặp phải. Nhắc nhở mục tiêu mà mỗi nhân viên cần hướng tới    Bước 4: Đánh giá tổng kết   Đánh giá kết quả thực hiện\n  Mức độ hoàn thành Key result được tính điểm 0.0 - 1.0\n  Điểm đánh giá của Objective tính bằng điểm trung bình của các Key result\n  Thang đánh giá\n \u0026lt; 0.4: Chưa đạt 0.6 - 0.7: Tốt   0.7: quá dễ\n     Khi mục tiêu có điểm \u0026gt; 0.7 nghĩa là mục tiêu đặt ra quá dễ, cần phải xem xét lại việc đặt mục tiêu lần sau\n  Khi mục tiêu \u0026lt; 0.4 nghĩa là việc xác đinh hoặc thực hiện mục tiêu chưa tốt.\n    Tại sao mục tiêu cty nên theo từng quý\n Thống nhất với lịch tài chính của công ty 3 tháng là khoảng thời gian đủ để tạo nên kết quả có thể đánh giá được    OKR cho phép người quản lý đảm bảo rằng tất cả nhân viên đang hướng đến mục tiêu chung. Mỗi tuần, mỗi cá nhân cần (check-in) cập nhật/đánh giá các kết quả then chốt của mình để đảm bảo các nhân viên đang đi đúng hướng và giảm thời gian họp không cần thiết. Nếu một nhân viên gặp các vấn đề vướng mắc, các vấn đề nên được giải quyết thông qua các cuộc họp trực tiếp 1-1 với cấp trên trực tiếp.\n- Nên tách biệt OKR với hệ thống đánh giá hiệu quả công việc của nhân viên để tránh tạo nên việc đặt ra các\n4. Một ví dụ áp dụng OKR trong thiết lập mục tiêu công ty  Comming soon\n 5. Một số sai lầm khi áp dụng OKR  Sử dụng OKR như list công việc Quá nhiều mục tiêu. Thay vì liệt kê tất cả các mục tiêu muốn đạt được, chỉ nên chọn ra 3-4 mục tiêu với độ ưu tiên cao nhất Thiếu sự thống nhất mục tiêu. Mục tiêu cần được thiết lập dựa trên mục tiêu chung của công ty và thông qua thảo luận để xác định đúng trọng tâm. Thiết lập xong rồi quên. Thực hiện OKR phải bao gồm việc liên tục theo dõi và đánh giá kết quả/tiến độ thực hiện, đảm bảo mỗi cá nhân luôn tập trung vào OKR của mình. Xây dựng OKR theo kiểu phân cấp, cấp dưới phải đợi cấp trên thiết lập xong mục tiêu rồi mới tạo mục tiêu của mình. Điều này dẫn tới việc tốn nhiều thời gian và mục tiêu của cá nhân sẽ sai lệch soi với mục tiêu công ty nếu mục tiêu ở cấp trên chưa đúng.  ","date":"09","image":null,"permalink":"https://bluzky.github.io/blog/2018-02-09-tim-hieu-okr/","tags":["others","management"],"title":"Thiết lập và quản lý mục tiêu theo phương pháp OKR"},{"categories":null,"contents":"1. Giới thiệu  List là một trong những kiểu dữ liệu được sử dụng rất nhiều trong python. Các thao tác thường được thực hiện trên list: xử lý từng phần tử trong list, lọc lấy một số phần tử thỏa điều kiện, tính toán dựa trên tất cả các phần tử của list( vd tính tổng) và trả về kết quả. Để đơn giản việc xử lý List, Python hỗ trợ một số hàm có sẵn để thực hiện các tác vụ trên gồm map(), filter(), reduce()  2. Map  map(func, seq) \u0026gt; map sẽ áp dụng hàm func cho mỗi phần tử của seq và trả về list kết quả.\n Ví dụ: Tính bình phương các số có trong list\na. sử dụng map():\n1my_list = [1,2,3,4,5] 2def binh_phuong(number): 3\treturn number*number 4 5print map(binh_phuong, my_list) 6# [1,2,9,16,25]  Trong ví dụ trên, map sẽ tự động áp dụng hàm binh_phuong với mỗi phần tử trong danh sách my_list Hàm truyền vào hàm map nhận vào một tham số cùng kiểu với phần tử của list Có thể sử dụng lamda thay thế cho hàm. Ví dụ trên có thể được viết lại: print map(lambda x: x*x, my_list)  b. Cách thông thường:\n1my_list = [1,2,3,4,5] 2result = list() 3for number in my_list: 4\tresult.append( number*number) 5 6print result # [1,2,9,16,25] 3. Filter   filter(func, list) Hàm filter sẽ gọi hàm func với tham số lần lượt là từng phần tử của list và trả về danh sách các phần tử mà func trả về True func chỉ có thể trả về True hoặc False   Ví dụ: lọc ra các số chẵn từ danh sách a. Sử dụng filter:\n1my_list = [1, 2, 3, 4, 5] 2 3def so_chan(number): 4 if number % 2 == 0: 5 return True 6 else: 7 return False 8 9print filter(so_chan, my_list) # [2,4] #Sử dụng lambda\n1print filter(lambda x: x%2 ==0, my_list)# [2,4] b. Không dùng filter\n1my_list = [1, 2, 3, 4, 5] 2ket_qua = list() 3 4for number in my_list: 5 if number % 2 == 0: 6 ket_qua.append(number) 7 8print ket_qua 4. Reduce  reduce(func, seq) reduce sẽ tính toán với các phần tử của danh sách và trả về kết quả. func là một hàm nhận vào 2 tham số có dạngfunc(arg1, arg2) trong đó arg1 là kết quả tính toán với các phần tử trước, arg2 là giá trị của phần tử của danh sách đang được tính toán.\n Ví dụ: tính tổng bình phương của các phần tử trong mảng a. Su dung reduce\n1data = [1,2,3,4] 2def tinh_tong(tong, so): 3\treturn tong + so*so 4 5#su dung ham 6print reduce(tinh_tong, data) #30 7 8#su dung lambda 9print reduce( (lambda tong, so: tong + so*so), data) #30 b. Khong su dung reduce\n1data = [1,2,3,4] 2tong = 0 3for so in data: 4\ttong += so*so 5 6print tong #30 5. Kết luận  Trong bài viết chỉ đưa ra những ví dụ đơn giản nên có thể các bạn chưa thấy được sự tiện dụng của map, filter, reduce. Tuy nhiên khi phải làm việc với list nhiều các bạn sẽ thấy nó rất là tiện đặc biệt là khi sử dụng kèm lambda hoặc tái sử dụng các hàm với map, filter và reduce  ","date":"21","image":null,"permalink":"https://bluzky.github.io/blog/2018-01-21-python-xu-ly-mang-voi-filter-reduce/","tags":["python","python-basic"],"title":"Dùng MAP, FILTER và REDUCE để xử lý danh sách / list trong Python"},{"categories":null,"contents":"1. Decorator là gì?  Decorator là một mẫu thiết kế (Design pattern) thường được dùng để thay đổi hành vi, chức năng của hàm(function) hoặc lớp (class) mà không cần phải thay đổi code của hàm hoặc lớp. Tham khảo Python hỗ trợ cú pháp (syntax) cho Decorator từ version 2.4 Về cơ bản Decorator giống như một lớp vỏ bọc (wrapper), nó thay đổi hành vi(behavior) của code trước và sau khi gọi hàm chính (hàm được decorate).  2. Decorator được dùng làm gì? Tại sao chúng ta cần Decorator?\n Cho phép tái sử dụng code. Mở rộng các hàm, hoặc lớp mà không cần phải thay đổi code có sẵn \u0026ndash;\u0026gt; không cần test lại.  Ví dụ trong chương trình của bạn bạn cần kiểm tra quyền (permission) của người dùng trước khi thực hiện hàm. Bạn có thể phải thêm code vào tất cả các hàm đã có để kiểm tra. Thay vào đó với decorator, bạn chỉ cần định nghĩa một decorator và khai báo nó trước hàm.\n3. Làm sao để định nghĩa một decorator?   Decorator cũng là một hàm chỉ khác là hàm decorator nhận vào một hàm và kết quả trả về của nó là hàm sau khi được decorate.\n  Như vậy để định nghĩa một decorator chỉ đơn giản là định nghĩa một hàm nhận vào một hàm khác và trả về một hàm mới có prototype tương đương với hàm nhận vào.\n  Ví dụ 1:\n1def ten_decorator(f): 2 def wrapper(ten): 3 chuoi_moi = \u0026#34;Ten tui la %s\u0026#34; % ten 4 return f(chuoi_moi) 5 return wrapper 6 7def xuat_ten( ten ): 8 print ten   CHÚ Ý QUAN TRỌNG: hàm wrapper và hàm f phải có tham số phù hợp với nhau. Ví dụ như hàm f nhận vào chỉ 2 tham số thì hàm decorator không thể nhận vào 3 tham số hoặc 1 tham số.\n  4. Sử dụng decorator như thế nào?  Sử dụng Decorator hết sức đơn giản. Sử dụng decorator trong ví dụ trên cho hàm xuat_ten như sau:  1@ten_decorator 2def xuat_ten(ten): 3\tprint ten  Dùng dấu @ để thông báo đó là một decorator. Một hàm có thể dùng nhiều decorator cùng lúc:  1@ten_decorator1 2@ten_decorator2 3@ten_decorator3 4def xuat_ten(ten): 5\tprint ten 5. Decorator hoạt động như thế nào? Như trong ví dụ ở trên:\n  ten_decorator nhận vào hàm f, sau đó bọc hàm f trong hàm wrapper của nó và trả về hàm wrapper. Hàm wrapper có nhiệm vụ gắn thêm thông tin vào tên rồi mới gọi thực hiện hàm f với chuỗi mới.\n  Việc sử dụng:\n1@ten_decorator 2def xuat_ten(ten): 3 print ten 4xuat_ten(\u0026#39;coulson\u0026#39;) Tương đương với:\n1def xuat_ten(ten): 2print ten 3ham_xuat_ten_moi = ten_decorator(xuat_ten) 4ham_xuat_ten_moi(\u0026#39;coulson\u0026#39;)   Rõ ràng với việc sử dụng cú pháp decorator thì code sẽ ngắn gọn và đơn giản hơn. Developer không phải gọi decorator mỗi lần sử dụng mà trình thông dịch sẽ làm việc đó.\n  Đối với hàm sử dụng nhiều decorator\nVí dụ 2\n1@ten_decorator1 2@ten_decorator2 3@ten_decorator3 4def xuat_ten(ten): 5\tprint ten  Decorator nào càng ở trên, xa function thì sẽ bọc lớp ngoài Giống như khi bạn bọc trái xoài vào trong bị, rồi lại lấy cái bị khác để bọc bên ngoài nữa. Thứ tự thực thi code: - Code của decorator được thực thi ngay lúc file nguồn Python được load lên. Ngoại trừ code trong hàm wrapper của decorator trong cùng sẽ được thực thi lúc gọi hàm. - Decorator được gọi thực thi theo thứ tự từ trong (gần hàm nhất) ra ngoài.  6 Truyền tham số cho decorator  Ở trên, để cho đơn giản, và dễ hiểu thì decorator là một hàm có tham số là một hàm khác. Nhưng điều đó không bắt buộc, decorator cũng có thể là một hàm nhận vào tham số bất kỳ và trả về một hàm và hàm trả về này nhận vào tham số là một hàm khác.\n Ví dụ 3: thêm chức danh vào chuỗi xuất ra mình có thể định nghĩa decorator như sau:\n1def chuc_danh_decorator(ten_chuc_danh): 2 def ten_decorator(f): 3 def wrapper(ten): 4 chuoi_moi = \u0026#34;Xin gioi thieu %s%s\u0026#34; % (ten_chuc_danh, ten) 5 return f(chuoi_moi) 6 return wrapper 7 return ten_decorator 8 9@chuc_danh_decorator(\u0026#34;Giao su\u0026#34;) 10def gioi_thieu(ten): 11\tprint ten 12 13@chuc_danh_decorator(\u0026#34;Tien si\u0026#34;) 14def gioi_thieu_2(ten): 15\tprint ten 16 17gioi_thieu(\u0026#34;Teo\u0026#34;) 18gioi_thieu_2(\u0026#34;Ti\u0026#34;) 19 20\u0026gt;\u0026gt; Xin gioi thieu Giao su Teo 21\u0026gt;\u0026gt; Xin gioi thieu Tien si Ti Sự khác biệt:\n Hàm decorator bây giờ không phải nhận vào tham số là một hàm mà có thể là tham số bất kỳ. Hàm trả về từ decorator nhận vào một hàm và chính nó mới trả về hàm wrapper Cách sử dụng decorator cũng khác một chút. Decorator được gọi chạy ( dùng dấu () ) và truyền vào tham số.  Nó chạy như thế nào:\n Trong ví dụ 3 decorator được sử dụng @chuc_danh_decorator(\u0026quot;Giao su\u0026quot;). Chú ý dấu (\u0026hellip;), decorator được gọi thực thi và nó trả về hàm ten_decorator và chính nó sẽ bọc hàm được decorate. Hàm chuc_danh_decorator chỉ có tác dụng là dùng để truyền tham số vào decorator.  7. Debug hàm decorator. Khi sử dụng decorator thì hàm thực sự được gọi là hàm wrapper của trả về từ decorator. Nên các thuộc tính __name__, __doc__, __module__ không còn là của hàm được decorate nữa mà là của wrapper\nSử dụng lại code trong ví dụ 1:\n1print xuat_ten.__name__ 2 3\u0026gt;\u0026gt; wrapper Khắc phục: sử dụng thư viện functools Ví dụ 4:\n1from functools import wraps 2 3def ten_decorator(f): 4 @wraps(f) 5 def wrapper(ten): 6 chuoi_moi = \u0026#34;Ten tui la %s\u0026#34; % ten 7 return f(chuoi_moi) 8 return wrapper 9 10def xuat_ten( ten ): 11 print ten 12 13print xuat_ten.__name__ 14 15\u0026gt;\u0026gt; xuat_ten Decorator wraps sẽ lấy các thuộc tính __name__, __doc__, __module__ của hàm được decorate và gán cho hàm wrapper nên khi lấy những thuộc tính này sẽ trả về thông tin đúng.\n8. Khi nào nên sử dụng decorator? Tham khảo trang Wiki của Python\n","date":"21","image":null,"permalink":"https://bluzky.github.io/blog/2018-01-21-python-decorator/","tags":["python","python-basic"],"title":"Python decorator là gì? dùng khi nào"},{"categories":null,"contents":"Thực sự thì không nhất thiết phải là *args và **kwargs. điều quan trọng là tham số có 1 dấu sao * hay là 2 dấu sao **. Đặt tên tham số là *var hay **vars hay bất cứ thứ gì bạn muốn. Nhưng để dễ hiểu thì nên dùng tên chuẩn là *args và **kwargs\n1. *args và **kwargs dùng để làm gì?  Khi khai báo 1 hàm, sử dụng *args và **kwargs cho phép bạn truyền vào bao nhiêu tham số cũng được mà không cần biết trước số lượng. Ví dụ  1# với giả sử các tham số truyền vào đều là số 2def sum(*args): 3\ttotal = 0 4\tfor number in args: 5 total += number 6 return total 7 8# gọi hàm 9sum(1, 2, 3,19) 10sum( 1, 100) 2. *args và **kwargs khác gì nhau?  Cho những bạn chưa biêt: Khi gọi hàm trong Python, có 2 kiểu truyền tham số:  Truyền tham số theo tên. Truyền tham số bình thường theo thứ tự khai báo đối số. Ví dụ  1def register(name, password): 2\t.... 3# Truyền tham số theo kiểu thông thường, phải theo đúng thứ tự 4register( \u0026#39;Coulson\u0026#39;, \u0026#39;hail_Hydra\u0026#39;) 5# Truyền tham số theo tên, Không cần phải theo thứ tự khai báo thao số 6register( password=\u0026#39;cookHim\u0026#39;, name=\u0026#39;Skye\u0026#39;)  *args nhận các tham số truyền bình thường. Sử dụng args như một list. **kwargs nhận tham số truyền theo tên. Sử dụng **kwargs** như một. dictionary  Ví dụ\n1def test_args(*args): 2\tfor item in args: 3 print item 4 5\u0026gt;\u0026gt;test_args(\u0026#39;Hello\u0026#39;, \u0026#39;world!\u0026#39;) 6Hello 7world! 8 9def test_kwargs(*kwargs): 10\tfor key, value in kwargs.iteritems(): 11 print \u0026#39;{0}= {1}\u0026#39;.format(key, value) 12 13\u0026gt;\u0026gt;test_kwargs(name=\u0026#39;Dzung\u0026#39;, age=10) 14age = 10 15name = Dzung 3. Thứ tự sử dụng và truyền tham số *args, **kwargs và tham số bình thường Khi sử dụng phải khai báo đối số theo thứ tự:\n **đối số xác đinh \u0026ndash;\u0026gt; *args \u0026ndash;\u0026gt; **kwargs**\n Đây là thứ tự bắt buộc. Và khi truyền tham số bạn cũng phải truyền theo đúng thứ tự này. Không thể truyền lẫn lộn giữa 2 loại.\n Khi sử dụng đồng thời *args **kwargs thì không thể truyền tham số bình thường theo tên\n Ví dụ\n1def show_detail(name, *args, **kwargs): 2\t..... 3 4show_detail(name=\u0026#39;Coulson\u0026#39;, \u0026#39;agent\u0026#39;, age=\u0026#39;40\u0026#39;, level=\u0026#39;A\u0026#39;) 5\u0026gt;\u0026gt; Lỗi 6 7def show_detail_2(name, **kwargs): 8\t.... 9 10show_detail_2(name=Coulson\u0026#39;, age=\u0026#39;40\u0026#39;, level=\u0026#39;A\u0026#39;) 11\u0026gt;\u0026gt; Chạy Ok ","date":"21","image":null,"permalink":"https://bluzky.github.io/blog/2018-01-21-truyen-tham-so-dong-python/","tags":["python","python-basic"],"title":"Truyền tham số động trong python (*args | **kwargs)?"},{"categories":null,"contents":"1. Oauthh 2 và các khái niệm 1.1 Oauth 2 là gì: Oauth 2 là bản nâng cấp của giao thức chứng thực Oauth 1.0\n1.2 Các Role (vai trò) trong mô hình oauth  resource owner là đối tượng có khả năng cấp quyền truy cập tới tài nguyên (resource) được bảo vệ Resource server là một server lưu trữ các tài nguyên, có khả năng xử lý các yêu cầu truy cập tới tài nguyên được bảo vệ. Client Ứng dụng muốn truy cập vào protected resource với tư cách của người sở hữu resource Authorization server là server chuyên cấp access token cho client sau khi resource owner đồng ý cấp phép cho client truy xuất vào resource được bảo vệ  1.3 Luồng xử lý của giao thức 1+--------+ +---------------+ 2| |--(A)- Authorization Request -\u0026gt;| Resource | 3| | | Owner | 4| |\u0026lt;-(B)-- Authorization Grant ---| | 5| | +---------------+ 6| | 7| | +---------------+ 8| |--(C)-- Authorization Grant --\u0026gt;| Authorization | 9| Client | | Server | 10| |\u0026lt;-(D)----- Access Token -------| | 11| | +---------------+ 12| | 13| | +---------------+ 14| |--(E)----- Access Token ------\u0026gt;| Resource | 15| | | Server | 16| |\u0026lt;-(F)--- Protected Resource ---| | 17+--------+ +---------------+  (A) Ứng dụng client yêu cầu resource owner cấp quyền (B) Client nhận được sự cấp phép từ resource owner tùy theo loại grant trong yêu cầu. Nếu được chứng thực, client sẽ được cấp 1 authorization grant (C) Client yêu cầu Authorization server xác thực authorization grant từ resource owner. (D) Authorization server sẽ kiểm tra và xác nhận authorization grant. Nếu được xác thực, Client sẽ nhận được access token (E) Client request resource từ resource server, dính kèm access token trong request. (F)Resource Server sẽ kiểm tra tính hợp lệ của access token. Nếu token hợp lệ, resource theo yêu cầu sẽ được cấp phát.  1.4 Authorization Grant Authorization grant là một chứng nhận xác định những resource nào đã được cấp quyền truy cập bởi chủ sở hữu của resource. Nó được sử dụng bởi ứng dụng client để đổi lấy access token. Có 4 loại authorization grant:\n Authorization code Implicit Resource owner password credential Client credential  1.4.1 Authorization code Authorization code được cấp phát trong mô hình mà server ủy quyền đóng vai trò trung gian giữa client và resource owner. Client sẽ chuyển resource owner tới server ủy quyền. Sau khi resource owner đồng ý, server ủy quyền sẽ trả về cho clien authorization code\n1.4.2 Implicit Implicit grant là sự bản đơn giản hóa của Authorization code, thường được dùng trên các ứng dụng không có khả năng bảo mật authorization grant. Ví dụ như web browser hoặc ứng dụng mobile. Thay vì tạo ra các authorization code, client được nhận trực tiếp access token. Do sự đơn giản hóa của nó nên implicit grant dễ bị tấn công, và các vấn đề về bảo mật.\n1.4.3 Resource Owner Password Credentials Đây là phương thức xác thực trong đó ứng dụng clieownernt sẽ dùng username và password của người dùng/ resource owner để xác thực với server ủy quyền. Sau khi xác thực thì server ủy quyền sẽ trả về cho ứng dụng client access token và refresh token. Do đó ứng dụng client không cần phải lưu thông tin đăng nhập của resource owner. Kiểu chứng thực này chỉ được sử dụng trên những ứng dụng của đối tác có độ tin cậy cao.\n1.4 Các khái niệm khác 1.4.1 Access token  Access token là những chứng nhận dùng để truy cập vào những tài nguyên được bảo vệ. Access token là một chuỗi ký tự, chứa thông tin về chứng nhận được cấp cho ứng dụng client như: thời gian hết hạn, phạm vi tài nguyên được sử dụng \u0026hellip;. Access token có thể dùng để định danh người dùng. nó dùng để lấy thông tin của resource owner hoặc bản thân nó chứa thông tin của resource owner. Access token giúp cho việc xác thực đơn giản hơn. 4 cách yêu cầu cấp quyền từ resource owner đều tạo ra access token do đó resource server không cần phải biết phương thức chứng thực nào được sử dụng. Nó chỉ cần biết sử dụng access token là đủ.  1.4.2 Refresh token  Refresh token là chứng chỉ được sử dụng để trao đổi lấy access token. Nó được trả về cùng với authorization grant, và được dùng để yêu cầu cấp mới access token khi access token hiện tại hết hạn. Refresh token được sử dụng với server ủy quyền, không sử dụng với resource server.  1+--------+ +---------------+ 2 | |--(A)------- Authorization Grant ---------\u0026gt;| | 3 | | | | 4 | |\u0026lt;-(B)----------- Access Token -------------| | 5 | | \u0026amp; Refresh Token | | 6 | | | | 7 | | +----------+ | | 8 | |--(C)---- Access Token ----\u0026gt;| | | | 9 | | | | | | 10 | |\u0026lt;-(D)- Protected Resource --| Resource | | Authorization | 11 | Client | | Server | | Server | 12 | |--(E)---- Access Token ----\u0026gt;| | | | 13 | | | | | | 14 | |\u0026lt;-(F)- Invalid Token Error -| | | | 15 | | +----------+ | | 16 | | | | 17 | |--(G)----------- Refresh Token -----------\u0026gt;| | 18 | | | | 19 | |\u0026lt;-(H)----------- Access Token -------------| | 20 +--------+ \u0026amp; Optional Refresh Token +---------------+ Figure 2: Refreshing an Expired Access Token\n (A) Client gửi authorization grant và yêu cầu server ủy quyền cấp access tocken và refresh token (B) server ủy quyền xác thực client và authorization grant. Nếu hợp lệ, nó sẽ tạo ra access token và refresh token và trả về cho client (C) Client yêu cầu truy xuất tới resource được bảo vệ sử dụng access token (D) Resource server kiểm tra access token, nếu hợp lệ, thực hiện yêu cầu từ client. (E) bước (C) và (D) được lặp lại cho tới khi access token hết hạn. Nếu client biết access token hết hạn, nó sẽ chủ động chuyển qua bước (G), nếu không nó sẽ gửi request mới. (F) Phát hiện access token hết hạn, resource server trả về lỗi access token không hợp lệ. (G) Client gửi refresh token lên server ủy quyền và yêu cầu cấp phát access token mới. (H) server ủy quyền kiểm tra thông tin client và refresh token, nếu hợp lệ, nó sẽ cấp phát access token và có thể là cả refresh token mới  2. Đăng ký client  Trước khi có thể sử dụng giao thức oauth 2, client phải đăng ký với server ủy quyền. Việc đăng ký tùy thuộc vào server Thông tin đăng ký có thể bao gồm:\n Loại client redirection URI Một số thông tin khác: mô tả, tên ứng dụng \u0026hellip;.   2.1 Loại Client Oauth định nghĩa 2 loại client:\n confidential(bí mật): client có khả năng lưu trữ và bảo mật các chứng nhận được cấp. public (công khai): client không thể bảo vệ các chửng nhận được cấp một cách bí mật.  Việc phân loại này dựa trên các loại ứng dụng sau:\n Ứng dụng web: là một loại client bí mật(confidential) chạy trên web server. Resource owner truy cập tới ứng dụng web thông qua browser. Các chứng nhận được cấp cũng như access token được lưu trữ trên server và resource owner không thể đọc những thông tin này. Ứng dụng trên nền browser: là loại public client trong đó code của ứng dụng client được tải về và chạy trên thiết bị của người dùng. Các chứng nhận, access token có thể dễ dàng truy cập bởi người sử dụng. Ứng dụng native: là một dạng public client, được cài và thực thi trên thiết bị của người dùng. Các dữ liệu của giao thức và các dữ liệu bí mật như access token có thể được truy xuất bởi người dùng với giả sử rằng ứng dụng có thể bị tách ra(extracted). Tuy nhiên ứng dụng có thể định nghĩa một số phương thức bảo vệ các thông tin bí mật của giao thức. Tùy vào nền tảng(platform) các thông tin này có thể được bảo vệ tránh sự truy xuất của các ứng dụng khác trên cùng thiết bị.  2.2 Định danh client (client identifier) Với mỗi client đăng ký, server ủy quyền sẽ tạo ra một chuỗi duy nhất để xác định client đó(được gọi là client identifier). Client identifier được công khai, được dùng để server ủy quyền kiểm tra liệu client có hợp lệ hay không.\n2.3 Chứng thực client Đối với loai client bí mật(confidential), client và server ủy quyền thiết lập một phương pháp phù hợp để xác thực client. Phương thức xác thực này là tùy vào client và server\n2.4 Mật khẩu của client  Nếu client sử dụng password. Nó có thể dùng mô hình chứng thực cung cấp bởi giao thức HTTP(RFC2617). Định danh của client được mã hóa sử dụng thuật toán \u0026ldquo;application/x-www-form-urlencoded\u0026rdquo;. Giá trị sau khi mã hóa được sử dụng như mật khẩu của client. server ủy quyền phải hỗ trợ mô hình chứng thực của giao thức HTTP. Một cách khác, server ủy quyền có thể hỗ trợ việc gửi thông tin của client trong thân của request( request-body) với các tham số: - client_id [REQUIRED]: định danh của client - client_secret [REQUIRED]: chuỗi bí mật của client\nVí dụ:  POST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded grant_type=refresh_token\u0026amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA \u0026amp;client_id=s6BhdRkqt3\u0026amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw  Phương pháp gửi thông tin client qua request-body không được khuyến khích sử dụng. Bởi vì nó dễ bị tấn công hơn so với phương pháp đầu tiên.\n 3. Các điểm cuối của giao thức (Protocol Endpoint) Tiến trình chứng thực trên server có 2 điểm cuối(endpoint)\n Authorization endpoint : được sử dụng bởi client để yêu cầu sự xác nhận từ resource owner thông qua user-agent(thường là browser). Token endpoint: được sử dụng bởi client để trao đổi authorization grant lấy access token.  Phía client chỉ có 1 điểm cuối:\n Redirection endpoint: là điểm mà server ủy quyền dùng để trả về thông tin cho client thông qua user-agent(thường là browser) của resource owner   Không phải tất cả các kiểu chứng thực đều tạo ra 2 endpoint. Một số kiểu chứng thực mở rộng có thể tạo ra các endpoint khác\n 3.1 Authorization Endpoint(sơ lược) Authorization endpoint được sử dụng để tương tác với resource owner, yêu cầu sự cấp quyền từ resource owner. server ủy quyền trước tiên phải xác thực resource owner.\n3.1.1 Response type (kiểu trả về) Đối với trường hợp authorization endpoint được sử dụng bởi authorization code và implicit grant, client thông báo với server ủy quyền kiểu cấp quyền sử dụng tham số: response_type [REQUIRED] có thể là một trong 2 giá trị sau:\n code \u0026ndash;\u0026gt; yêu cầu sử dụng kiểu authorization code token \u0026ndash;\u0026gt; yêu cầu cấp phát access token (sử dụng cho implicit)  có thể mở rộng response_type tùy nhu cầu. Có thể cùng lúc request nhiều response_type; các gía trị phải cách nhau bằng khoảng trắng.\n3.2 Redirection Endpoint (sơ lược)  Sau khi yêu cầu cấp quyền xong, server ủy quyền chuyển hướng user-agent vào redirection URI lúc đăng ký client. Request này chứa các thông tin về chứng chỉ đã được cấp phát cho client. Một client có thể đăng ký nhiều redirection URI. Nếu không có URI nào được đăng ký thì rất dễ bị tấn công. Nếu nhiều URI được đăng ký, thì lúc yêu cầu chứng thực, client phải gửi kèm tham số redirect_uri. server ủy quyền sẽ tìm URI giống với trong request để trả về các chứng nhận  3.3 Token endpoint (sơ lược) Token endpoint được sử dụng bởi client, là nơi xác thực authorization grant và trả vê access token và refresh token cho client.\n3.4 Phạm vi(scope) của access token  Authorization endpoint và Token endpoint cho phép client xác định phạm vi/ giới hạn truy xuất của request thông qua tham số scope. Sau khi được cấp quyền, authorization server sử dụng scope để xác định các giới hạn/ phạm vi được quyền truy cập đối với access token được trả về. Scope được thể hiện dưới dạng một chuỗi gồm nhiều scope cách nhau bằng khoảng trắng. Nếu scope của access token được cấp phát giống với scope trong request của client thì server có thể bỏ qua tham số scope trong response. Nếu scope khác với trong request thì bắt buộc phải trả về tham số scope trong response.  4. Lấy ủy quyền (Obtain authorization) Để yêu cầu một access token, client cần phải nhận được sự ủy quyền từ resource owner. Sự ủy quyền được thể hiện dưới dạng authorization grant. Client sử dụng nó để yêu cầu lấy một access token. Có 4 loại cấp quyền: authorization code, implicit, resource owner password credentials, và client credentials.\n4.1 Cấp quyền sử dụng code thay thế cho ủy quyền (Athorization code grant)  Kiểu này sử dụng để yêu cầu cả access token và refresh token, thường dùng với confidential client. Kiểu cấp quyền này dựa trên redirection (chuyển hướng) nên client phải có thể tương tác với user-agent (browser) cà nhận request thông qua redirection từ server ủy quyền. Sơ đồ:   +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- \u0026amp; Redirection URI ----\u0026gt;| | | User- | | Authorization | | Agent -+----(B)-- User authenticates ---\u0026gt;| Server | | | | | | -+----(C)-- Authorization Code ---\u0026lt;| | +-|----|---+ +---------------+ | | ^ v (A) (C) | | | | | | ^ v | | +---------+ | | | |\u0026gt;---(D)-- Authorization Code ---------' | | Client | \u0026amp; Redirection URI | | | | | |\u0026lt;---(E)----- Access Token -------------------' +---------+ (w/ Optional Refresh Token) Note: Các đường thẳng minh hoạ bước (A), (B), và (C) được chia thành 2 phần bởi vì chúng được thực hiện thông qua user agent Figure 3: Quá trình cấp code ủy quyền  (A)client khởi tạo luồng xử lý bằng việc chuyển hướng user-agent(browser) của resource owner tới authorizatio endpoint. Client gửi kèm theo định danh của nó được server ủy quyền cấp, phạm vi quyền hạn (scope), redirection URI. (B)Server ủy quyền sẽ xác thực resource owner (yêu cầu đăng nhập) và yêu cầu resource owner quyết định đồng ý hay từ chối yêu cầu cấp quyền. (C) Giả sử resource owner đồng ý cấp quyền, server ủy quyền sẽ chuyển hướng user-agent đến clien sử dụng redirection URI, kèm theo đó là auhthorization code (code xác nhận ủy quyền). (D) Client yêu cầu cấp access token tới server ủy quyền, kèm theo đó là authorization code từ bước (C) vả redirection URI. (E) Server ủy quyền xác thực client, kiểm tra sự hợp lệ của authorization code và redirection URI. Nếu tất cả đều hợp lệ, server xác thực sẽ trả về cho client access token và có thể gồm refresh token.  4.1.1 Yêu cầu ủy quyền (Authorization request) Client tạo 1 request với các tham số sau, sử dụng định dạng application/x-www-form-urlencoded\n response_type [REQUIRED] phải có giá trị là code client_id [REQUIRED] định danh của client, được nói trong phần 2 redirect_uri [OPTIONAL] url chuyển hướng đến sau khi được ủy quyền scope [OPTIONAL] giới hạn/phạm vi của request được ủy quyền. Trong phần 3.4 state [RECOMMENDED]. được sử dụng bởi client để truyền thông tin trạng thái từ request và callback. Server ủy quyền sẽ gửi kèm state khi chuyển hướng tới redirec URI. state nên được sử dụng để ngăn chặn kiểu tấn công cross-site request forgery. Ví dụ  GET /authorize?response_type=code\u0026amp;client_id=s6BhdRkqt3\u0026amp;state=xyz \u0026amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1 Host: server.example.com 4.1.2 Kết quả nếu thành công (Authorization response) Nếu resource server đồng ý cấp quyền truy cập, server ủy quyền sẽ sinh ra một code xác nhận ủy quyền (authorization code) và trả về cho client thông qua redirection URI với các tham số sau:\n code [REQUIRED] code ủy quyền được sinh ra bởi server ủy quyền. Nó phải hết hạn trong khoảng thời gian ngắn, khuyến khích tối đa là 10 phút để tránh bị rò rỉ. clien chỉ được sử dụng authorization code 1 lần. Nếu nhiều hơn 1 lần thì server ủy quyền phải từ chối và nên hủy bỏ các access token đã cấp sử dụng authorization code đó ngay khi có thể. state [REQUIRED] nếu tham số state được gửi đi trong authorization request thì nó sẽ được nhận lại nguyên vẹn ở client. Ví dụ  HTTP/1.1 302 Found Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA \u0026amp;state=xyz Client phải bỏ qua tất cả các tham số khác nếu có.\n4.1.3 Kết quả trả về nếu bị lỗi (Error response) Nếu yêu cầu ủy quyền thất bại, server ủy quyền phải thông báo cho client biết lý do và không được tự động chuyển hướng qua redirection URI không hợp lệ. Lỗi nên được trả về thông qua redirection URI với các tham số sau:\n error [REQUIRED] một chuỗi ký tự ASCII trong các lỗi sau: - unauthorized_client: client không được ủy quyền để yêu cầu authorization code - access_denied: resource owner hoặc server ủy quyền từ chối request - unsupported_response_type: server ủy quyền không hỗ trwoj việc lấy authorization code sử dụng phương thức này. - invalid_scope: scope trong yêu cầu cấp quyền không hợp lệ. - server_eror: server ủy quyền gặp một lỗi không xác định nên nó không thể thực hiện việc cấp ủy quyền được. - temporarily_unavailable: server ủy quyền tạm thời không thể xử lý yêu cầu vì một lý do nào đó. error_description [OPTIONAL] chuỗi ký tự cung cấp thông tin chi tiết về lỗi mà con người có thể đọc được error_uri [OPTIONAL] một URI dẫn tới một trang web cung cấp thông tin về lỗi state [REQUIRED] bắt buộc phải có nếu trong request gửi lên server có kèm theo tham số state.  4.1.4 Yêu cầu cấp Access token Client gửi yêu cầu cấp token tới token endpoint cùng với các tham số sau sử dụng kiểu định dạng( format) application/x-www-form-urlencoded.\n grant_type [REQUIRED] giả trị phải là authorization_code. code [REQUIRED] authorization code nhận được từ server ủy quyền. redirect_uri [REQUIRED] cần phải có nếu tham số redirect_uri được gửi đi lúc yêu cầu ủy quyền trong phần 4.1.1 client_id [REREQUIRED] định danh của lient Ví dụ:  1\tPOST /token HTTP/1.1 2 Host: server.example.com 3 Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW 4 Content-Type: application/x-www-form-urlencoded 5 6 grant_type=authorization_code\u0026amp;code=SplxlOBeZQQYbYS6WxSbIA 7 \u0026amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb Server ủy quyền phải:\n Yêu cầu client chứng thực đối với confidential client Đảm bảo rằng authorization code được cấp phát cho đúng client. Nếu client là public thì đảm bảo rằng code được cấp đúng cho client_id trong request Kiểm tra authorization code có còn hợp lệ hay không Đảm bảo tham redirect_uri được gửi nếu redirect_uri đã được gửi trong yêu cầu 4.1.1  4.1.5 Kết quả cấp access token Nếu yêu cầu hợp lệ và quá trình cấp phát thành công, server ủy quyền sẽ tạo ra một access token và có thể kèm theo refresh token. Nếu yêu cầu thất bại thì server sẽ trả về lỗi được trình bày trong phàn 5.2. Ví dụ:\n1\tHTTP/1.1 200 OK 2 Content-Type: application/json;charset=UTF-8 3 Cache-Control: no-store 4 Pragma: no-cache 5 6 { 7 \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, 8 \u0026#34;token_type\u0026#34;:\u0026#34;example\u0026#34;, 9 \u0026#34;expires_in\u0026#34;:3600, 10 \u0026#34;refresh_token\u0026#34;:\u0026#34;tGzv3JOkF0XG5Qx2TlKWIA\u0026#34;, 11 \u0026#34;example_parameter\u0026#34;:\u0026#34;example_value\u0026#34; 12 } 4.2 Implicit grant Implicit grant được sử đụng để lấy access token (không hỗ trợ refresh token) và được sử dụng trong các client công khai. Sơ đồ hoạt động:\n\t+----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- \u0026amp; Redirection URI ---\u0026gt;| | | User- | | Authorization | | Agent -|----(B)-- User authenticates --\u0026gt;| Server | | | | | | |\u0026lt;---(C)--- Redirection URI ----\u0026lt;| | | | with Access Token +---------------+ | | in Fragment | | +---------------+ | |----(D)--- Redirection URI ----\u0026gt;| Web-Hosted | | | without Fragment | Client | | | | Resource | | (F) |\u0026lt;---(E)------- Script ---------\u0026lt;| | | | +---------------+ +-|--------+ | | (A) (G) Access Token | | ^ v +---------+ | | | Client | | | +---------+ Note: Đường thẳng minh họa các bước (A) và (B) được chia thành 2 phần vì chúng được chuyển thông qua user-agent. Figure 4: Implicit Grant Flow  (A) client khởi tạo luồng chứng thực bằng việc chuyển hướng user-agent của resource owner tới authentication endpoint. Client gửi kèm theo đó là định danh client, phạm vi/giới hạn yêu cầu, trạng thái hiện tại và URI chuyển hướng sau khi được ủy quyền. (B) Server ủy quyền sẽ xác thực người dùng, và hỏi người dùng có chấp nhận ủy quyền hay từ chối yêu cầu từ client. (C) giả sử resource owner được cấp quyền truy cập, server ủy quyền sẽ chuyển hướng user-agent đến redirection URI trong bước (A) kèm theo access token trong URI fragment(phần sau dấu # trên URL) (D) user-agent giữ lại thông tin về access token và chuyển hướng tới redirection URI của ứng dụng web. (E) ứng dụng web của client trả về một trag web với khả lấy và sử dụng access token trên user-agent. (F) user-agent thực thi các script từ ứng dụng web để lấy access token . (G) user-agent chuyển access token cho client sử dụng.  4.2.1 Yêu cầu ủy quyền: Client tạo một request với các tham số sau, sử dụng định dạng application/x-www-form-urlencoded.\n response_type [REQUIRED] giá trị phải là token client_id [REQUIRED] định đanh của client redirect_uri [OPTIONAL] (đã nói ở phần trước). scope [OPTIONAL] (đã nói ở phần trước). state [RECOMMENDED] (giống như authorization code grant)  Ví dụ:\n\tGET /authorize?response_type=token\u0026amp;client_id=s6BhdRkqt3\u0026amp;state=xyz \u0026amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1 Host: server.example.com Server ủy quyền sẽ kiểm tra request để đảm bảo các tham số đầy đủ và hợp lệ. Nếu tất cả thông tin đều hợp lệ thì server ủy quyền sẽ chứng thực resource owner và hỏi việc cấp quyền từ resource owner. Sau khi hoàn tất, server sẽ chuyển thông tin về cho client thông qua redirection URI\n4.2.2 Access token trả về Nếu resource owner chấp nhận yêu cầu ủy quền thì server sẽ trả về trong redirection URI với các tham số sau:\n access_token [REQUIRED] access token cấp phát bởi server token_type [REQUIRED] loại token được cấp phát. Trình bày trong phần 7 expired_in [RECOMMENDED] thời gian sống của access token tính theo giây scope [OPTIONAL] tùy chọn nếu giống với scope trong request, bắt buộc trả về trong trường hợp ngược lại. state bắt buộc nếu trong request có gửi kèm tham số state  Server không được trả về refresh_token\nVí dụ\n\tHTTP/1.1 302 Found Location: http://example.com/cb# access_token=2YotnFZFEjr1zCsicMWpAA \u0026amp;state=xyz\u0026amp;token_type=example\u0026amp;expires_in=3600 4.2.3 Lỗi trả về Nếu quá trình xin ủy quyền thất bại thì server sẽ trả về các tham số sau trong thông qua redirect URI\n error [REQUIRED] một chuỗi ký tự ASCII chứa mã lỗi trong những chuỗi sau: - invalid_request request thiếu tham số hoặc các tham số không hợp lệ. - unauthorized_client client không được ủy quyền đối với phương pháp này. - access_denied rresource ơnowner từ chối ủy quyền cho client. - unsupported_response_typeserver ủy quyền không hỗ trợ phương thức ủy quyền này. - invalid_scope quyền hạn yêu cầu không hợp lệ, sai định đạng. - server_error lỗi server không thể tiếp tục quá trình xin cấp ủy quyền. - temporarily_unavailable server tạm thời không thể xử lý yêu cầu xin cấp ủy quyền. error_description [OPTIONAL] mô tả chi tiết của lỗi xảy ra. error_uri một URI dẫn tới mội trang web chứa thông tin chi tiết về lỗi xảy ra. state bắt buộc phải có nếu trong request có gửi kèm tham số state.  Ví dụ:\n HTTP/1.1 302 Found Location: https://client.example.com/cb# error=access_denied\u0026amp;state=xyz 4.3 Cấp quyền sử dụng thông tin đăng nhập của resource owner. Chỉ nên sử dụng khi client và resource owner có mối quan hệ tin tưởng lẫn nhau.\nLuồng xử lý:\n +----------+ | Resource | | Owner | | | +----------+ v | Resource Owner (A) Password Credentials | v +---------+ +---------------+ | |\u0026gt;--(B)---- Resource Owner -------\u0026gt;| | | | Password Credentials | Authorization | | Client | | Server | | |\u0026lt;--(C)---- Access Token ---------\u0026lt;| | | | (w/ Optional Refresh Token) | | +---------+ +---------------+ Figure 5: Resource Owner Password Credentials Flow  (A) resource owner cung cấp thông tin username, password cho client. (B) Client yêu cầu server ủy quyền cấp access token cho nó, kèm theo đó là thông tin đăng nhập của resource owner. Đồng thời server ủy quyền cũng chứng thực client. (C) server ủy quyền kiểm tra tất cả các thông tin, nếu hợp lệ nó sẽ tạo access token và trả về cho client.  4.3.1 Yêu cầu access token Client sau khi lấy được thông tin đăng nhập của resource owner , tạo một request kèm các thông số sau, sử dụng format \u0026quot;application/x-www-form-urlencoded\u0026quot;\n grant_type [REQUIRED] giá trị phải là \u0026quot;password\u0026quot;. user_name [REQUIRED] username của resource owner. password [REQUIRED] password của resource owner. scope [OPOPTIONAL] phạm vi quyền hạn được ủy quyền.  Ví dụ:\n1\tPOST /token HTTP/1.1 2 Host: server.example.com 3 Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW 4 Content-Type: application/x-www-form-urlencoded 5 6 grant_type=password\u0026amp;username=johndoe\u0026amp;password=A3ddj3w 4.3.2 Kết quả access token Nếu quá trình xin ủy quyền thực hiện thành công. Server ủy quyền tạo ra access token và có thể cả refresh token và trả về cho client\nVí dụ: cấp phát thành công\n1 HTTP/1.1 200 OK 2 Content-Type: application/json;charset=UTF-8 3 Cache-Control: no-store 4 Pragma: no-cache 5 6 { 7 \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, 8 \u0026#34;token_type\u0026#34;:\u0026#34;example\u0026#34;, 9 \u0026#34;expires_in\u0026#34;:3600, 10 \u0026#34;refresh_token\u0026#34;:\u0026#34;tGzv3JOkF0XG5Qx2TlKWIA\u0026#34;, 11 \u0026#34;example_parameter\u0026#34;:\u0026#34;example_value\u0026#34; 12 } 4.4 Cấp quyền bằng thông tin chứng thực của client Client có thể yêu cầu cấp access token sử dung thông tin chứng thực của chính nó. Kiểu ủy quyền này chỉ được sử dụng cho confidential client.\nLuồng xử lý:\n +---------+ +---------------+ | | | | | |\u0026gt;--(A)- Client Authentication ---\u0026gt;| Authorization | | Client | | Server | | |\u0026lt;--(B)---- Access Token ---------\u0026lt;| | | | | | +---------+ +---------------+ Figure 6: Client Credentials Flow  (A) client chứn thực nó với server ủy quyền và yêu cầu cấp access token từ token endpoint. (B) server ủy quyền chứng thực client, nếu hợp lệ, cấp một access token.  4.4.1 Yêu cầu cấp Access token Client gửi tạo một request với các tham số sau, sử dụng format \u0026quot;application/x-www-form-urlencoded\u0026quot;:\n grant_type [REREQUIRED] giá trị bắt buộc là client_credentials. scope [OPTIONAL] phạm vi quyền hạn được ủy quyền.  Ví dụ:\n POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded grant_type=client_credentials 4.4.2 Kết quả access token Nếu quá trình chứng thực thành công thì server trả về cho client access token nhưng không nên gửi refresh token. Ví dụ:\n1\tHTTP/1.1 200 OK 2 Content-Type: application/json;charset=UTF-8 3 Cache-Control: no-store 4 Pragma: no-cache 5 6 { 7 \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, 8 \u0026#34;token_type\u0026#34;:\u0026#34;example\u0026#34;, 9 \u0026#34;expires_in\u0026#34;:3600, 10 \u0026#34;example_parameter\u0026#34;:\u0026#34;example_value\u0026#34; 11 } 4.5 Mở rộng kiểu cấp ủy quyền Client sử dụng kiểu cấp ủy quyền mở rộng bằng cách thay đổi giá trị của tham số grant_type trong request gửi tới token endpoint và thêm các tham số khác nếu cần thiết.\nPHẦN NÀY KHÔNG DỊCH CHI TIẾT\n5 Cấp phát access token 5.1 Kết quả trả về nếu thành công Các thông tin trả về được chứa trong body của gói tin HTTP trả về với mã lỗi 200. Các tham số:\n access_token [REQUIRED] access token được cấp. token_type [REQUIRED] loại token được cấp phát. xem phần 7 expires_in [RECOMMENDED] thời gian sống của access token. refresh_token [OPTIONAL] token dùng để xin cấp lại access token khi hết hạn. scope [OPTIONAL] nếu scope giống với trong request. [REQUIRED] nếu khác với trong request.  Các tham số được chứa trong thân của của HTTP response có định dạng \u0026quot;application/json\u0026quot; Server ủy quyền phải kèm theo header \u0026ldquo;Cache-Control\u0026rdquo; trong gói response với giá trị là \u0026ldquo;no-store\u0026rdquo;\nVí dụ:\n1\tHTTP/1.1 200 OK 2 Content-Type: application/json;charset=UTF-8 3 Cache-Control: no-store 4 Pragma: no-cache 5 6 { 7 \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, 8 \u0026#34;token_type\u0026#34;:\u0026#34;example\u0026#34;, 9 \u0026#34;expires_in\u0026#34;:3600, 10 \u0026#34;refresh_token\u0026#34;:\u0026#34;tGzv3JOkF0XG5Qx2TlKWIA\u0026#34;, 11 \u0026#34;example_parameter\u0026#34;:\u0026#34;example_value\u0026#34; 12 } Client phải bỏ qua các tham số khác không được xách định ở trên.\n5.2 Lỗi trả về Nếu quá trình xin ủy quyền thất bại thì server sẽ trả về các tham số sau trong thông qua redirect URI\n error [REQUIRED] một chuỗi ký tự ASCII chứa mã lỗi trong những chuỗi sau: - invalid_request request thiếu tham số hoặc các tham số không hợp lệ. - invalid_client việc chứng thực client thất bại. - invalid_grant phương pháp thực hiện việc cấp quền hoặc refresh token không hợp lệ, hết hạn, bị hủy bỏ, redirection URI không đúng. - unauthorized_client client không được ủy quyền đối với phương pháp này. - unsupported_response_typeserver ủy quyền không hỗ trợ phương thức ủy quyền này. - invalid_scope quyền hạn yêu cầu không hợp lệ, sai định đạng. error_description [OPTIONAL] mô tả chi tiết của lỗi xảy ra. error_uri một URI dẫn tới mội trang web chứa thông tin chi tiết về lỗi xảy ra.  Các tham số này được chứa trong body của response sử dụng loại media \u0026quot;application/json\u0026quot;\nVí dụ:\n1 HTTP/1.1 400 Bad Request 2 Content-Type: application/json;charset=UTF-8 3 Cache-Control: no-store 4 Pragma: no-cache 5 6 { 7 \u0026#34;error\u0026#34;:\u0026#34;invalid_request\u0026#34; 8 } 6 Làm mới access token Client gửi request tới token endpoint với các tham số sau sử dụng format \u0026quot;application/x-www-form-urlencoded\u0026quot;:\n grant_type [REQUIRED] giá trị phải là refresh_token. refresh_token [REQUIRED] chuỗi refresh token. scope [OPTIONAL] phạm vi quyền hạn truy cập, các quyền ở đây phải là những quyền nằm trong scope lúc yêu cầu cấp access token. Nếu không có tham số scope thì mặc định phạm vi quyền hạn sẽ giống như lúc yêu cầu cấp phát access token.  Ví dụ:\n\tPOST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded grant_type=refresh_token\u0026amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA Server ủy quyền sẽ:\n Chứng thực client. Kiểm tra refresh token có đúng là được cấp cho client hay không. Kiểm tra refresh token có hợp lệ hay không.  Nếu tất cả các thông tin đều hợp lệ thì server ủy quyền sẽ cấp token mới cho client. Server có thể tạo refresh token mới, khi đó refresh token cũ sẽ không còn hợp lệ.\n7. Truy cập vào tài nguyên được bảo vệ Client truy cập vào tài nguyên được bảo vệ bằng cách cung cấp access token cho resource server. Resource servẻ phải kiểm tra access token để đảm bảo rằng nó còn hiệu lực và nằm trong phạm vi truy cập.\n7.1 Các loại access token Loại của access token được trả về cùng với access token khi cấp phát thành công. Có 2 loại access token:\n bearer mac ở đây không nói chi tiết về 2 loại token này. Tham khảo RFC6750 và OAuth-HTTP-MAC  7.2 Trả lỗi Nếu yêu cầu truy xuất tài nguyên thất bại, resource server nên thông báo client lỗi đã xảy ra\n8. Mở rộng giao thức: (không dịch) 9. Ứng dụng native:(không dịch) 10. Các nguy cơ bảo mật. 10.1 Chứng thực client 10.2 Mạo danh client  Một client nguy hiểm có thể mạo danh một client khác và lấy quyền truy cập tới tài nguyên được bảo vệ nếu client bị mạo danh thất bại hoặc không thể giữ bí mật các thông tinh chứng thực của nó. Server phải chứng thực client bất cứ khi nào có thể. Yêu cầu client đăng ký redirection URI để nhận kết quả ủy quyền. Server ủy quyền nên cung cấp cho người dùng thông tin về client và quyền hạn mà client yêu cầu. Server ủy quyền không nên tự động lặp lại việc ủy quyền mà không xác thực client hoặc dựa trên các cách khác để đảm bảo request đến từ cùng client  10.3 Access token  Access token phải được giữ bí mật trong quá trình lưu trữ và truyền tải. Và chỉ chia sẻ giữa server ủy quyền, resource server và client sở hữu nó. Access token chỉ được truyền tải qua giao thức TLS. Khi sử dụng kiểu cấp ủy quyền implicit, access token được gắn vào URI nên dễ dàng bị đánh cắp bởi các bên/ứng dụng khác. Server ủy quyền phải đảm bảo rằng access token không thể được tạo ra, thay đổi hoặc đoán được bởi một bên nào khác không được chứng thực. Client nên yêu cầu cấp access token với phạm vi truy cập tối thiểu cần thiết cho nó.  10.4 Refresh token  Server ủy quyền có thể cấp refresh token cho ứng dụng web hoặc ứng dụng native. Refresh token phải được giữ bí mật trong lưu trữ và truyền tải. Và chỉ được chia sẻ giữa server ủy quyền và client được cấp phát. refresh token phải được truyền tải qua giao thức TLS. Server ủy quyền phải kiểm tra liệu refresh token có phải được cấp phát cho client hay không. Trong trường hợp không thể chứng thực client, server nên sử dụng các cách khác để phát hiện việc lạm dụng refresh token. Server ủy quyền phải đảm bảo rằng refresh token không thể được tạo ra, thay đổi hoặc đoán được bởi một bên nào khác không được chứng thực.  10.5 Authorization code   Việc truyền tải authorization code nên được thực hiện thông qua một kênh bảo mật. Client nên sử dụng giao thức TLS cho redirection URI. Authorization code được truyền thông qua user-agent nên nó có thể bị bắt lại ở user agent.\n  Authorization code phải có thời gian sống ngắn và chỉ được dùng một lần. Nếu server ủy quyền nhận thấy authorization code được sử dụng lại nhiều lần, server nên hủy tất cả các access token đã cấp phát dựa trên authorization code này.\n  Nếu có thể, server ủy quyền nên chứng thực clien và kiểm tra authorization code có được cấp phát cho đúng client hay không.\n  10.7 Authorization Code Redirection URI Manipulation  Khi sử dụng phương thức cấp quyền authorization code, client xác định URI chuyển hướng băng tham số redirect_uri. Nếu kẻ tấn công có thể thay đổi giá trị của redirect_uri nó có thể làm cho server chuyển hướng kết quả tới URI của kẻ tấn công. Kẻ tấn côn có thể tạo tài khoản trên một server hợp lệ và khởi tạo luồng cấp ủy quyền. Khi user-agent của kẻ tấn công đang request tới server ủy quyền để yêu cầu cấp quyền truy cập, hắn thay thế URI của client hợp pháp và thay bằng URI của hắn. Sau đó kẻ tấn công lừa cho nạn nhân sử dụng link đã được thay đổi để cấp quyền truy cập cho client hợp lệ.  Một khi server ủy quyền hoàn thành việc cấp ủy quyền, nạn nhân sau đó sẽ được chuyển hướng tới một trang khác của kẻ tấn công cùng với authorization code. Sau đó attacker gửi authorization code tới client. client sử dụng thông tin đó để cấp quyền truy cập cho account của kẻ tấn công, và hắn có thể sử dụng tài khoản của mình để truy cập vào tài nguyên được bảo vệ của nan nhân thông qua client.\nĐể ngăn chặn kiểu tấn công như vậy: - Server ủy quyền phải đảm bảo rằng redirection URI được sử dụng để lấy code ủy quyền phải giống với redirection URI khi đổi authorization code lấy access token. - Server ủy quyền yêu cầu public client phải đăng ký redirection URI và confidential client cũng nên đăng ký redirection URI. server sẽ kiểm tra URI trong request có đúng với URI đã đăng ký hay không.\n10.7 Resource Owner Password Credentials  Kiểu cấp quyền này có nhiều nguy cơ bị tấn công hơn so với những kiểu khác bởi vì nó sử dụng username và password là điều mà giao thức oauth2 muốn tránh khỏi.Client có thể lạm dụng hoặc để lộ mậu khẩu. Thêm vào đó, resource owner không được tham gia vào quá trình cấp quyền nên client có thể yêu cầu cấp phạm vi quyền hạn lớn hơn. Server ủy quyền nên xem xét thời gian sống và và phạm vi(scope) của access token trong kiểu cấp quyền này. Server ủy quyền và client nên hạn chế sử dụng kiểu cấp quyền này và sử dụng kiểu ủy quyền khác bất cứ khi nào có thể.  10.8 Request Confidentiality  access token, refresh token , resource owner password, và client credential KHÔNG ĐƯỢC truyền tại dưới dạng text rõ ràng (không được hash hay mã hóa). Authorization code KHÔNG NÊN truyền dưới dạng text rõ ràng. state và scope không nên chứa các thông tin nhạy cảm ủa client hoặc resource owner dưới dạng text rõ ràng bởi vì chúng có thể được truyền tải qua một kênh không an toàn.  10.9 Ensuring Endpoint Authenticity Để ngăn chặn kiểu tấn công man-in-the-middle, server ủy quyền phải yêu cầu sử dụng kênh truyền TLS.\n10.10 Credentials-Guessing Attacks  Server ủy quyền phải ngăn chặn kẻ tấn công đoán access token, mật khẩu của resource owner và thông tin đăng nhập của client. Khả năng kẻ tấn công đoán ra access token PHẢI nhỏ hơn hoặc bằng 2^(-128) và NÊN nhỏ hơn hoặc bằng 2^(-160)  10.11 Phishing Attacks 10.12 Cross-Site Request Forgery   Là kiểu tấn công trong đó kẻ tấn công làm cho user-agent của người dùng chuyển hướng theo một URI nguy hiể tới server đang được tin tưởng (thông thường được thiết lập qua một session cookie hợp lệ).\n  Tấn công CSRF dựa trên redirection URI cho phép kẻ tấn công thay thế bằng authorization code hoặc access token của hắn. Kết quả là client sẽ sử dụng access token liên kết với protected resource của kẻ tấn công thay vì của nạn nhân (Ví dụ như lưu thông tin tín dụng của nạn nhân vào tài khoản của kẻ tấn công).\n  Client phải hỗ trợ ngăn chặn CSRF đối với redirection URI của nó. Việc này có thể thực hiện bằng việc yêu cầu mọi request gửi tới redirection URI endpoint phải kèm theo một giá trị gắn request với trạng thái chứng thực của user-agent . Client nên tạo tham số state trong request gửi tới server ủy quyền.\n  Sâu khi cấp quyền, server trả về cho client kết quả kèm theo state của request. Thông tin này cho phép client kiểm tra tính hợp lệ của request.\n  Tấn công CSRF trên authorization endpoint của server ủy quyền có thể dẫn tới kết quả là kẻ tấn công lấy được ủy quyền của user cho một client nguy hiểm mà user không hề biết.\n  Server ủy quyền phải hỗ trợ việc ngăn chặn CSRF đối với authorization enpoint của nó và đảm bảo rằng client nguy hiểm không thể nhận được ủy quyền mà không có sự chấp thuận của resource owner.\n  10.13 Clickjacking  Đối với tấn công Clickjacking, kẻ tấn công đăng ký một client hợp lệ và tạo một website nguy hiểm để tả authorizatin endpoint của server ủy quyền trong một iframe trong suôt, và tạo các button tại vị trí các button trên trang của server ủy quyền. Khi người dùng click lên các button do kẻ tấn công tạo ra, họ đã vô tình click lên cac button vô hình trên trang cấp quyền(ví dụ như nút Authorize). Điều này giúp kẻ tấn công đánh lừa người dùng cấp quyền truy cập cho hắn mà người dùng không hề hay biết. Để ngăn chặn kiểu tấn công này, các ứng dụng native nên sử dụng các trình duyện bên ngoài thay vì nhúng trình duyệt bên trong ứng dụng, việc chặn các iframe có thể được thực hiện bằng việc server ủy quyền sử dụng \u0026quot;x-frame-options\u0026quot; header. Header này có nhận 1 trong hai giá trị deny hoặc \u0026lsquo;sameorigin\u0026rsquo;. Thiết lập này ngăn việc sử dụng iframe hoặc chặn iframe từ các trang không cùng domain.  10.14 Code Injection and Input Validation  Tấn công code injection xảy ra khi các biến bên ngoài hoặc input nhận vào và được sử dụng mà không được khử độc (:) sanitize) và do đó làm thay đổi logic của ứng dụng. Việc này cho phép kẻ tấn công lấy được quyền truy cập vào device mà ứng dụng đang chạy hoặc dữ liệu ứng dụng, gây từ chối dịch vụ hoặc là nhiều tác động nguy hiểm khác. Server ủy quyền và client nên sanitize(khử độc, khử trùng, khử) các giá trị nhận được, đặc biệt là tham số state và redirect_uri.  10.15 Open Redirectors  Server ủy quyền, authorization endpoint và client redirection endpoint có thể được cấu hình không đúng tạo nên open redirector. Open redirection là một endpoint sử dụng các tham số và chuyển hướng tự động tới các vị trí được xác định trong các tham số mà không kiểm tra trước. Open redirection có thể được sử dụng trong tấn công phishing, hoặc bởi kẻ tấn công để khiến người dùng truy cập vào các trang web nguy hiểm bằng cách sử dụng redirection URI. Ngoài ra nếu server ủy quyền cho phép client đăng ký 1 phần của redirection URI, kẻ tấn công có thể sử dụng open redirector để tạo ra các URI qua mặt được việc kiểm tra của server ủy quyền và server sẽ gửi authorization code hoặc access token tới redirection URI do kẻ tấn công quản lý.  10.16 isuse of Access Token to Impersonate Resource Owner in Implicit Flow  Đối với implicit thì không thể biết được access token đang được cấp phát cho client nào. resource owner có thể cấp quyền cho client của kẻ tấn công. Kẻ tấn công cũng có thể lấy trộm token thông qua một số cơ chế khác. Sau đó kẻ tấn công có thể giả mạo resource owner bằng cách cung cấp access token cho client hợp lệ. Kẻ tấn công cũng có thể thay thế access token mà server ủy quyền trả về bằng access token được cấp cho hắn trước đó.  \u0026mdash;- CÁC PHẦN CÒN LẠI KHÔNG DỊCH\u0026mdash;-\n","date":"21","image":null,"permalink":"https://bluzky.github.io/blog/2018-01-21-tim-hieu-oauth/","tags":["others","protocol","oauth2"],"title":"Tìm hiểu về Oauth / Oauth hoạt động như thế nào?"},{"categories":null,"contents":"1. What is Rabbit MQ?  Rabbit MQ is an server application, it is a message broker which implement AMQP (Advanced Message Queue Protocol). It works like a post service, which take the message from sender and dispatch that message to the receiver.\n Some terminologies:\n Producer: send message to queue Queue: hold all message added by producer and dispatch those message to a consumer Consumer: receive message from  2. What is Rabbit MQ used for? RabbitMQ is a message broker server that receive and dispatch/distribute messages to back end services that handle/process heavy tasks. It helps to build a big system can handle large amount of request\n3. Features list Reliability\nRabbitMQ offers a variety of features to let you trade off performance with reliability, including persistence, delivery acknowledgements, publisher confirms, and high availability.\nFlexible Routing\nMessages are routed through exchanges before arriving at queues. RabbitMQ features several built-in exchange types for typical routing logic. For more complex routing you can bind exchanges together or even write your own exchange type as a plugin.\nClustering\nSeveral RabbitMQ servers on a local network can be clustered together, forming a single logical broker.\nFederation\nFor servers that need to be more loosely and unreliably connected than clustering allows, RabbitMQ offers a federation model.\nHighly Available Queues\nQueues can be mirrored across several machines in a cluster, ensuring that even in the event of hardware failure your messages are safe.\nMulti-protocol\nRabbitMQ supports messaging over a variety of messaging protocols.\nMany Clients\nThere are RabbitMQ clients for almost any language you can think of.\nManagement UI\nRabbitMQ ships with an easy-to use management UI that allows you to monitor and control every aspect of your message broker.\nTracing\nIf your messaging system is misbehaving, RabbitMQ offers tracing support to let you find out what\u0026rsquo;s going on.\n3.Bis. Implement models 1. Supported Model   Default exchange\nMessage from Producer will be pushed directly to message queue and Consumber will receive message on the same queue. Producer and Consumer must know the name of the queue\n  Fanout exchange\nEvery message is pushed to Fanout exchange,it will be pushed to all all queues which subscribe this Exchange\n  Direct exachange\nIf a Consumer only want to filter received message, it will bind to one or many routing_key. When Exchange have new message, it will append that message to all queue which subscribe same routing_key with message. If message\u0026rsquo;s routing key does not match any subscriber, it will be discarded\n  Topic exchange\nThis type of exchange allow more complicated filter, it use pattern to filter topic. Topic string format contains many words and separate by dot [.] # to replace 0 or many words * to replace exactly one word Example:\npublish topic: kern.logs.error, security.log.warning pattern: *.*.error, kern.#\n  Headers exchange\n  2. Direct message:  Producer send message directy to message queue To send message direct to queue, set exchange name to empty string Many consumer can subcribe same queue. Message will be dispatched using FIFO rule\n Producer\n1channel.basic_publish(exchange=\u0026#39;\u0026#39;, 2\trouting_key=\u0026#39;routing_name\u0026#39;, 3 body=\u0026#39;message_content\u0026#39;) Consumer\n1channel.basic_consume(callback, # callback function to handle message 2\tqueue=\u0026#39;queue_name\u0026#39; 3 no_ack=True) mermaid.initialize({ theme: 'forest' })  graph LR; A((Producer))--Q[queue]; Q -- C((Consumer 1)); Q -- C2((Consumer 2)); Q -- C3(( ......));  3. Publish message via Exchange(publish/subcribe) Exchange: acts like an agent, it receives messages from Producer and pushes them to appropriate queue. The idea of exchange is to separate Producer from queues. Producers do not need to know about queues, it simply sends message to exchange, and Exchanges will know how/ which queue to append message to or discard them.\n Routing key comes with publish and subscribe. Instead of knowing name of queue, producer now only need know routing key, it sends messages to Exchange with routing key. Each time Exchange receives a message, it will check message\u0026rsquo;s routing key and push that message to all Consumer which subscribe that routing key.\n mermaid.initialize({ theme: 'forest' })  graph LR; P1((P1))--E(Exchange); P2((P2))--E; E--|Black|Q1[Queue1]; E--|Green|Q2[Queue2]; E--|Blue|Q2[Queue2]; Q1--C1((C1)); Q2--C2((C2));  Producer\n1# firs we need to declare an exchange 2# four types of exchange: fanout, headers, topic, direct 3channel.exchange_declare(exchange=\u0026#39;exchange_name\u0026#39;, 4\ttype=\u0026#39;exchange_type\u0026#39;) 5.... 6channel.basic_publish(exchange=\u0026#39;exchange_name\u0026#39;, 7\trouting_key=\u0026#39;channel_name\u0026#39;, 8 body=\u0026#39;message_content\u0026#39;) 9.... Consumer\n1channel.exchange_declare(exchange=\u0026#39;exchange_name\u0026#39;, 2\ttype=\u0026#39;exchange_type\u0026#39;) 3.... 4# need to bind queue to a specific exchange 5channel.queue_bind(exchange=\u0026#39;exchange_name\u0026#39;, 6\tqueue=\u0026#39;queue_name\u0026#39;) 7.... 8channel.basic_consume(callback, 9\tqueue=\u0026#39;queue_name\u0026#39;, 10 no_ack=True)  RPC\n Client send request to Server, Method is defined at server and Client should know exactly which function server has. Client push request to a queue and server subscribe this queue Server push result to another queue and clien subscribe this queue\n mermaid.initialize({ theme: 'forest' })  graph LR C((Client))--Q1[request queue] Q1-- S((Server)) Q2[result queue] --C S-- Q2 style C fill:orange style S fill:pink    ##4. Use case\n Sound cloud  ##5. References\n Install instruction Tutorial page ==AMQP concept== ##6. Conclusion  ","date":"21","image":null,"permalink":"https://bluzky.github.io/blog/2018-01-21-what-is-rabbit-mq/","tags":["others","tech"],"title":"What is Rabbit MQ?"}]