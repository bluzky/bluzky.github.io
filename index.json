[{"categories":null,"contents":"The story At our company, OnPoint, we are building an ecommerce website using Phoenix Framework. And I am working on admin to manage product, orders \u0026hellip; All the listing pages need a filter and this filter change frequently, operation team wants to add this field, order by that field. And each time they change their requirements I have to update query code.\nMy team use Django Admin before, they support an easy way to compose query directly from the URL. You don\u0026rsquo;t have to change code on the back-end. It\u0026rsquo;ll be great if I can do it with Phoenix.\nWhat it should have:\n Support basic query operator: \u0026gt;, \u0026gt;=, \u0026lt;, \u0026lt;=, =, !=, like, ilike, in Query join table Can sort result  This is the result after some night of work:\nhttps://github.com/bluzky/querie\nHow it work  I define a simple rule for passing parameter from client side. The key must follow format [column]__[operator]=[value]. On the server side, it is parsed to {operator, {column, value}} with appropriate data type Then it is passed to a filter function to build Ecto query dynamically  You can try with example project to see how it works.\nHow to use it 1. Define a filter schema For example you have a Post schema:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  defmodule Example.Content.Post do use Ecto.Schema import Ecto.Changeset def state_enum(), do: ~w(draft published archived trash) schema \u0026#34;posts\u0026#34; do field(:content, :string) field(:state, :string, default: \u0026#34;draft\u0026#34;) field(:title, :string) field(:view_count, :integer, default: 0) belongs_to(:category, Example.PostMeta.Category) belongs_to(:author, Example.Account.User) end end   And you want to filter the Post by title, state, view_count. This is the filter schema:\n1 2 3 4 5  @schema %{ title: :string, state: :string, # short form view_count: [type: :integer] # long form }   2. Parse request parameters and build the query Use Querie.parse/2 to parse request parameters with your schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  alias Example.Content.Post def index(conn, params) do with {:ok, filter} \u0026lt;- Querie.parse(@schema, params) do query = Querie.filter(Post, filter) # Or you can pass a query like this # query = from(p in Post, where: ....) # query = Querie.filter(query, filter) posts = Repo.all(query) # do the rendering here else {:error, errors} -\u0026gt; IO.puts(inspect(errors) # or do anything with error # error is a list of tuple {field, message} end end   3. Compose URL Then from client side you can send a form:\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;form action=\u0026#34;/posts\u0026#34;\u0026gt; \u0026lt;label\u0026gt;Titlte\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;title__icontains\u0026#34;\u0026gt; \u0026lt;label\u0026gt;State\u0026lt;/label\u0026gt; \u0026lt;select name=\u0026#34;state\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;draft\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;published\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;trashed\u0026#34;\u0026gt;\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;label\u0026gt;View count greater than\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;number\u0026#34; name=\u0026#34;view_count__ge\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;   Or directly from URL with data like this:\nhttp://localhost:4000/posts?title__icontains=elixir\u0026amp;state=published\u0026amp;view_count__ge=100 Enter and see the result\nQuery joined table It quite simple to filter result with filter on joined tables.\n1. Update your query Querie support ref operator to join tables. For example you want to query Post by author whose email contains sam the query would be:\n?author__ref[email__icontains]=sam 2. Update your schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14  alias Example.Account.User @schema %{ title: :string, state: :string, view_count: [type: :integer], author: [ type: :ref, # this references to another schema model: User, # which schema to query schema: %{ # define filter schema for User email: :string } ] }   For more query options, please read document\nIf you have any suggestion, please leave a comment or open an issuse on Github.\nThanks for reading.\n","date":"30","image":"/img/request-to-query.png","permalink":"https://bluzky.github.io/blog/2020-10-30-compose-ecto-query-from-client/","tags":["elixir","phoenix","query","ecto","querie"],"title":"Compose Ecto Query From Client"},{"categories":null,"contents":"Yêu cầu chuẩn hoá và validate các tham số truyền lên từ client là yêu cầu cơ bản khi xây dựng API Web. Mình đã có một bài hướng dẫn sử dụng Ecto.Changeset để chuẩn hoá trong bài viết này:\nParse và validate request param trong Phoenix với Ecto \nTrong bài viết này, mình sẽ hướng dẫn một cách ngắn và đơn giản hơn bằng cách sử dụng thư viện sẵn có Tarams. Thư viện này thực ra là sử dụng lại Ecto.Changeset nhưng nó giúp cho chúng ta không phải lặp lại quá nhiều code như khi dùng Ecto.Changeset\nMột vài tính năng thú vị của Tarams:\n Cung cấp cách thức đơn giản để định nghĩa các cấu trúc tham số Cho phép định nghĩa các giá trị default động Cho phép định nghĩa các hàm để cast giá trị về đúng kiểu dữ liệu Định nghĩa hàm để validate dữ liệu  Sau đây là cách sử dụng Tarams. Ví dụ chúng ta đang viết API để cập nhật profile của nhân viên. Yêu cầu là\nemail: bắt buộc, đúng định dạng first_name: bắt buộc last_name: bắt buộc birthday: không bắt buộc, kiểu ngày tháng title: không bắt buộc start_date: ngày bắt đầu làm việc, ngày tháng, mặc định là ngày hiện tại 1. Định nghĩa cấu trúc của tham số truyền lên khá đơn giản 1 2 3 4 5 6 7 8  @schema %{ email: [type: :string], first_name: [type: :string], last_name: [type: :string], title: :string, birth_day: [type: :date], start_date: [type: :date] }   Schema đơn giản chỉ là một map với key là tên field và value là 1 list option của field đó.\n2. Bây giờ thêm các ràng buộc  Để đánh dấu 1 trường là bắt buộc, thêm option required: true Taram cũng cho phép validate data sử dụng lại các hàm validate của Changeset  1 2 3 4 5 6 7 8  @schema %{ email: [type: :string, required: true, validate: {:format, ~r/@/}], first_name: [type: :string, required: true], last_name: [type: :string, required: true], title: :string, birth_day: [type: :date], start_date: [type: :date] }   3. Bây giờ thì set các giá trị default default có thể là 1 giá trị hoặc 1 hàm. Mỗi khi parse tham số thì hàm này sẽ được gọi để lấy giá trị mặc định\n1 2 3 4 5 6  @schema %{ ... title: [type: :string, default: \u0026#34;staff\u0026#34;], birth_day: [type: :date], start_date: [type: :date, default: \u0026amp;Timex.today/0] }   4. Cast các giá trị tham số về đúng kiểu Nhiều các giá trị tham số truyền lên phải được chuyển về đúng các loại dữ liệu phức tạp như ngày tháng, list. Ví dụ ngày tháng truyền lên là string 01/12/1994 thì phải chuyển về kiểu date để sử dụng lại được. Tarams hỗ trợ định nghĩa 1 hàm custom để cast giá trị, hàm này trả về\n {:ok, value} nếu parse thành công {:error, error_message} nếu thất bại  1 2 3 4 5 6 7 8 9 10  def parse_date(date_str) do Timex.parse(date_str, \u0026#34;{0D}/{0M}/{YYYY}\u0026#34;) end @schema %{ ... title: [type: :string, default: \u0026#34;staff\u0026#34;], birth_day: [type: :date, cast_func: \u0026amp;parse_date/1], start_date: [type: :date, default: \u0026amp;Timex.today/0] }   5. Bây giờ sử dụng nào 1 2 3 4 5 6 7 8  def update(conn, params) do with {:ok, user_data} \u0026lt;- Tarams.parse(@schema, params) do # do anything with your params # access data bằng atom key: user_data.email else {:error, changset} -\u0026gt; # return params error end end   Hàm parse sẽ parse và validate dữ liệu. Nếu mọi thứ đều ổn, sẽ trả về {:ok, data} và ngược lại thì trả về {:error, changeset}.\nDone! Code của bạn sẽ trở nên đơn giản và ngắn gọn hơn nhiều\n","date":"01","image":"/img/tarams-parse.png","permalink":"https://bluzky.github.io/blog/2020-10-01parse-validate-data-with-tarams/","tags":["elixir","ecto","phoenix","tarams"],"title":"Chuẩn hoá và validate dữ liệu trong Phoenix với thư viện Tarams"},{"categories":null,"contents":"Khi viết các API hoặc cả các endpoint thì thông thường chúng ta sẽ có một số nhu cầu:\n Chỉ cho phép một số các tham số xác định được truyền vào. Chuyển các tham số về kiểu dữ liệu mong muốn Validate các tham số theo yêu cầu  Bài viết này sẽ hướng dẫn các bạn giải quyết các vấn đề trên sử dụng Ecto.Changeset\nThư viện Ecto đã cung cấp sẵn cho chúng ta module Changeset. Nó hỗ trợ việc cast các tham số về đúng kiểu dữ liệu mong muốn, nó cũng hỗ trợ các phương thức để validate các tham số yêu cầu, và nó cũng cho phép bạn giới hạn tham số nào được truyền vào.\nVà sau đây là một ví dụ sử dụng Chageset để validate các tham số khi filter các đơn hàng.\n1. Đầu tiên bạn phải định nghĩa một schema 1 2 3 4 5 6 7 8 9 10 11 12  defmodule MyApp.OrderFilterParams do use Ecto.Schema import Ecto.Changeset schema \u0026#34;order_filter_params\u0026#34; do field :keyword, :string field :category_id, :integer field :status, :string field :start_date, :utc_datetime field :end_date, :utc_datetime end end   2. Cast và validate Sau đó phải định nghĩa một hàm để thực hiện việc cast tham số và validate changeset.\n1 2 3 4 5 6 7 8 9 10 11 12  defmodule MyApp.OrderFilterParams do ... @required ~w(category_id start_date) @optional ~w(keyword status end_date) def changeset(changeset_or_model, params) do cast(changeset_or_model, params, @required ++ @optional) |\u0026gt; validate_required(@required) end end   3. Set giá trị default động Nếu bạn muốn sử dụng các giá trị default động, ví dụ như mặc định ngày kết thúc là ngày hiện tại, các bạn phải định nghĩa một function để set giá trị mong muốn.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  defmodule MyApp.OrderFilterParams do ... def changeset(changeset_or_model, params) do cast(changeset_or_model, params, @required ++ @optional) |\u0026gt; validate_required(@required) |\u0026gt; set_default_end_date() end defp set_defaut_end_date(changeset) do end_date = get_change(changeset, :end_date) if is_nil(end_date) do put_change(changeset, :end_date, Timex.today()) else changeset end end end   4. Sử dụng Params schema 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  defmodule MyApp.OrderController do use MyApp, :controller alias MyApp.OrderFilterParams def index(conn, params) do changeset = OrderFilterParams.changeset(%OrderFilterParams{}, params) if changeset.valid? do strong_params = Ecto.Changeset.apply_changes(changeset) IO.put(strong_params.keyword) # Do something with your params else # handle error end end end   Rất đơn giản đúng không, nếu bạn đã sử dụng Ecto thì việc này chỉ là ruồi muỗi. Tuy nhiên đơn giản thì phải có thứ đánh đổi chứ.\nVài thứ mà bạn sẽ thấy bất tiện 1. Lượng code mà bạn phải viết quá nhiều. Thử tưởng tượng mỗi API bạn lại phải định nghĩa thêm một Module params cho nó thì phức tạp vl.\nBạn có thể sử dụng schemaless, nhưng mà function của bạn sẽ rối nùi lên vì code logic và code xử lý params nó không liên quan gì tới nhau cả. Và bạn thì kiểu như đổ sting vào cơm để ăn vậy.\n2. Thiếu linh hoạt. Điều này cũng đúng vì mục đích chính của Ecto là phục vụ cho việc định nghĩa các schema cho database.\nĐơn giản như việc định nghĩa giá trị default động như trên, bạn phải viết luôn 1 hàm mới\nTuy nhiên nó cũng có một ưu điểm là bạn không phải sử dụng thêm thư viện của bên thứ ba.\nKết Nếu bạn không cần phải xử lý nhiều ràng buộc liên quan đến tham số của request thì đơn giản là cứ dùng Changeset thôi.\nNếu bạn muốn nhanh gọn hơn thì trên Hex có một số thư viện để hỗ trợ định nghĩa param đơn giản hơn, ví dụ như https://github.com/bluzky/tarams/\nThư viện này cung cấp cách thức đơn giản và nhanh chóng hơn để định nghĩa param cho API. Mình sẽ viết bài hướng dẫn sau.\n","date":"26","image":"/img/parse-ecto-phoenix.png","permalink":"https://bluzky.github.io/blog/validate-request-params-phoenix-ecto/","tags":["elixir","ecto","phoenix"],"title":"Parse và validate request param trong Phoenix với Ecto"},{"categories":null,"contents":" Bài viết này sẽ hướng dẫn các bạn sử dụng ETS như là bộ nhớ cache để tăng tốc các ứng dụng web Phoenix\n Dành cho các bạn chưa biết:\n ETS (Erlang Term Storage) là cơ sở dữ liệu dạng key-value lưu trữ trên RAM, tương tự như Memcache và Redis, với ưu điểm là tốc độ truy xuất cực nhanh. Đọc thêm về ETS Cache là việc lưu lại các kết quả xử lý của request vào bộ nhớ và trả về cho các request sau mà không cần phải tính toán lại -\u0026gt; giảm response time.  1. Setup project   Tạo 1 project mới\n1 2  mix phx.new phoenix_cache mix deps.get     Thêm chức năng tạo/xoá/sửa bài viết\n1 2 3  mix phx.gen.html Posts Post posts title:string summary:text content:text mix ecto.create mix ecto.migrate     Vào http://0.0.0.0:4000/posts để xem chức năng bài viết. Thêm vài bài viết để có dữ liệu test   2. Tạo một module để quản lý cache Do table trong ETS sẽ bị huỷ khi process khởi tạo table kết thúc, nên cần phải có 1 process luôn luôn chạy để table không bị xoá. Sử dụng GenServer để quản lý Cache là tiện nhất vì nó được cung cấp sẵn bởi Elixir. Đọc thêm về GenServer\n2.1 Tạo module Tạo một file mới phoenix_cache/lib/phoenix_cache/bucket.ex\n1 2 3 4 5 6 7 8 9 10 11  defmodule PhoenixCache.Bucket do use GenServer alias :ets, as: Ets # thời gian sống của 1 entry mặc định là 6 phút @expired_after 6 * 60 def start_link(args \\\\ []) do GenServer.start_link(__MODULE__, args, name: __MODULE__) end end   2.2 Khởi tạo cache table khi bắt đầu chạy GenServer 1 2 3 4  def init(state) do Ets.new(:simple_cache, [:set, :protected, :named_table, read_concurrency: true]) {:ok, state} end   Module cache sẽ hỗ trợ 3 thao tác:\n set: lưu data vào bộ nhớ cache get: lấy data từ bộ nhớ cache delete: xoá data khỏi cache (cái này có vẻ không cần lắm thì phải)  2.3 Thêm data vào cache 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def set(key, value) do GenServer.cast(__MODULE__, {:set, key, value}) end @doc \u0026#34;\u0026#34;\u0026#34; Default TTL \u0026#34;\u0026#34;\u0026#34; def handle_cast({:set, key, val}, state) do expired_at = NaiveDateTime.utc_now() |\u0026gt; NaiveDateTime.add(@expired_after, :second) Ets.insert(:simple_cache, {key, val, expired_at}) {:noreply, state} end   Ở đây chúng ta sẽ tạo tính toán thời điểm expire/hết hạn của giá trị cache, tính từ thời điểm hiện tại, sử dụng giá trị TTL(thời gian sống) mặc định là 6phút. Bạn có thể cấu hình lưu TTL mặc định vào config hoặc biến môi trường. Mình lưu vào thuộc tính module cho tiện.\n2.4 Thêm data vào cache và thiết lập thời gian sống của data Để có thể thoải mái thiết lập TTL, ta thêm 1 hàm cho phép truyền vào tham số TTL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  @doc \u0026#34;\u0026#34;\u0026#34; Custom TTL for cache entry ttl: Time to live in second \u0026#34;\u0026#34;\u0026#34; def set(key, value, ttl) do GenServer.cast(__MODULE__, {:set, key, value, ttl}) end @doc \u0026#34;\u0026#34;\u0026#34; Custom TTL \u0026#34;\u0026#34;\u0026#34; def handle_cast({:set, key, val, ttl}, state) do inserted_at = NaiveDateTime.utc_now() |\u0026gt; NaiveDateTime.add(ttl, :second) Ets.insert(:simple_cache, {key, val, inserted_at}) {:noreply, state} end   Cũng tương tự như trên nhưng hàm set sẽ nhận thêm tham số thứ 3 là TTL thay vì xài giá trị mặc định.\n2.5 Truy xuất dữ liệu từ cache Có vào thì phải có lấy ra chứ nhỉ, bây giờ ta sẽ thêm code để truy xuất data từ cache.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  def get(key) do # lấy giá trị đầu tiên tìm đuợc rs = Ets.lookup(:simple_cache, key) |\u0026gt; List.first() # Nếu không tìm thấy thì trả về lỗi if rs == nil do {:error, :not_found} else expired_at = elem(rs, 2) # So sánh thời điểm hết hạn với hiện tại, nếu hết hạn thì trả về lỗi cond do NaiveDateTime.diff(NaiveDateTime.utc_now(), expired_at) \u0026gt; 0 -\u0026gt; {:error, :expired} true -\u0026gt; {:ok, elem(rs, 1)} end end end   Note: Nhờ feedback của bác @HQC, chỗ này mình đọc trực tiếp từ table, thay vì dùng GenServer.call như trước vì khi send request vào GenServer thì code sẽ được chạy sync/đồng bộ. Do vậy sẽ tạo nên ngẽn cổ chai. Mình sửa lại ở phần tạo table thêm read_concurrency: true và đưa phần code query dữ liệu ra ngoài GenServer\n2.6 Xoá dữ liệu khỏi cache 1 2 3 4 5 6 7 8  def delete(key) do GenServer.cast(__MODULE__, {:delete, key}) end def handle_cast({:delete, key}, state) do Ets.delete(:simple_cache, key) {:noreply, state} end   2.7 Module hoàn chỉnh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  defmodule PhoenixCache.Bucket do use GenServer alias :ets, as: Ets @expired_after 6 * 60 def start_link(args \\\\ []) do GenServer.start_link(__MODULE__, args, name: __MODULE__) end def set(key, value) do GenServer.cast(__MODULE__, {:set, key, value}) end @doc \u0026#34;\u0026#34;\u0026#34; Custom TTL for cache entry ttl: Time to live in second \u0026#34;\u0026#34;\u0026#34; def set(key, value, ttl) do GenServer.cast(__MODULE__, {:set, key, value, ttl}) end def get(key) do rs = Ets.lookup(:simple_cache, key) |\u0026gt; List.first() if rs == nil do {:error, :not_found} else expired_at = elem(rs, 2) cond do NaiveDateTime.diff(NaiveDateTime.utc_now(), expired_at) \u0026gt; 0 -\u0026gt; {:error, :expired} true -\u0026gt; {:ok, elem(rs, 1)} end end end def delete(key) do GenServer.cast(__MODULE__, {:delete, key}) end # Server callbacks # Server (callbacks) @impl true def init(state) do Ets.new(:simple_cache, [:set, :protected, :named_table, read_concurrency: true]) {:ok, state} end @doc \u0026#34;\u0026#34;\u0026#34; Default TTL \u0026#34;\u0026#34;\u0026#34; def handle_cast({:set, key, val}, state) do expired_at = NaiveDateTime.utc_now() |\u0026gt; NaiveDateTime.add(@expired_after, :second) Ets.insert(:simple_cache, {key, val, expired_at}) {:noreply, state} end @doc \u0026#34;\u0026#34;\u0026#34; Custom TTL \u0026#34;\u0026#34;\u0026#34; def handle_cast({:set, key, val, ttl}, state) do inserted_at = NaiveDateTime.utc_now() |\u0026gt; NaiveDateTime.add(ttl, :second) Ets.insert(:simple_cache, {key, val, inserted_at}) {:noreply, state} end @impl true def handle_cast({:delete, key}, state) do Ets.delete(:simple_cache, key) {:noreply, state} end end   3. Setup cache Ta đã tạo xong module cache rồi, nhưng làm sao để cache tự động chạy khi chạy server?\nThêm worker vào file phoenix_cache/lib/phoenix_cache/application.ex\n1 2 3 4  children = [ ... worker(PhoenixCache.Bucket, []) ]   Khi Supervisor khởi chạy, nó sẽ start các children và quản lý chúng. Để hiểu rõ hơn, đọc thêm tại https://hexdocs.pm/elixir/Supervisor.html\n4. Xài cache Olala, ta đã tạo module cache và thiết lập để chạy cùng với server, bây giờ tới lúc xài nó rồi.\nThử dùng cache cho chức năng xem bài viết:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  def show(conn, %{\u0026#34;id\u0026#34; =\u0026gt; id}) do post = # lấy nội dung post từ cache case PhoenixCache.Bucket.get(\u0026#34;posts-#{id}\u0026#34;) do # Nếu có ròi thì khỏi cần đọc DB {:ok, post} -\u0026gt; IO.puts(\u0026#34;HIT\u0026#34;) post {:error, _} -\u0026gt; IO.puts(\u0026#34;MISS\u0026#34;) # Chưa cache thì đọc từ DB post = Posts.get_post!(id) # cache bài viết 60s PhoenixCache.Bucket.set(\u0026#34;posts-#{id}\u0026#34;, post, 60) post end render(conn, \u0026#34;show.html\u0026#34;, post: post) end   Kết quả request:\n1 2 3 4 5 6  [info] GET /posts/1 MISS ... [info] GET /posts/1 HIT ...   Lần request đầu tiên, bài viết chưa được cache nên phải truy xuất database và cache lại, lần thứ 2 thì đã có trong cache nên không cần phải đọc từ database nữa.\nỞ ví dụ này có thể bạn sẽ chưa thấy sự khác biệt lắm về tốc độ response, nhưng nếu như thay vì load 1 bài viết bằng việc xử lý thống kê dữ liệu thì sự khác biệt sẽ rất lớn.\n5. Plug cache Nếu cứ mỗi chức năng đều phải thêm code để kiểm tra cache thì sẽ lặp lại rất nhiều. Để phát huy cái sự lười biếng thì ta sẽ tạo một plug đơn giản để khỏi phải code nhiều lần.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  defmodule PhoenixCache.Plug.Cache do import Plug.Conn # 6 minute @default_ttl 6 * 60 def init(ttl \\\\ nil), do: ttl def call(conn, ttl \\\\ nil) do ttl = ttl || @default_ttl # Chỉ cache với GET request if conn.method == \u0026#34;GET\u0026#34; do # tạo key từ request path và query param, thông thường # thì cùng path và cùng param thì kết quả là giống nhau key = \u0026#34;#{conn.request_path}-#{conn.query_string}\u0026#34; case PhoenixCache.Bucket.get(key) do {:ok, body} -\u0026gt; IO.puts(\u0026#34;PLUG HIT\u0026#34;) # nếu đã cache thì trả về ngay conn |\u0026gt; send_resp(200, body) |\u0026gt; halt _ -\u0026gt; IO.puts(\u0026#34;PLUG MISS\u0026#34;) # nếu chưa cache thì xử lý như bình thường conn |\u0026gt; assign(:ttl, ttl) |\u0026gt; register_before_send(\u0026amp;cache_before_send/1) # gọi hàm này trước khi trả về end else conn end end def cache_before_send(conn) do # nếu request đuợc xử lý thành công thì cache if conn.status == 200 do key = \u0026#34;#{conn.request_path}-#{conn.query_string}\u0026#34; data = conn.resp_body PhoenixCache.Bucket.set(key, data, conn.assigns[:ttl] || @default_ttl) conn else # không thì kệ chúng mày conn end end end   Đây chỉ là một plug đơn giản, bạn có thể viết lại theo nhu cầu.\nSử dụng Plug: plug(PhoenixCache.Plug.Cache, TTL )\n1 2 3 4  pipeline :browser do ... plug(PhoenixCache.Plug.Cache, 100) # cache 100s end   6. Kết luận Vậy là bạn đã có thể sử dụng ETS như là bộ nhớ cache cho ứng dụng Phoenix của mình mà không cần phải cài thêm phần mềm/dịch vụ khác.\nHi vọng sẽ giúp ích cho các bạn\nSource code project https://github.com/bluzky/phoenix_ets_cache_example\n","date":"18","image":null,"permalink":"https://bluzky.github.io/blog/2018-05-17-ets-as-cache-phoenix/","tags":["elixir","phoenix","ETS"],"title":"Sử dụng ETS để tăng tốc ứng dụng với Phoenix"},{"categories":null,"contents":"ETS là gì? Có lẽ các bạn đã nghe qua về redis hoặc memcache, hoặc là cả hai. Còn nếu bạn chưa nghe tới bao giờ thì đó là những cơ sở dữ liệu lưu trữ trên RAM với ưu điểm là tốc độ truy xuất cực kỳ nhanh. ETS - Erlang Term Service - cũng là một CSDL lưu trữ trên RAM (in-ram DB) nhưng khác ở chỗ là ETS có sẵn khi cài Elixir/Erlang và bạn chẳng phải mất công cài đặt, cấu hình như 2 anh trên kia, nhà trồng được việc gì phải ngại.\nĐặc điểm của em nó là:\n Không cần cài đặt Dữ liệu lưu trữ trên RAM và mất đi khi process kết thúc Dữ liệu lưu trữ dạng key-value value có thể là set, ordered_set, bag, duplicated_bag Kiểu dữ liệu của value trên cùng 1 bảng là giống nhau và đuợc khai báo khi tạo bảng.  Các thao tác trong ETS 1. Tạo bảng 1  iex\u0026gt; :ets.new(:cache, [:set, :protected, :named_table])   **Syntax: ** :ets.new(ten_bang, [type, access, name_table])\n type là kiểu dữ liệu của value lưu trong bảng  set là kiểu dữ liệu, chú này chung thuỷ chỉ có 1 value cho 1 key và key là duy nhất, không bị trùng. ordered_set thằng em nghiêm túc của set, khác thằng anh ở chỗ đuợc tự động order khi thêm data vào. bag khác với set ở chỗ chú này chơi harem, cho phép nhiều value cho cùng 1 key, tuy nhiên các value không đuợc trùng nhau. duplicated_bag thằng này ăn tạp giống bag nhưng cho phép value trùng nhau   access giới hạn khả năng truy xuất dữ liệu từ bảng, cũng khá dễ nhớ  public: hàng công cộng, chú process nào thích nhìn (đọc), sờ (ghi) gì anh cho hết protected: các chú chỉ đuợc nhìn thôi, anh sở hữu thì anh đuợc sờ private: anh giấu hết, chỉ có anh mới đuợc nhìn và sờ, các chú đi ra chỗ khác   named_table Cái này tuỳ chọn, bình thuờng thì sẽ trả về 1 id dùng để truy xuất vào table. Nếu thêm option này vào thì có thể dùng ten_bang để truy xuất vào table.  Đã xong phần khởi tạo, giờ phần hay ho nhất đây.\n2. Insert và update dữ liệu   Insert dữ liệu nếu key đã có chủ thì ghi đè (đập chậu cuớp bông)\n1 2  iex\u0026gt; :ets.insert(:cache, {\u0026#34;post-1\u0026#34;, \u0026#34;world!\u0026#34;, %{view: 1}}) true      Insert dữ liệu, nếu key đã có chủ thì bỏ qua.\n1 2 3 4  iex\u0026gt; :ets.insert_new(:cache, {\u0026#34;post-1\u0026#34;, \u0026#34;Lao!\u0026#34;, %{view: 2}}) false iex\u0026gt; :ets.insert_new(:cache, {\u0026#34;post-2\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 999}}) true      Dữ liệu cho hàm insert/2 và insert_new/2 là 1 tuple, phần tử đầu tiên của tuple mặc định được dùng làm key.\n3. Query dữ liệu 3.1 Query đơn giản: tìm kiếm dữ liệu theo key dùng hàm lookup/2\n1 2  iex\u0026gt; :ets.lookup(:cache, \u0026#34;post-1\u0026#34;) [{\u0026#34;post-1\u0026#34;, \u0026#34;world!\u0026#34;, %{view: 1}}]   3.2 Query với nhiều trường dữ liệu với hàm match_object/2\n1 2  iex\u0026gt; :ets.match_object(:cache, {:\u0026#34;_\u0026#34;, \u0026#34;Vietnam!\u0026#34;, :\u0026#34;_\u0026#34;}) [{\u0026#34;post-2\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 999}}]    Note :\u0026quot;_\u0026quot; đánh dấu tại vị trí này sẽ không xài để match dữ liệu, truờng này chứa dữ liệu gì cũng đuợc, anh không quan tâm  3.3 Select trường dữ liệu nào sẽ trả về với match/2\n1 2  iex\u0026gt; :ets.match_object(:cache, {:\u0026#34;$1\u0026#34;, :\u0026#34;$2\u0026#34;, :\u0026#34;_\u0026#34;}) [{\u0026#34;post-1\u0026#34;, \u0026#34;world!\u0026#34;}, {\u0026#34;post-2\u0026#34;, \u0026#34;Vietnam!\u0026#34;}]    Note :\u0026quot;$N\u0026quot; dùng để select kết quả trả về, N là một số nguyên dùng để xác định vị trí của dữ liệu trong kết quả.  1 2  iex\u0026gt; :ets.match_object(:cache, {:\u0026#34;$30\u0026#34;, :\u0026#34;$2\u0026#34;, :\u0026#34;_\u0026#34;}) [{\u0026#34;world!\u0026#34;, \u0026#34;post-1\u0026#34;}, {\u0026#34;Vietnam!\u0026#34;, \u0026#34;post-2\u0026#34;}]   3.4 Giới hạn kết quả tra về\nSử dụng hàm match/3 hoặc match_object/3 tương tự như match/2 và match_object/2, trong đó tham số thứ 3 là số lượng phần tử sẽ trả về.\n1 2 3 4 5 6 7 8 9 10 11  # them 1 phan tu iex\u0026gt; :ets.insert_new(:cache, {\u0026#34;post-3\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 1000}}) true # khong limit iex\u0026gt; :ets.match_object(:cache, {:\u0026#34;_\u0026#34;, \u0026#34;Vietnam!\u0026#34;, :\u0026#34;_\u0026#34;}) [{\u0026#34;post-2\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 999}}, {\u0026#34;post-3\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 1000}}] # co limit iex\u0026gt; :ets.match_object(:cache, {:\u0026#34;_\u0026#34;, \u0026#34;Vietnam!\u0026#34;, :\u0026#34;_\u0026#34;}, 1) [{\u0026#34;post-2\u0026#34;, \u0026#34;Vietnam!\u0026#34;, %{view: 999}}]   4. Xoá dữ liệu Xoá theo key\n1 2  iex\u0026gt; :ets.delete(:cache, \u0026#34;post-1\u0026#34;) true   Match dữ liệu và xoá. Cách match giống như trong query dữ liệu\n1 2  iex\u0026gt; :ets.match_delete(:cache, {:\u0026#34;_\u0026#34;, \u0026#34;Vietnam!\u0026#34;, :\u0026#34;_\u0026#34;}) true   5. Xoá bảng 1 2  iex\u0026gt; :ets.delete(:cache) true   Nếu không xoá thì dữ liệu sẽ tồn tại cho đến khi process kết thúc mới bị mất đi.\n6. Các hàm hay xài  member/2 kiểm tra xem key đã tồn taị trong bảng hay chưa tab2list: đọc tất cả dữ liệu của bảng vào 1 list tab2file: lưu tất cả dữ liệu trên bảng vào 1 file, bạn có thể lưu dữ liệu lại truớc khi process kết thúc và có thể xài lại dữ liệu sau. file2tab : đọc 1 file đuợc lưu bởi tab2file và tạo lại bảng tương ứng to_dest/2: copy toàn bộ dữ liệu từ bảng ETS qua bảng DETS (lưu dữ liệu trên ổ cứng) from_dest/2: copy toàn bộ dữ liệu từ bảng DETS qua bảng ETS  Tham khảo  http://erlang.org/doc/man/ets.html xem nhiều trò hay http://learnyousomeerlang.com/ets Ngoài ra Erlang còn hỗ trợ DETS (disk-based term storage) lưu trên ổ cứng với API tương tự http://erlang.org/doc/man/dets.html  ","date":"12","image":null,"permalink":"https://bluzky.github.io/blog/2018-05-12-erlang-term-storage/","tags":["elixir","erlang"],"title":"Elixir - Lưu trữ dữ liệu trên RAM với ETS"},{"categories":null,"contents":"Trong quá trình tìm hiểu về lập trình chat bot sử dụng các API của Facebook Messenger thì việt test chat bot trên localhost là một trở ngại.\nKhi tạo một subscription cho app chat bot, Facebook sẽ gửi một request đến server mà chat bot đang chạy để xác nhận có đúng là chat bot của bạn không. Cũng như sau đó, tất cả những tin nhắn của nguời dùng sẽ đuợc gửi tới chat bot thông qua callback url. Và vấn đề là khi dev và test trên localhost thì làm sao để server local của bạn có thể nhận và phản hồi request của Facebook.\nMột giải pháp đơn giản là sử dụng dịch vụ của https://ngrok.com để chuyển các request về máy localhost. ngrok.com cung cấp gói miễn phí test vô tư, hơn nữa ngrok hỗ trợ cả https. Điều này rất quan trọng, bởi vì từ 2018 thì tất cả các callback url khi đăng ký ứng dụng trên Facebook Developer đều phải sử dụng kết nối TLS.\nBuớc 1: Đăng ký tài khoản  Đăng ký tại https://ngrok.com/pricing Vì là tài khoản miễn phí nên sẽ có một số giới hạn: 40 kết nối / phút Mỗi lần chỉ chạy được 1 ngrok process  Bước 2: Download ngrok và cấu hình API key  Download tại https://ngrok.com/download Giải nén file vừa Download bạn sẽ có file ngrok Thêm token vào ngrok config bằng lệnh  1  $ ./ngrok authtoken \u0026lt;YOUR_AUTH_TOKEN\u0026gt;   Bạn có thể copy command trên từ Dashboard trong phần Connect your account\nBước 3: Khởi chạy ngrok process Chạy lệnh\n1  ./ngrok http \u0026lt;PORT\u0026gt;   trong đó PORT là port number của server localhost mà bạn muốn test.\nOuput mẫu của ngrok\nngrok cung cấp cho bạn 2 public URL để kết nối vào server localhost. 1 URL với giao thức http và 1 URL với https. Ngon không nào!\nBây giờ bạn đã có thể cấu hình Facebook để test trên localhost rồi.\nLưu ý:\nKhi sử dụng tài khoản Free, mỗi lần chạy ngrok thì forwarding URL sẽ khác nhau nên sẽ phải sửa lại sửa lại cấu hình app trên Facebook Developer. Đồ chùa thường là đồ chua mà. Khi sử dụng gói có phí bạn có thể cấu hình forwarding URL theo ý mình. Mình nghèo nên chịu khó thôi.\n","date":"08","image":null,"permalink":"https://bluzky.github.io/blog/2018-05-08-test-fb-bot-localhost/","tags":["tech","til"],"title":"Cấu hình kết nối HTTPS để test Facebook app trên localhost"},{"categories":null,"contents":" Từ tháng 04/2018 tất cả các app mới tạo trên Facebook chỉ chấp nhận callback url có sử dụng SSL. Đây là những bước đơn giản để có thể sử dụng giao thức https trên localhost đối với Phoenix\n 1. Tạo chứng chỉ\nRun command\n1 2  openssl genrsa 1024 \u0026gt; app.key \u0026amp;\u0026amp; openssl req -new -x509 -nodes -sha1 -days 365 -key ~/app.key \u0026gt; ~/app.cert   2. Copy file\napp.key and app.cert file to priv/keys\n3. Chỉnh sửa cấu hình\nfile dev.exs\n1 2 3  config :my_app, MyAppWeb.Endpoint, http: [port: 4000], https: [port: 4443, keyfile: \u0026#34;priv/keys/app.key\u0026#34;, certfile: \u0026#34;priv/keys/app.cert\u0026#34;],   Access https://localhost:4443 to use SSL connection\n","date":"02","image":null,"permalink":"https://bluzky.github.io/blog/2018-05-02-phoenix-local-ssl/","tags":["elixir","til"],"title":"Chạy server Phoenix với SSL trên localhost"},{"categories":null,"contents":"1. Memcache  Memcache là một cơ sở dữ liệu dạng key-value, các dữ liệu đuợc ghi nhớ trên RAM giúp tối ưu thời gian truy xuất.\n 2. Đặc điểm  Dữ liệu lưu trữ dạng key-value Value là dữ liệu dạng string Kích thuớc của Value giới hạn là 1MB Dữ liệu sẽ bị mất khi tắt máy/ tắt memcache Truy xuất dữ liệu nhanh  3. Ứng dụng Memcache thường đuợc dùng đễ cache dữ liệu trên các web server giúp giảm thời gian xử lý các request giống nhau, thay vào đó chỉ cần đọc dữ liệu từ bộ nhớ và trả về ngay lập tức.\n4. Ưu - Nhược điểm Ưu điểm\n Dữ liệu truy xuất nhanh Sử dụng phổ biến  Nhược điểm\n Khi dữ liệu bị xoá, dữ liệu không đuợc phục hồi Chỉ hỗ trợ dữ liệu kiểu string Kích thước dữ liệu giới hạn chỉ 1MB Không hỗ trợ lưu dữ liệu persistent  5. Cách sử dụng Ví dụ sử dụng trong Elixir:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  def get_post(conn, %{\u0026#34;id\u0026#34; =\u0026gt; id}) do response = Memcache.Client.get(\u0026#34;post-#{id}\u0026#34;) case response.status do :ok -\u0026gt; # trả về ngay nếu tìm thấy trong cache json(conn, Poison.decode!(response.value)) status -\u0026gt; # Nếu không thấy, truy xuất dữ liệu mới data = get_post_data(id) # Lưu dữ liệu mới vào cache json_data = Poison.encode!(data) Memcache.Client.set(\u0026#34;post-#{id}\u0026#34;, json_data) json(conn, data) end end   6. Refs  Trang chủ memcached.org So sánh Memcache và Redis trên Stack overflow  ","date":"01","image":null,"permalink":"https://bluzky.github.io/blog/2018-05-01-what-is-mem-cache/","tags":["tech","til"],"title":"Memcache là gì?"},{"categories":null,"contents":"Khi chuyển qua dùng các hệ điều hành Unix và Mac, việc sử dụng các command line là một phần không thể thiếu, đặc biệt là các công việc liên quan tới Web dev và devops.\nTuy nhiên phần lớn là đụng tới đâu cần thì mới search, hoặc là do xài quen rồi nên cũng lười tìm cách làm khác. Chỉ cần dành 1 phút để đọc qua bài viết này, các bạn sẽ thực sự bất ngờ vì có những thứ cool đến không ngờ.\nNguồn dwmkerr.com\n","date":"24","image":null,"permalink":"https://bluzky.github.io/blog/2018-04-24-terminal-tips/","tags":["tips","til","terminal"],"title":"Terminal tips - Một số command hay dùng"},{"categories":null,"contents":"1. Tìm hiểu về FSM  FSM(Finite state machine) - Máy trạng thái hữu hạn là một mô hình toán học biểu diễn trạng thái của hệ, trong đó số trạng thái là hữu hạn. Từ mỗi trạng thái, máy có thể chuyển đổi qua 1 số trạng thái cố định khác, dựa trên các sự kiện, input.\n Fsm được biểu diễn như 1 đồ thị có hướng.\nVí dụ:\nMáy trạng thái thể hiện trạng thái của 1 bài báo trên trang tin tức\n draft, in review published là các trạng thái của bài viết review, approve, reject, unpublish là các sự kiện( event ). Các sự kiện này phát sinh khi nhận các input như click lên button, … Các sự kiện này gây ra việc chuyển trạng thái (ví dụ từ Draft -\u0026gt; In review), gọi là quá trình chuyển đổi (transition)  Đặc điểm\nTrong mô hình sử dụng DFS máy trạng thái đơn định.\n Tại mỗi thời điểm máy chỉ ở 1 trạng thái duy nhất Tại mỗi trạng thái, chỉ có thể chuyển qua những trạng thái được cho phép Từ trạng thái hiện tại, có thể biết được những trạng thái kế tiếp mà máy có thể chuyển qua  2. Ứng dụng của FSM trong lập trình   FSM mô tả các trạng thái, sự kiện và quá trình chuyển đổi giữa các trạng thái, nên FSM có thể được sử dụng để quản lý trạng thái của object, hoặc workflow.\n  Ví dụ: Quản lý trạng thái đơn hàng, quản lý trạng thái của ticket, quản lý trạng thái của nhân vật trong game, \u0026hellip;\n​\nTrong ví dụ trên, mỗi bài viết, chỉ có thể có một trạng thái tại một thời điểm, và từ 1 trạng thái chỉ có thể chuyển đổi qua một số trạng thái được quy định trước:\n Từ draft chỉ có thể chuyển qua in review Từ draft không thể chuyển qua published    2.1 Khi không dùng FSM Khi không sử dụng FSM thì code sẽ phải dùng tới rất nhiều điều kiện if … else… hoặc case (switch ... case … trong các ngôn ngữ khác)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  defmodule Post do defstruct content: \u0026#34;sample content\u0026#34;, status: \u0026#34;draft\u0026#34; def all_status, do: [\u0026#34;draft\u0026#34;, \u0026#34;in_review\u0026#34;, \u0026#34;published\u0026#34;] def update_status(%{status: \u0026#34;draft\u0026#34;} = post, status) do if status == \u0026#34;in_review\u0026#34; do IO.put(\u0026#34;Update post status to in_review\u0026#34;) Map.put(post, :status, \u0026#34;in_review\u0026#34;) else IO.put(\u0026#34;Cannot update to #{status}from draft\u0026#34;) post end end def update_status(%{status: \u0026#34;in_review\u0026#34;} = post, status) do case status do \u0026#34;draft\u0026#34; -\u0026gt; IO.put(\u0026#34;Reject the post\u0026#34;) Map.put(post, :status, \u0026#34;draft\u0026#34;) \u0026#34;published\u0026#34; IO.put(\u0026#34;Publish the post\u0026#34;) Map.put(post, :status, \u0026#34;published\u0026#34;) true -\u0026gt; IO.put(\u0026#34;Cannot update to #{status}from in_review\u0026#34;) post end end def update_status(%{status: \u0026#34;published\u0026#34;} = post, status) do if status == \u0026#34;draft\u0026#34; do IO.put(\u0026#34;Unpublish the post\u0026#34;) Map.put(post, :status, \u0026#34;draft\u0026#34;) else IO.put(\u0026#34;Cannot update to #{status}from published\u0026#34;) post end end end   **Vấn đề: **\n  Code dài, khó mở rộng, dễ xảy ra lỗi\n  Nếu thêm nhiều trạng thái khác cho post, phải update toàn bộ các hàm update_status\n  Nếu có nhiều cách chuyển đổi giữa các trạng thái, phải update toàn bộ\n  Làm sao biết từ trạng thái hiện tại có thể chuyển qua trạng thái nào khác?\n  Làm sao đảm bảo luồng dữ liệu/ logic chạy đúng\n  2.2 Sử dụng FSM Trong ví dụ này sử dụng thư viện as_fsm hỗ trợ việc implement máy trạng thái trên ngôn ngữ elixir\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  defmodule Post do # define state, event and transition  use AsFsm, states: [:draft, :in_review, :published], events: [ review: [ name: \u0026#34;In review\u0026#34;, from: [:draft], to: :in_review, on_transition: fn(post, params) -\u0026gt; # thực ra việc gán trạng thái mới được tự động thực hiện bởi thư viện # code này chỉ để mục đích cho dễ hiểu post = Map.put(post, :status, :in_review) {:ok, post} end ], approve: [ name: \u0026#34;Approve\u0026#34;, from: [:in_review], to: :published on_transition: fn(post, params) -\u0026gt; post = Map.put(post, :status, :published) {:ok, post} end ], reject: [ name: \u0026#34;Reject\u0026#34;, from: [:in_review], to: :draft, on_transition: fn(post, params) -\u0026gt; post = Map.put(post, :status, :draft) {:ok, post} end ], unpublish: [ name: \u0026#34;Unpublish\u0026#34;, from: [:published], to: :draft, on_transition: fn(post, params) -\u0026gt; post = Map.put(post, :status, :draft) {:ok, post} end ] ] defstruct content: \u0026#34;sample content\u0026#34;, status: \u0026#34;draft\u0026#34; end # gọi thực hiện  iex \u0026gt; post = %Post{content: \u0026#34;test content\u0026#34;, status: \u0026#34;draft\u0026#34;} iex \u0026gt; post = Post.review(post) # hoac iex \u0026gt; post = Post.trigger(post, :review)    Việc implement FSM cũng không quá phức tạp nhưng có thể tái sử dụng được nhiều lần Việc thêm mới các trạng thái (state) hoặc các bước chuyển tiếp (transition) không cần thay đổi quá nhiều code các luồng xử lý, event được thể hiện rõ trên cấu hình trạng thái  3. Tham khảo   Học thêm về FSM trên Brilliant\n  Finite-state machine in web-development\n  Thư viện FSM cho ecto model ecto_state_machine\n  Slide State Machine Workflow: Esoteric Techniques \u0026amp; Patterns\n​\n  ","date":"13","image":null,"permalink":"https://bluzky.github.io/blog/2018-04-13-finite-state-machine-web-development/","tags":["elixir","tech"],"title":"Finite state machine trong lập trình"},{"categories":null,"contents":" Từ cơn sốt tiền ảo, công nghệ Blockchain được tung hô và được xem như là công nghệ sẽ làm thay đổi tương lại, thậm chí đến cả công ty thực phẩm thêm chữ Blockchain vào tên sản phẩm cũng đủ làm giá cổ phiếu tăng mấy chục lần. Vậy Blockchain là gì và nó có thực sự là thứ sẽ làm thay đổi tương lai công nghệ? Để trả lời thắc mắc của chính mình, tôi đã dành thời gian để tìm hiểu về Blockchain. Có thể có một số sai sót không tránh khỏi. Rất mong nhận được sự góp ý.\n I. Blockchain là gì? 1. Định nghĩa Khó có thể đưa ra một định nghĩa chính xác cho Blockchain\nBlockchain là một công nghệ xác thực, xử lý và lưu trữ các giao dịch trên mạng internet dựa trên hệ thống phân tán.\nNguồn gốc tên gọi Blockchain xuất phát từ công nghệ lưu trữ dữ liệu thành các khối block, sau đó các khối này được kết nối lại với nhau thành một chuỗi chain.\n2. Cách tổ chức dữ liệu Tất cả dữ liệu trong hệ thống Blockchain sẽ được đóng gói thành các khối, các khối này liên kết với nhau tạo thành một chuỗi duy nhất và thống nhất trên toàn bộ hệ thống.\nMỗi block chứa nhiều giao dịch (transaction) khác nhau và Mỗi block có chứa mã hash của block trước nó. Mã hash được tạo ra nhờ các thuật toán phức tạp như SHA256, MD5, … giá trị của mã hash là khác nhau cho các dữ liệu khác nhau. Chỉ cần một sự thay đổi nhỏ trong dữ liệu cũng sẽ làm thay đổi giá trị của mã hash. Nhờ mã hash này mà việc thay đổi giá trị của một block sẽ khiến mã hash nó thay đổi và không còn trùng với mã hash được lưu ở block sau nó. Nhờ mã hash mà hệ thống có thể kiểm tra và loại bỏ những thông tin bị cố tình thay đổi.\nTransaction là thông tin của các giao dịch. Giao dịch ở đây không giới hạn trong chuyển tiền, transaction có thể chứa bất cứ thông tin gì như hình ảnh, âm thanh, ….\n3. Blockchain network Để hiện thực công nghệ blockchain cần có một hệ thống các máy tính kết nối với mạng internet và chạy một ứng dụng khách client.\nMỗi máy tính trong network được gọi là node. Mỗi node có thể chứa bản sao (hoặc một phần) dữ liệu của hệ thống blockchain. Điều này giúp tránh việt mất mát dữ liệu và đảm bảo an toàn cho hệ thống.\n4. Lưu trữ dữ liệu Blockchain sử dụng công nghệ lưu trữ dữ liệu gọi là sổ cái phân tán (distributed ledger). Trong đó dữ liệu sẽ được lưu trên tất cả các node trong network, mỗi node sẽ chứa bản sao của blockchain. Khi có một thay đổi trên blockchain, thay đổi này sẽ được đồng bộ hoá trong toàn bộ hệ thống. Sau 1 thời gian thì toàn bộ các node trên hệ thống sẽ đồng bộ trở lại và toàn bộ các bản sao trong hệ thống sẽ hoàn toàn giống nhau.\n5. Đặc điểm của hệ thống Blockchain  Dữ liệu một khi đã lưu trữ thì hầu như không thể sửa đổi được Luôn có thể truy vết nguồn gốc của dữ liệu qua tất cả các giao dịch trước đó Dữ liệu trên toàn bộ hệ thống thống nhất với nhau Phi tập trung: việc xác nhận và thực thi các giao dịch không cần phụ thuộc vào một bên trung gian thứ 3 cụ thể, mà được xác nhận bởi toàn bộ hệ thống. Dữ liệu được lưu trữ phân tán trên toàn bộ hệ thống Sử dụng các cơ chế đồng thuận để xác nhận giao dịch Mỗi giao dịch cần có sự tham gia của toàn bộ hệ thống  6. Ưu điểm   Ổn định : Khác với hệ thống tập trung, khi một phần dịch vụ ngưng hoạt động sẽ ảnh hưởng toàn bộ hệ thống. Khi một vài node trong hệ thống bị dừng hoặc mất mát dữ liệu, toàn bộ hệ thống vẫn hoạt động bình thường.\n  An toàn dữ liệu: Một khi dữ liệu đã được lưu vào trong hệ thống thì hầu như không thể thay đổi\n  Bảo mật: Dữ liệu không thể thay đổi, việc thêm mới dữ liệu cần có sự xác nhận và đồng thuận của toàn bộ hệ thống nên khó để giả mạo thông tin.\n  Thống nhất: Dữ liệu được lưu trữ trên các node được đồng bộ và thống nhất với nhau. Không cần trung gian/ không cần tin tưởng: Việc xác nhận các giao dịch do toàn bộ các node trong hệ thống thực hiện nên không cần phải thông qua một bên thứ 3 được tin tưởng. Ví dụ: thông thường chuyển tiền qua ngân hàng cần 2 bên tin tưởng tuyệt đối vào ngân hàng. Trong blockchain, các giao dịch được thực hiện trực tiếp\n  Giảm bớt chi phí, thời gian: Các giao dịch không cần khoản phí rất nhỏ do không phải trả cho bên trung gian. Thời gian giao dịch nhanh, không cần đợi xác nhận từ ngân hàng, không phải chờ ngày cuối tuần, \u0026hellip;\n  Hạn chế lỗi phát sinh do con người: Toàn bộ các hoạt động của blockchain do hệ thống tự vận hành, không có sự can thiệp của con người.\n​\n  7. Nhược điểm  Lãng phí: việc xử lý tính toán được thực hiện bởi tất cả các node trong hệ thống nhưng chỉ kết quả của 1 node được sử dụng, chi phí tính toán của tất cả node còn lại bị lãng phí. Khó mở rộng: Việc xác nhận các giao dịch và đóng gói dữ liệu được thực hiện bởi toàn bộ các node trong hệ thống. Nếu lượng giao dịch quá lớn trong khoảng thời gian ngắn thì hệ thống không thể đáp ứng việc xử lý đồng thời quá nhiều Vấn đề lưu trữ dữ liệu: Khi hệ thống trở nên lớn hơn thì lượng dữ liệu cần lưu trữ sẽ ngày càng lớn. Như Ethereum mỗi năm dữ liệu tăng khoảng 55GB, nếu tất cả các node đều lưu trữ dữ liệu này thì các node sẽ cần khả năng xử lý cao hơn và điều này không thực tế. Nếu chỉ có một số node lưu trữ full data thì việc tấn công sẽ dễ hơn bởi vì chỉ cần tấn công một số ít node. Tích hợp phức tạp: Blockchain là công nghệ hoàn toàn mới nên việc tích hợp vào các hệ thống cũ sẽ rất khó khăn Chưa hoàn thiện: Hiện nay công nghệ blockchain vẫn đang trong giai đoạn phát triển và chưa có một ứng dụng nào áp dụng công nghệ blockchain thành công ngoài lĩnh vực tiền ảo  8. Các ứng dụng của blockchain / Các vấn đề mà blockchain có thể xử lý  Truy xuất nguồn gốc sản phẩm (vật lý hay kỹ thuật số) Giảm chi phí trung gian Giải quyết vấn đề giao dịch không cần tin tưởng lẫn nhau Hợp đồng thông minh smart contract tự động thực thi điều khoản hợp đồng khi các điều kiện được đáp ứng, tránh việc chây ỳ, phá hợp đồng.  II. Smart contract 1. Smart contract là gì? Smart contract là một chương trình máy tính được lưu trữ trong blockchain, có khả năng thực thi các thoả thuận tự động mà không cần sự can thiệp từ con người.\nSmart contract nói một cách chính xác hơn là giao dịch có điều kiện conditional transaction. Nghĩa là khi 2 bên đồng ý các điều khoản với nhau thì sẽ lập nên một smart contract/transaction với các điều kiện ràng buộc. Khi các điều kiện này thoả thì sẽ thực hiện giao dịch (transaction)/ hoặc huỷ giao dịch tuỳ điều kiện.\nSmart contract được hỗ trợ bởi hầu hết các nền tảng blockchain hiện tại nhưng Ethereum là nền tảng được sử dụng nhiều nhất bởi sự linh hoạt và các tính năng mà nó hỗ trợ.\nVí dụ:\nKhi A mua hàng sách online tại Shop P, cuốn sách trị giá 200k, A và Shop P lập 1 smart contract\n 200k của A sẽ được lưu trong smart contract điều kiện là khi A nhận được cuốn sách từ Shop P -\u0026gt; chuyển 200k vào tài khoản shop P.  2. Smart contract hoạt động như thế nào? implement smart contract Ethereum\nLàm thử rồi hiểu\n3. Ưu và nhược điểm của Smart contract Ưu điểm:\n Không cần sự can thiệp của con người trong việc thực thi hợp đồng Giảm bớt chi phí trung gian: luật sư, phí giao dịch ngân hàng Không cần tin tưởng đối tác Tự động thực thi  Nhược điểm:\n  Để kiểm tra điều kiện của smart contract thì toàn bộ hệ thống phải truy xuất vào cùng 1 nguồn dữ liệu\n Việc này giống như tấn công DDOS Không có gì đảm bảo tất cả các kết quả trả về là giống nhau, vd: nguồn ko hoạt động, bị thay đổi    Smart contract không thể cập nhật các điều khoản\n  Không thể huỷ bỏ\n  Tính chính xác của smart contract phụ thuộc vào người thiết lập các điều khoản (thường là lập trình viên)\n Lập trình viên là con người và có xác suất lỗi Lập trình viên phải hoàn toàn hiểu các điều khoản để chuyển thành chương trình Phải hoàn toàn tin tưởng vào lập trình viên. 👹(they can be evil)    Nguồn dữ liệu để kiểm tra các điều kiện có thể đến từ thế giới thực (vd xác nhận đã nhận hàng) thì vẫn có thể bị tấn công, giả mạo các thông tin đầu vào, hoặc phụ thuộc vào 1 bên thứ 3 được tin tưởng tuyệt đối\n  4. Ứng dụng của Smart contract Tất cả những hoạt động giao dịch có điều kiện đều có thể sử dụng smart contract\n  Tạo ra các token mới, có thể sử dụng như 1 loại tiền điện tử\n  Xổ số\n  Mua hàng online\n  Bảo hiểm\n  Mua nhà\n  Giao hàng\n  Cá độ\n  …..\n  III. Fork, Hard fork vs soft fork? 1 Fork là gì? Như đã biết Blockchain là một chuỗi các khối liên kết với nhau, và các chuỗi này là giống nhau trên toàn bộ hệ thống. Các node  trong hệ thống thông qua một cơ chế đồng thuận  consensus để xác định khối nào sẽ được thêm vào blockchain. Fork  xảy ra khi một hệ thống không đạt được sự đống thuận trong việc ghi các khối mới và blockchain bị chia tách thành 2 nhánh khách nhau.\nNguyên nhân của fork là do:\n Thêm các tính năng mới để cải tiến chức năng của hệ thống blockchain hiện tại. Sửa đổi các rule (quy định) trong quá trình xác nhận giao dịch và tạo khối (Vd: kích thước của 1 block)  Do những thay đổi này là permanent(lâu dài) nên khi thực hiện fork các node trong hệ thống cần phải cập nhật ứng dụng client để tích hợp các rule mới.\nFork được chia làm 3 loại:\n Soft fork Hard fork Spin-off coin  2 Soft fork Soft fork là những cập nhật phần mềm có tương thích với phiên bản cũ , nghĩa là các node không cần cập nhật phần mềm mới vẫn có thể thực hiện việc kiểm tra (validate) và xác nhận(verify) các giao dịch. Để hoàn thành soft fork chỉ cần phần lớn các node trong hệ thống cập nhật phiên bản mới, các node cũ vẫn có thể tiếp tục xác nhận các block mới tạo.\nSoft fork là thực hiện việc cập nhật từ từ và không ảnh hưởng nhiều đến chức năng của hệ thống.\nVí dụ:\nThay đổi kích thước block từ 1MB lên 2MB, các node chưa cập nhật vẫn có thể tiếp nhận và xử lý các giao dịch, tuy nhiên các block do các node này tạo ra sẽ bị hệ thống bỏ qua, không cho ghi vào blockchain, nên công sức xử lý của các node này coi như là bị lãng phí.\n3 Hard fork Hard fork là những cập nhật phần mềm tạo nên sự không tương thích với các phiên bản cũ. Để hoàn toàn cập nhật, tất cả các node phải cập nhật phần mềm lên phiên bản mới. Những node không cập nhật sẽ vẫn tiếp tục hoạt động theo các rule cũ. Các node mới và node cũ sẽ tạo nên 2 phiên bản khác nhau từ 1 blockchain ban đầu.\nViệc thực hiện Hard fork có thể là do có kế hoạch trước hoặc là do sự chia rẽ trong cộng đồng sử dụng, bảo trì blockchain.\n3.1 Hard fork có kế hoạch  Là những cập nhật trong giao thức đã được lên kế hoạch từ trước và có sự đồng thuận từ toàn bộ cộng đồng. Tất cả các node sẽ dần chuyển hoàn toàn qua nhánh mới tách ra. Nhánh cũ sẽ bị bỏ đi Việc cập nhật sẽ không gây ảnh hưởng tới giá trị của coin  3.2 Hard fork do tranh cãi  Thông thường là do sự bất đồng ý kiến trong cộng đồng trong việc xác định những thay đổi mà mỗi bên cho là tốt nhất đối với blockchain hiện tại. Blockchain sẽ chia tách thành 2 phiên bản khác nhau cùng tồn tại song song với nhau. Các node trong mạng lưới ban đầu cũng sẽ tách thành 2 mạng lưới khác nhau: mỗi bên sử dụng 1 bản cập nhật khác nhau. Các giao dịch trước khi chia tách sẽ tồn tại trong cả 2 blockchain  Ví dụ\nViệc hard fork Bitcoin thành Bitcoin và Bitcoin Cash, do 1 bên muốn giữ kích thước Block 1MB và 1 bên muốn nâng kích thước block lên 8MB để tăng khả năng mở rộng của Bitcoin (thực hiện nhiều giao dịch hơn trong cùng thời gian)\n4 Spin-off coin Sử dụng mã nguồn của những coin có sẵn và thay đổi để tạo nên blockchain mới với những tính năng mới thêm vào.\nVí dụ\nLitecoin là một coin dựa trên mã nguồn của Bitcoin với các thay đổi:\n Thời gian xử lý block trung bình là 2.5 phút so với 10 phút của Bitcoin Sử dụng thuật toán Scrypt thay vì SHA256 Giới hạn tổng số coin là 84 triệu so với 21 triệu Bitcoin  IV. Coin vs Token 1. Coin là gì? Coin là một loại tiền mã hoá (crypto currency) được tạo ra và vận hành một cách độc lập dựa trên một nền tảng blockchain của riêng nó.\nCoin là từ dùng để chỉ chung các loại tiền ảo như : Bitcoin, Ethereum, \u0026hellip;\nAltcoin dùng để chỉ các loại tiền ảo ngoài Bitcoin\n2. Token là gì ? Tạo token mới từ Ethereum\nToken là các đơn vị có thể được sử dụng để dao dịch như coin, tuy nhiên token được tạo ra và hoạt động dựa trên cơ chế Smart contract mà các nền tảng Blockchain như Ethereum hay Omni cung cấp.\nHiện nay hơn 80% các loại token được tạo ra dựa trên nền tảng Ethereum\n3. Phân loại token Không có phân loại cụ thể cho token. Một token có thể sử dụng cho một hoặc nhiều mục đích:\n Sử dụng như đơn vị tiền tệ Tài sản số (digital) Công cụ kế toán Công cụ phân chia cổ phần nắm giữ trong các start-up Một phương pháp để chống tấn công Một dạng điểm, reward cho user \u0026hellip;  ","date":"11","image":"/img/blockchain.jpg","permalink":"https://bluzky.github.io/blog/2018-04-11-blockchain/","tags":["others","tech","blockchain"],"title":"Tìm hiểu về công nghệ Blockchain"},{"categories":null,"contents":"  Vừa mới hoàn thành các chức năng cơ bản cho hệ thống OKR nội bộ công ty. Sau quá trình tìm hiểu các phương pháp áp dụng OKR vào trong một tổ chức, mình thấy nó rất là hay và đơn giản, dễ áp dụng. Ngoài việc áp dụng cho công ty, có thể áp dụng các nguyên tắc của OKR để thiết lập kế hoạch cá nhân. Đây là tóm tắt một số nội dung cơ bản về OKR, có thể có một số sai sót mong nhận được sự góp ý.   1. OKR là gì? OKR - Objectives and Key Results - tạm dịch Mục tiêu và Kết quả then chôt.\nOKR là một phương pháp thiết lập mục tiêu giúp tạo sự thống nhất giữa mục tiêu của từng cá nhân với mục tiêu của toàn công ty, tập trung động lực của toàn bộ công ty để đạt được mục tiêu đề ra.\nOKR đã được áp dụng bởi các công ty hàng đầu như Intel, Google (từ 1999), Oracle, Linked in, \u0026hellip;\nĐiểm khác biệt của OKR so với các phương pháp truyền thống:\n OKR được thiết lập thường xuyên (thông thường là mỗi quý) Quá trình thực hiện OKR bao gồm việc liên tục theo dõi và đánh giá kết quả thực hiện được. OKR đơn giản, theo nhịp điệu nhanh (do thời gian thực hiện OKR ngắn) và khuyến khích sự tham gia của các nhân viên.  2. Các lợi ích khi áp dụng OKR  Tạo nên sự thống nhất trong công ty: mục tiêu của mỗi cá nhân đều theo định hướng của mục tiêu công ty, khi mỗi cá nhân đạt được mục tiêu thì công ty sẽ đạt được mục tiêu. Sự rõ ràng và tập trung: Mục tiêu cá nhân ít và rõ ràng, giúp nhân viên biết rõ mục tiêu của mình và cần làm gì để đạt được mục tiêu. Kết nối nhân viên với sứ mệnh công ty: khi mục tiêu của mỗi nhân viên gắn với mục tiêu công ty, mỗi người sẽ ý thức được sự đóng góp của cá nhân cho sự phát triển của công ty. Tạo nên sự trong suốt: nghĩa là mỗi nhân viên có thể thấy được mục tiêu của những nhân viên khác, qua đó thúc đẩy sự hợp tác/hỗ trợ để đạt được mục tiêu chung. Đơn giản, dễ áp dụng, không tốn nhiều thời gian  3. OKR hoạt động như thế nào OKR dựa trên các khái niệm\n Objective: Mục tiêu muốn đạt được. (Bạn muốn đi đến đâu?) Key Result: các kết quả then chốt dùng để đo lường mức độ hoàn thành của mục tiêu. (Làm sao để biết là bạn đạt được mục tiêu hay chưa?)  Bước 1: Xây dựng mục tiêu cho toàn công ty Mục tiêu của công ty nên được thiết lập mỗi quý 1 lần. Dựa trên mục tiêu của công ty, các phòng ban thiết lập mục tiêu phòng ban theo định hướng công ty, tương tự thiết lập mục tiêu xuống các cấp thấp hơn. Các mục tiêu phải được cụ thể hoá bằng các kết quả then chốt\n  Mục tiêu (Objective)\n Mỗi cá nhân/ công ty chỉ nên có 3-5 mục tiêu. Các mục tiêu nên mang tính tham vọng, lớn hơn khả năng. Các nghiên cứu chứng minh rằng nếu đặt mục tiêu cao thì sẽ có khả năng đạt được kết quả cao hơn. Mỗi mục tiêu chỉ nên có 3-4 kết quả then chốt. Nhiều kết quả then chốt sẽ dễ tạo nên sự mất tập trung. Mục tiêu của cấp thấp hơn (vd phòng ban) sẽ dựa trên mục tiêu của cấp cao hơn(vd công ty). Mỗi cá nhân tự đặt ra mục tiêu của mình và thảo luận với cấp trên trực tiếp để thống nhất mục tiêu theo đúng định hướng.    Kết quả then chốt (key result) cần phải\n Cụ thể: Có thể đo lường được (có thể tính bằng con số cụ thể hoặc %) Có xác định thời gian deadline Không nên cảm tính, cần dựa trên tình hình cụ thể của công ty    Bước 2: Thực hiện  Ở mức độ cá nhân, các Key Result nên được chia thành các Task (Tác vụ) thực hiện trong ngày hoặc tuần.  Bước 3: Đánh giá liên tục (Check - in)  Check - in nên được thực hiện hàng tuần, có thể kết hợp với các buổi họp khác như 15' stand-up meeting Mục đích của Check - in  Đánh giá lại các công việc đã làm Giải quyết các vướng mắc/ khó khăn gặp phải. Nhắc nhở mục tiêu mà mỗi nhân viên cần hướng tới    Bước 4: Đánh giá tổng kết   Đánh giá kết quả thực hiện\n  Mức độ hoàn thành Key result được tính điểm 0.0 - 1.0\n  Điểm đánh giá của Objective tính bằng điểm trung bình của các Key result\n  Thang đánh giá\n \u0026lt; 0.4: Chưa đạt 0.6 - 0.7: Tốt   0.7: quá dễ\n     Khi mục tiêu có điểm \u0026gt; 0.7 nghĩa là mục tiêu đặt ra quá dễ, cần phải xem xét lại việc đặt mục tiêu lần sau\n  Khi mục tiêu \u0026lt; 0.4 nghĩa là việc xác đinh hoặc thực hiện mục tiêu chưa tốt.\n    Tại sao mục tiêu cty nên theo từng quý\n Thống nhất với lịch tài chính của công ty 3 tháng là khoảng thời gian đủ để tạo nên kết quả có thể đánh giá được    OKR cho phép người quản lý đảm bảo rằng tất cả nhân viên đang hướng đến mục tiêu chung. Mỗi tuần, mỗi cá nhân cần (check-in) cập nhật/đánh giá các kết quả then chốt của mình để đảm bảo các nhân viên đang đi đúng hướng và giảm thời gian họp không cần thiết. Nếu một nhân viên gặp các vấn đề vướng mắc, các vấn đề nên được giải quyết thông qua các cuộc họp trực tiếp 1-1 với cấp trên trực tiếp.\n- Nên tách biệt OKR với hệ thống đánh giá hiệu quả công việc của nhân viên để tránh tạo nên việc đặt ra các\n4. Một ví dụ áp dụng OKR trong thiết lập mục tiêu công ty  Comming soon\n 5. Một số sai lầm khi áp dụng OKR  Sử dụng OKR như list công việc Quá nhiều mục tiêu. Thay vì liệt kê tất cả các mục tiêu muốn đạt được, chỉ nên chọn ra 3-4 mục tiêu với độ ưu tiên cao nhất Thiếu sự thống nhất mục tiêu. Mục tiêu cần được thiết lập dựa trên mục tiêu chung của công ty và thông qua thảo luận để xác định đúng trọng tâm. Thiết lập xong rồi quên. Thực hiện OKR phải bao gồm việc liên tục theo dõi và đánh giá kết quả/tiến độ thực hiện, đảm bảo mỗi cá nhân luôn tập trung vào OKR của mình. Xây dựng OKR theo kiểu phân cấp, cấp dưới phải đợi cấp trên thiết lập xong mục tiêu rồi mới tạo mục tiêu của mình. Điều này dẫn tới việc tốn nhiều thời gian và mục tiêu của cá nhân sẽ sai lệch soi với mục tiêu công ty nếu mục tiêu ở cấp trên chưa đúng.  ","date":"09","image":null,"permalink":"https://bluzky.github.io/blog/2018-02-09-tim-hieu-okr/","tags":["others","management"],"title":"Thiết lập và quản lý mục tiêu theo phương pháp OKR"},{"categories":null,"contents":"1. Giới thiệu  List là một trong những kiểu dữ liệu được sử dụng rất nhiều trong python. Các thao tác thường được thực hiện trên list: xử lý từng phần tử trong list, lọc lấy một số phần tử thỏa điều kiện, tính toán dựa trên tất cả các phần tử của list( vd tính tổng) và trả về kết quả. Để đơn giản việc xử lý List, Python hỗ trợ một số hàm có sẵn để thực hiện các tác vụ trên gồm map(), filter(), reduce()  2. Map  map(func, seq) \u0026gt; map sẽ áp dụng hàm func cho mỗi phần tử của seq và trả về list kết quả.\n Ví dụ: Tính bình phương các số có trong list\na. sử dụng map():\n1 2 3 4 5 6  my_list = [1,2,3,4,5] def binh_phuong(number): return number*number print map(binh_phuong, my_list) # [1,2,9,16,25]    Trong ví dụ trên, map sẽ tự động áp dụng hàm binh_phuong với mỗi phần tử trong danh sách my_list Hàm truyền vào hàm map nhận vào một tham số cùng kiểu với phần tử của list Có thể sử dụng lamda thay thế cho hàm. Ví dụ trên có thể được viết lại: print map(lambda x: x*x, my_list)  b. Cách thông thường:\n1 2 3 4 5 6  my_list = [1,2,3,4,5] result = list() for number in my_list: result.append( number*number) print result # [1,2,9,16,25]   3. Filter   filter(func, list) Hàm filter sẽ gọi hàm func với tham số lần lượt là từng phần tử của list và trả về danh sách các phần tử mà func trả về True func chỉ có thể trả về True hoặc False   Ví dụ: lọc ra các số chẵn từ danh sách a. Sử dụng filter:\n1 2 3 4 5 6 7 8 9  my_list = [1, 2, 3, 4, 5] def so_chan(number): if number % 2 == 0: return True else: return False print filter(so_chan, my_list) # [2,4]   #Sử dụng lambda\n1  print filter(lambda x: x%2 ==0, my_list)# [2,4]   b. Không dùng filter\n1 2 3 4 5 6 7 8  my_list = [1, 2, 3, 4, 5] ket_qua = list() for number in my_list: if number % 2 == 0: ket_qua.append(number) print ket_qua   4. Reduce  reduce(func, seq) reduce sẽ tính toán với các phần tử của danh sách và trả về kết quả. func là một hàm nhận vào 2 tham số có dạngfunc(arg1, arg2) trong đó arg1 là kết quả tính toán với các phần tử trước, arg2 là giá trị của phần tử của danh sách đang được tính toán.\n Ví dụ: tính tổng bình phương của các phần tử trong mảng a. Su dung reduce\n1 2 3 4 5 6 7 8 9  data = [1,2,3,4] def tinh_tong(tong, so): return tong + so*so #su dung ham print reduce(tinh_tong, data) #30 #su dung lambda print reduce( (lambda tong, so: tong + so*so), data) #30   b. Khong su dung reduce\n1 2 3 4 5 6  data = [1,2,3,4] tong = 0 for so in data: tong += so*so print tong #30   5. Kết luận  Trong bài viết chỉ đưa ra những ví dụ đơn giản nên có thể các bạn chưa thấy được sự tiện dụng của map, filter, reduce. Tuy nhiên khi phải làm việc với list nhiều các bạn sẽ thấy nó rất là tiện đặc biệt là khi sử dụng kèm lambda hoặc tái sử dụng các hàm với map, filter và reduce  ","date":"21","image":null,"permalink":"https://bluzky.github.io/blog/2018-01-21-python-xu-ly-mang-voi-filter-reduce/","tags":["python","python-basic"],"title":"Dùng MAP, FILTER và REDUCE để xử lý danh sách / list trong Python"},{"categories":null,"contents":"1. Decorator là gì?  Decorator là một mẫu thiết kế (Design pattern) thường được dùng để thay đổi hành vi, chức năng của hàm(function) hoặc lớp (class) mà không cần phải thay đổi code của hàm hoặc lớp. Tham khảo Python hỗ trợ cú pháp (syntax) cho Decorator từ version 2.4 Về cơ bản Decorator giống như một lớp vỏ bọc (wrapper), nó thay đổi hành vi(behavior) của code trước và sau khi gọi hàm chính (hàm được decorate).  2. Decorator được dùng làm gì? Tại sao chúng ta cần Decorator?\n Cho phép tái sử dụng code. Mở rộng các hàm, hoặc lớp mà không cần phải thay đổi code có sẵn \u0026ndash;\u0026gt; không cần test lại.  Ví dụ trong chương trình của bạn bạn cần kiểm tra quyền (permission) của người dùng trước khi thực hiện hàm. Bạn có thể phải thêm code vào tất cả các hàm đã có để kiểm tra. Thay vào đó với decorator, bạn chỉ cần định nghĩa một decorator và khai báo nó trước hàm.\n3. Làm sao để định nghĩa một decorator?   Decorator cũng là một hàm chỉ khác là hàm decorator nhận vào một hàm và kết quả trả về của nó là hàm sau khi được decorate.\n  Như vậy để định nghĩa một decorator chỉ đơn giản là định nghĩa một hàm nhận vào một hàm khác và trả về một hàm mới có prototype tương đương với hàm nhận vào.\n  Ví dụ 1:\n1 2 3 4 5 6 7 8  def ten_decorator(f): def wrapper(ten): chuoi_moi = \u0026#34;Ten tui la %s\u0026#34; % ten return f(chuoi_moi) return wrapper def xuat_ten( ten ): print ten     CHÚ Ý QUAN TRỌNG: hàm wrapper và hàm f phải có tham số phù hợp với nhau. Ví dụ như hàm f nhận vào chỉ 2 tham số thì hàm decorator không thể nhận vào 3 tham số hoặc 1 tham số.\n  4. Sử dụng decorator như thế nào?  Sử dụng Decorator hết sức đơn giản. Sử dụng decorator trong ví dụ trên cho hàm xuat_ten như sau:  1 2 3  @ten_decorator def xuat_ten(ten): print ten    Dùng dấu @ để thông báo đó là một decorator. Một hàm có thể dùng nhiều decorator cùng lúc:  1 2 3 4 5  @ten_decorator1 @ten_decorator2 @ten_decorator3 def xuat_ten(ten): print ten   5. Decorator hoạt động như thế nào? Như trong ví dụ ở trên:\n  ten_decorator nhận vào hàm f, sau đó bọc hàm f trong hàm wrapper của nó và trả về hàm wrapper. Hàm wrapper có nhiệm vụ gắn thêm thông tin vào tên rồi mới gọi thực hiện hàm f với chuỗi mới.\n  Việc sử dụng:\n1 2 3 4  @ten_decorator def xuat_ten(ten): print ten xuat_ten(\u0026#39;coulson\u0026#39;)   Tương đương với:\n1 2 3 4  def xuat_ten(ten): print ten ham_xuat_ten_moi = ten_decorator(xuat_ten) ham_xuat_ten_moi(\u0026#39;coulson\u0026#39;)     Rõ ràng với việc sử dụng cú pháp decorator thì code sẽ ngắn gọn và đơn giản hơn. Developer không phải gọi decorator mỗi lần sử dụng mà trình thông dịch sẽ làm việc đó.\n  Đối với hàm sử dụng nhiều decorator\nVí dụ 2\n1 2 3 4 5  @ten_decorator1 @ten_decorator2 @ten_decorator3 def xuat_ten(ten): print ten    Decorator nào càng ở trên, xa function thì sẽ bọc lớp ngoài Giống như khi bạn bọc trái xoài vào trong bị, rồi lại lấy cái bị khác để bọc bên ngoài nữa. Thứ tự thực thi code: - Code của decorator được thực thi ngay lúc file nguồn Python được load lên. Ngoại trừ code trong hàm wrapper của decorator trong cùng sẽ được thực thi lúc gọi hàm. - Decorator được gọi thực thi theo thứ tự từ trong (gần hàm nhất) ra ngoài.  6 Truyền tham số cho decorator  Ở trên, để cho đơn giản, và dễ hiểu thì decorator là một hàm có tham số là một hàm khác. Nhưng điều đó không bắt buộc, decorator cũng có thể là một hàm nhận vào tham số bất kỳ và trả về một hàm và hàm trả về này nhận vào tham số là một hàm khác.\n Ví dụ 3: thêm chức danh vào chuỗi xuất ra mình có thể định nghĩa decorator như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  def chuc_danh_decorator(ten_chuc_danh): def ten_decorator(f): def wrapper(ten): chuoi_moi = \u0026#34;Xin gioi thieu %s%s\u0026#34; % (ten_chuc_danh, ten) return f(chuoi_moi) return wrapper return ten_decorator @chuc_danh_decorator(\u0026#34;Giao su\u0026#34;) def gioi_thieu(ten): print ten @chuc_danh_decorator(\u0026#34;Tien si\u0026#34;) def gioi_thieu_2(ten): print ten gioi_thieu(\u0026#34;Teo\u0026#34;) gioi_thieu_2(\u0026#34;Ti\u0026#34;) \u0026gt;\u0026gt; Xin gioi thieu Giao su Teo \u0026gt;\u0026gt; Xin gioi thieu Tien si Ti   Sự khác biệt:\n Hàm decorator bây giờ không phải nhận vào tham số là một hàm mà có thể là tham số bất kỳ. Hàm trả về từ decorator nhận vào một hàm và chính nó mới trả về hàm wrapper Cách sử dụng decorator cũng khác một chút. Decorator được gọi chạy ( dùng dấu () ) và truyền vào tham số.  Nó chạy như thế nào:\n Trong ví dụ 3 decorator được sử dụng @chuc_danh_decorator(\u0026quot;Giao su\u0026quot;). Chú ý dấu (\u0026hellip;), decorator được gọi thực thi và nó trả về hàm ten_decorator và chính nó sẽ bọc hàm được decorate. Hàm chuc_danh_decorator chỉ có tác dụng là dùng để truyền tham số vào decorator.  7. Debug hàm decorator. Khi sử dụng decorator thì hàm thực sự được gọi là hàm wrapper của trả về từ decorator. Nên các thuộc tính __name__, __doc__, __module__ không còn là của hàm được decorate nữa mà là của wrapper\nSử dụng lại code trong ví dụ 1:\n1 2 3  print xuat_ten.__name__ \u0026gt;\u0026gt; wrapper   Khắc phục: sử dụng thư viện functools Ví dụ 4:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  from functools import wraps def ten_decorator(f): @wraps(f) def wrapper(ten): chuoi_moi = \u0026#34;Ten tui la %s\u0026#34; % ten return f(chuoi_moi) return wrapper def xuat_ten( ten ): print ten print xuat_ten.__name__ \u0026gt;\u0026gt; xuat_ten   Decorator wraps sẽ lấy các thuộc tính __name__, __doc__, __module__ của hàm được decorate và gán cho hàm wrapper nên khi lấy những thuộc tính này sẽ trả về thông tin đúng.\n8. Khi nào nên sử dụng decorator? Tham khảo trang Wiki của Python\n","date":"21","image":null,"permalink":"https://bluzky.github.io/blog/2018-01-21-python-decorator/","tags":["python","python-basic"],"title":"Python decorator là gì? dùng khi nào"},{"categories":null,"contents":"Thực sự thì không nhất thiết phải là *args và **kwargs. điều quan trọng là tham số có 1 dấu sao * hay là 2 dấu sao **. Đặt tên tham số là *var hay **vars hay bất cứ thứ gì bạn muốn. Nhưng để dễ hiểu thì nên dùng tên chuẩn là *args và **kwargs\n1. *args và **kwargs dùng để làm gì?  Khi khai báo 1 hàm, sử dụng *args và **kwargs cho phép bạn truyền vào bao nhiêu tham số cũng được mà không cần biết trước số lượng. Ví dụ  1 2 3 4 5 6 7 8 9 10  # với giả sử các tham số truyền vào đều là số def sum(*args): total = 0 for number in args: total += number return total # gọi hàm sum(1, 2, 3,19) sum( 1, 100)   2. *args và **kwargs khác gì nhau?  Cho những bạn chưa biêt: Khi gọi hàm trong Python, có 2 kiểu truyền tham số:  Truyền tham số theo tên. Truyền tham số bình thường theo thứ tự khai báo đối số. Ví dụ  1 2 3 4 5 6  def register(name, password): .... # Truyền tham số theo kiểu thông thường, phải theo đúng thứ tự register( \u0026#39;Coulson\u0026#39;, \u0026#39;hail_Hydra\u0026#39;) # Truyền tham số theo tên, Không cần phải theo thứ tự khai báo thao số register( password=\u0026#39;cookHim\u0026#39;, name=\u0026#39;Skye\u0026#39;)    *args nhận các tham số truyền bình thường. Sử dụng args như một list. **kwargs nhận tham số truyền theo tên. Sử dụng **kwargs** như một. dictionary  Ví dụ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def test_args(*args): for item in args: print item \u0026gt;\u0026gt;test_args(\u0026#39;Hello\u0026#39;, \u0026#39;world!\u0026#39;) Hello world! def test_kwargs(*kwargs): for key, value in kwargs.iteritems(): print \u0026#39;{0}= {1}\u0026#39;.format(key, value) \u0026gt;\u0026gt;test_kwargs(name=\u0026#39;Dzung\u0026#39;, age=10) age = 10 name = Dzung   3. Thứ tự sử dụng và truyền tham số *args, **kwargs và tham số bình thường Khi sử dụng phải khai báo đối số theo thứ tự:\n **đối số xác đinh \u0026ndash;\u0026gt; *args \u0026ndash;\u0026gt; **kwargs**\n Đây là thứ tự bắt buộc. Và khi truyền tham số bạn cũng phải truyền theo đúng thứ tự này. Không thể truyền lẫn lộn giữa 2 loại.\n Khi sử dụng đồng thời *args **kwargs thì không thể truyền tham số bình thường theo tên\n Ví dụ\n1 2 3 4 5 6 7 8 9 10 11  def show_detail(name, *args, **kwargs): ..... show_detail(name=\u0026#39;Coulson\u0026#39;, \u0026#39;agent\u0026#39;, age=\u0026#39;40\u0026#39;, level=\u0026#39;A\u0026#39;) \u0026gt;\u0026gt; Lỗi def show_detail_2(name, **kwargs): .... show_detail_2(name=Coulson\u0026#39;, age=\u0026#39;40\u0026#39;, level=\u0026#39;A\u0026#39;) \u0026gt;\u0026gt; Chạy Ok   ","date":"21","image":null,"permalink":"https://bluzky.github.io/blog/2018-01-21-truyen-tham-so-dong-python/","tags":["python","python-basic"],"title":"Truyền tham số động trong python (*args | **kwargs)?"},{"categories":null,"contents":"1. Oauthh 2 và các khái niệm 1.1 Oauth 2 là gì: Oauth 2 là bản nâng cấp của giao thức chứng thực Oauth 1.0\n1.2 Các Role (vai trò) trong mô hình oauth  resource owner là đối tượng có khả năng cấp quyền truy cập tới tài nguyên (resource) được bảo vệ Resource server là một server lưu trữ các tài nguyên, có khả năng xử lý các yêu cầu truy cập tới tài nguyên được bảo vệ. Client Ứng dụng muốn truy cập vào protected resource với tư cách của người sở hữu resource Authorization server là server chuyên cấp access token cho client sau khi resource owner đồng ý cấp phép cho client truy xuất vào resource được bảo vệ  1.3 Luồng xử lý của giao thức 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  +--------+ +---------------+ | |--(A)- Authorization Request -\u0026gt;| Resource | | | | Owner | | |\u0026lt;-(B)-- Authorization Grant ---| | | | +---------------+ | | | | +---------------+ | |--(C)-- Authorization Grant --\u0026gt;| Authorization | | Client | | Server | | |\u0026lt;-(D)----- Access Token -------| | | | +---------------+ | | | | +---------------+ | |--(E)----- Access Token ------\u0026gt;| Resource | | | | Server | | |\u0026lt;-(F)--- Protected Resource ---| | +--------+ +---------------+    (A) Ứng dụng client yêu cầu resource owner cấp quyền (B) Client nhận được sự cấp phép từ resource owner tùy theo loại grant trong yêu cầu. Nếu được chứng thực, client sẽ được cấp 1 authorization grant (C) Client yêu cầu Authorization server xác thực authorization grant từ resource owner. (D) Authorization server sẽ kiểm tra và xác nhận authorization grant. Nếu được xác thực, Client sẽ nhận được access token (E) Client request resource từ resource server, dính kèm access token trong request. (F)Resource Server sẽ kiểm tra tính hợp lệ của access token. Nếu token hợp lệ, resource theo yêu cầu sẽ được cấp phát.  1.4 Authorization Grant Authorization grant là một chứng nhận xác định những resource nào đã được cấp quyền truy cập bởi chủ sở hữu của resource. Nó được sử dụng bởi ứng dụng client để đổi lấy access token. Có 4 loại authorization grant:\n Authorization code Implicit Resource owner password credential Client credential  1.4.1 Authorization code Authorization code được cấp phát trong mô hình mà server ủy quyền đóng vai trò trung gian giữa client và resource owner. Client sẽ chuyển resource owner tới server ủy quyền. Sau khi resource owner đồng ý, server ủy quyền sẽ trả về cho clien authorization code\n1.4.2 Implicit Implicit grant là sự bản đơn giản hóa của Authorization code, thường được dùng trên các ứng dụng không có khả năng bảo mật authorization grant. Ví dụ như web browser hoặc ứng dụng mobile. Thay vì tạo ra các authorization code, client được nhận trực tiếp access token. Do sự đơn giản hóa của nó nên implicit grant dễ bị tấn công, và các vấn đề về bảo mật.\n1.4.3 Resource Owner Password Credentials Đây là phương thức xác thực trong đó ứng dụng clieownernt sẽ dùng username và password của người dùng/ resource owner để xác thực với server ủy quyền. Sau khi xác thực thì server ủy quyền sẽ trả về cho ứng dụng client access token và refresh token. Do đó ứng dụng client không cần phải lưu thông tin đăng nhập của resource owner. Kiểu chứng thực này chỉ được sử dụng trên những ứng dụng của đối tác có độ tin cậy cao.\n1.4 Các khái niệm khác 1.4.1 Access token  Access token là những chứng nhận dùng để truy cập vào những tài nguyên được bảo vệ. Access token là một chuỗi ký tự, chứa thông tin về chứng nhận được cấp cho ứng dụng client như: thời gian hết hạn, phạm vi tài nguyên được sử dụng \u0026hellip;. Access token có thể dùng để định danh người dùng. nó dùng để lấy thông tin của resource owner hoặc bản thân nó chứa thông tin của resource owner. Access token giúp cho việc xác thực đơn giản hơn. 4 cách yêu cầu cấp quyền từ resource owner đều tạo ra access token do đó resource server không cần phải biết phương thức chứng thực nào được sử dụng. Nó chỉ cần biết sử dụng access token là đủ.  1.4.2 Refresh token  Refresh token là chứng chỉ được sử dụng để trao đổi lấy access token. Nó được trả về cùng với authorization grant, và được dùng để yêu cầu cấp mới access token khi access token hiện tại hết hạn. Refresh token được sử dụng với server ủy quyền, không sử dụng với resource server.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  +--------+ +---------------+ | |--(A)------- Authorization Grant ---------\u0026gt;| | | | | | | |\u0026lt;-(B)----------- Access Token -------------| | | | \u0026amp; Refresh Token | | | | | | | | +----------+ | | | |--(C)---- Access Token ----\u0026gt;| | | | | | | | | | | |\u0026lt;-(D)- Protected Resource --| Resource | | Authorization | | Client | | Server | | Server | | |--(E)---- Access Token ----\u0026gt;| | | | | | | | | | | |\u0026lt;-(F)- Invalid Token Error -| | | | | | +----------+ | | | | | | | |--(G)----------- Refresh Token -----------\u0026gt;| | | | | | | |\u0026lt;-(H)----------- Access Token -------------| | +--------+ \u0026amp; Optional Refresh Token +---------------+   Figure 2: Refreshing an Expired Access Token\n (A) Client gửi authorization grant và yêu cầu server ủy quyền cấp access tocken và refresh token (B) server ủy quyền xác thực client và authorization grant. Nếu hợp lệ, nó sẽ tạo ra access token và refresh token và trả về cho client (C) Client yêu cầu truy xuất tới resource được bảo vệ sử dụng access token (D) Resource server kiểm tra access token, nếu hợp lệ, thực hiện yêu cầu từ client. (E) bước (C) và (D) được lặp lại cho tới khi access token hết hạn. Nếu client biết access token hết hạn, nó sẽ chủ động chuyển qua bước (G), nếu không nó sẽ gửi request mới. (F) Phát hiện access token hết hạn, resource server trả về lỗi access token không hợp lệ. (G) Client gửi refresh token lên server ủy quyền và yêu cầu cấp phát access token mới. (H) server ủy quyền kiểm tra thông tin client và refresh token, nếu hợp lệ, nó sẽ cấp phát access token và có thể là cả refresh token mới  2. Đăng ký client  Trước khi có thể sử dụng giao thức oauth 2, client phải đăng ký với server ủy quyền. Việc đăng ký tùy thuộc vào server Thông tin đăng ký có thể bao gồm:\n Loại client redirection URI Một số thông tin khác: mô tả, tên ứng dụng \u0026hellip;.   2.1 Loại Client Oauth định nghĩa 2 loại client:\n confidential(bí mật): client có khả năng lưu trữ và bảo mật các chứng nhận được cấp. public (công khai): client không thể bảo vệ các chửng nhận được cấp một cách bí mật.  Việc phân loại này dựa trên các loại ứng dụng sau:\n Ứng dụng web: là một loại client bí mật(confidential) chạy trên web server. Resource owner truy cập tới ứng dụng web thông qua browser. Các chứng nhận được cấp cũng như access token được lưu trữ trên server và resource owner không thể đọc những thông tin này. Ứng dụng trên nền browser: là loại public client trong đó code của ứng dụng client được tải về và chạy trên thiết bị của người dùng. Các chứng nhận, access token có thể dễ dàng truy cập bởi người sử dụng. Ứng dụng native: là một dạng public client, được cài và thực thi trên thiết bị của người dùng. Các dữ liệu của giao thức và các dữ liệu bí mật như access token có thể được truy xuất bởi người dùng với giả sử rằng ứng dụng có thể bị tách ra(extracted). Tuy nhiên ứng dụng có thể định nghĩa một số phương thức bảo vệ các thông tin bí mật của giao thức. Tùy vào nền tảng(platform) các thông tin này có thể được bảo vệ tránh sự truy xuất của các ứng dụng khác trên cùng thiết bị.  2.2 Định danh client (client identifier) Với mỗi client đăng ký, server ủy quyền sẽ tạo ra một chuỗi duy nhất để xác định client đó(được gọi là client identifier). Client identifier được công khai, được dùng để server ủy quyền kiểm tra liệu client có hợp lệ hay không.\n2.3 Chứng thực client Đối với loai client bí mật(confidential), client và server ủy quyền thiết lập một phương pháp phù hợp để xác thực client. Phương thức xác thực này là tùy vào client và server\n2.4 Mật khẩu của client  Nếu client sử dụng password. Nó có thể dùng mô hình chứng thực cung cấp bởi giao thức HTTP(RFC2617). Định danh của client được mã hóa sử dụng thuật toán \u0026ldquo;application/x-www-form-urlencoded\u0026rdquo;. Giá trị sau khi mã hóa được sử dụng như mật khẩu của client. server ủy quyền phải hỗ trợ mô hình chứng thực của giao thức HTTP. Một cách khác, server ủy quyền có thể hỗ trợ việc gửi thông tin của client trong thân của request( request-body) với các tham số: - client_id [REQUIRED]: định danh của client - client_secret [REQUIRED]: chuỗi bí mật của client\nVí dụ:  POST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded grant_type=refresh_token\u0026amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA \u0026amp;client_id=s6BhdRkqt3\u0026amp;client_secret=7Fjfp0ZBr1KtDRbnfVdmIw  Phương pháp gửi thông tin client qua request-body không được khuyến khích sử dụng. Bởi vì nó dễ bị tấn công hơn so với phương pháp đầu tiên.\n 3. Các điểm cuối của giao thức (Protocol Endpoint) Tiến trình chứng thực trên server có 2 điểm cuối(endpoint)\n Authorization endpoint : được sử dụng bởi client để yêu cầu sự xác nhận từ resource owner thông qua user-agent(thường là browser). Token endpoint: được sử dụng bởi client để trao đổi authorization grant lấy access token.  Phía client chỉ có 1 điểm cuối:\n Redirection endpoint: là điểm mà server ủy quyền dùng để trả về thông tin cho client thông qua user-agent(thường là browser) của resource owner   Không phải tất cả các kiểu chứng thực đều tạo ra 2 endpoint. Một số kiểu chứng thực mở rộng có thể tạo ra các endpoint khác\n 3.1 Authorization Endpoint(sơ lược) Authorization endpoint được sử dụng để tương tác với resource owner, yêu cầu sự cấp quyền từ resource owner. server ủy quyền trước tiên phải xác thực resource owner.\n3.1.1 Response type (kiểu trả về) Đối với trường hợp authorization endpoint được sử dụng bởi authorization code và implicit grant, client thông báo với server ủy quyền kiểu cấp quyền sử dụng tham số: response_type [REQUIRED] có thể là một trong 2 giá trị sau:\n code \u0026ndash;\u0026gt; yêu cầu sử dụng kiểu authorization code token \u0026ndash;\u0026gt; yêu cầu cấp phát access token (sử dụng cho implicit)  có thể mở rộng response_type tùy nhu cầu. Có thể cùng lúc request nhiều response_type; các gía trị phải cách nhau bằng khoảng trắng.\n3.2 Redirection Endpoint (sơ lược)  Sau khi yêu cầu cấp quyền xong, server ủy quyền chuyển hướng user-agent vào redirection URI lúc đăng ký client. Request này chứa các thông tin về chứng chỉ đã được cấp phát cho client. Một client có thể đăng ký nhiều redirection URI. Nếu không có URI nào được đăng ký thì rất dễ bị tấn công. Nếu nhiều URI được đăng ký, thì lúc yêu cầu chứng thực, client phải gửi kèm tham số redirect_uri. server ủy quyền sẽ tìm URI giống với trong request để trả về các chứng nhận  3.3 Token endpoint (sơ lược) Token endpoint được sử dụng bởi client, là nơi xác thực authorization grant và trả vê access token và refresh token cho client.\n3.4 Phạm vi(scope) của access token  Authorization endpoint và Token endpoint cho phép client xác định phạm vi/ giới hạn truy xuất của request thông qua tham số scope. Sau khi được cấp quyền, authorization server sử dụng scope để xác định các giới hạn/ phạm vi được quyền truy cập đối với access token được trả về. Scope được thể hiện dưới dạng một chuỗi gồm nhiều scope cách nhau bằng khoảng trắng. Nếu scope của access token được cấp phát giống với scope trong request của client thì server có thể bỏ qua tham số scope trong response. Nếu scope khác với trong request thì bắt buộc phải trả về tham số scope trong response.  4. Lấy ủy quyền (Obtain authorization) Để yêu cầu một access token, client cần phải nhận được sự ủy quyền từ resource owner. Sự ủy quyền được thể hiện dưới dạng authorization grant. Client sử dụng nó để yêu cầu lấy một access token. Có 4 loại cấp quyền: authorization code, implicit, resource owner password credentials, và client credentials.\n4.1 Cấp quyền sử dụng code thay thế cho ủy quyền (Athorization code grant)  Kiểu này sử dụng để yêu cầu cả access token và refresh token, thường dùng với confidential client. Kiểu cấp quyền này dựa trên redirection (chuyển hướng) nên client phải có thể tương tác với user-agent (browser) cà nhận request thông qua redirection từ server ủy quyền. Sơ đồ:   +----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- \u0026amp; Redirection URI ----\u0026gt;| | | User- | | Authorization | | Agent -+----(B)-- User authenticates ---\u0026gt;| Server | | | | | | -+----(C)-- Authorization Code ---\u0026lt;| | +-|----|---+ +---------------+ | | ^ v (A) (C) | | | | | | ^ v | | +---------+ | | | |\u0026gt;---(D)-- Authorization Code ---------' | | Client | \u0026amp; Redirection URI | | | | | |\u0026lt;---(E)----- Access Token -------------------' +---------+ (w/ Optional Refresh Token) Note: Các đường thẳng minh hoạ bước (A), (B), và (C) được chia thành 2 phần bởi vì chúng được thực hiện thông qua user agent Figure 3: Quá trình cấp code ủy quyền  (A)client khởi tạo luồng xử lý bằng việc chuyển hướng user-agent(browser) của resource owner tới authorizatio endpoint. Client gửi kèm theo định danh của nó được server ủy quyền cấp, phạm vi quyền hạn (scope), redirection URI. (B)Server ủy quyền sẽ xác thực resource owner (yêu cầu đăng nhập) và yêu cầu resource owner quyết định đồng ý hay từ chối yêu cầu cấp quyền. (C) Giả sử resource owner đồng ý cấp quyền, server ủy quyền sẽ chuyển hướng user-agent đến clien sử dụng redirection URI, kèm theo đó là auhthorization code (code xác nhận ủy quyền). (D) Client yêu cầu cấp access token tới server ủy quyền, kèm theo đó là authorization code từ bước (C) vả redirection URI. (E) Server ủy quyền xác thực client, kiểm tra sự hợp lệ của authorization code và redirection URI. Nếu tất cả đều hợp lệ, server xác thực sẽ trả về cho client access token và có thể gồm refresh token.  4.1.1 Yêu cầu ủy quyền (Authorization request) Client tạo 1 request với các tham số sau, sử dụng định dạng application/x-www-form-urlencoded\n response_type [REQUIRED] phải có giá trị là code client_id [REQUIRED] định danh của client, được nói trong phần 2 redirect_uri [OPTIONAL] url chuyển hướng đến sau khi được ủy quyền scope [OPTIONAL] giới hạn/phạm vi của request được ủy quyền. Trong phần 3.4 state [RECOMMENDED]. được sử dụng bởi client để truyền thông tin trạng thái từ request và callback. Server ủy quyền sẽ gửi kèm state khi chuyển hướng tới redirec URI. state nên được sử dụng để ngăn chặn kiểu tấn công cross-site request forgery. Ví dụ  GET /authorize?response_type=code\u0026amp;client_id=s6BhdRkqt3\u0026amp;state=xyz \u0026amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1 Host: server.example.com 4.1.2 Kết quả nếu thành công (Authorization response) Nếu resource server đồng ý cấp quyền truy cập, server ủy quyền sẽ sinh ra một code xác nhận ủy quyền (authorization code) và trả về cho client thông qua redirection URI với các tham số sau:\n code [REQUIRED] code ủy quyền được sinh ra bởi server ủy quyền. Nó phải hết hạn trong khoảng thời gian ngắn, khuyến khích tối đa là 10 phút để tránh bị rò rỉ. clien chỉ được sử dụng authorization code 1 lần. Nếu nhiều hơn 1 lần thì server ủy quyền phải từ chối và nên hủy bỏ các access token đã cấp sử dụng authorization code đó ngay khi có thể. state [REQUIRED] nếu tham số state được gửi đi trong authorization request thì nó sẽ được nhận lại nguyên vẹn ở client. Ví dụ  HTTP/1.1 302 Found Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA \u0026amp;state=xyz Client phải bỏ qua tất cả các tham số khác nếu có.\n4.1.3 Kết quả trả về nếu bị lỗi (Error response) Nếu yêu cầu ủy quyền thất bại, server ủy quyền phải thông báo cho client biết lý do và không được tự động chuyển hướng qua redirection URI không hợp lệ. Lỗi nên được trả về thông qua redirection URI với các tham số sau:\n error [REQUIRED] một chuỗi ký tự ASCII trong các lỗi sau: - unauthorized_client: client không được ủy quyền để yêu cầu authorization code - access_denied: resource owner hoặc server ủy quyền từ chối request - unsupported_response_type: server ủy quyền không hỗ trwoj việc lấy authorization code sử dụng phương thức này. - invalid_scope: scope trong yêu cầu cấp quyền không hợp lệ. - server_eror: server ủy quyền gặp một lỗi không xác định nên nó không thể thực hiện việc cấp ủy quyền được. - temporarily_unavailable: server ủy quyền tạm thời không thể xử lý yêu cầu vì một lý do nào đó. error_description [OPTIONAL] chuỗi ký tự cung cấp thông tin chi tiết về lỗi mà con người có thể đọc được error_uri [OPTIONAL] một URI dẫn tới một trang web cung cấp thông tin về lỗi state [REQUIRED] bắt buộc phải có nếu trong request gửi lên server có kèm theo tham số state.  4.1.4 Yêu cầu cấp Access token Client gửi yêu cầu cấp token tới token endpoint cùng với các tham số sau sử dụng kiểu định dạng( format) application/x-www-form-urlencoded.\n grant_type [REQUIRED] giả trị phải là authorization_code. code [REQUIRED] authorization code nhận được từ server ủy quyền. redirect_uri [REQUIRED] cần phải có nếu tham số redirect_uri được gửi đi lúc yêu cầu ủy quyền trong phần 4.1.1 client_id [REREQUIRED] định danh của lient Ví dụ:  1 2 3 4 5 6 7  POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded grant_type=authorization_code\u0026amp;code=SplxlOBeZQQYbYS6WxSbIA \u0026amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb   Server ủy quyền phải:\n Yêu cầu client chứng thực đối với confidential client Đảm bảo rằng authorization code được cấp phát cho đúng client. Nếu client là public thì đảm bảo rằng code được cấp đúng cho client_id trong request Kiểm tra authorization code có còn hợp lệ hay không Đảm bảo tham redirect_uri được gửi nếu redirect_uri đã được gửi trong yêu cầu 4.1.1  4.1.5 Kết quả cấp access token Nếu yêu cầu hợp lệ và quá trình cấp phát thành công, server ủy quyền sẽ tạo ra một access token và có thể kèm theo refresh token. Nếu yêu cầu thất bại thì server sẽ trả về lỗi được trình bày trong phàn 5.2. Ví dụ:\n1 2 3 4 5 6 7 8 9 10 11 12  HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;:\u0026#34;example\u0026#34;, \u0026#34;expires_in\u0026#34;:3600, \u0026#34;refresh_token\u0026#34;:\u0026#34;tGzv3JOkF0XG5Qx2TlKWIA\u0026#34;, \u0026#34;example_parameter\u0026#34;:\u0026#34;example_value\u0026#34; }   4.2 Implicit grant Implicit grant được sử đụng để lấy access token (không hỗ trợ refresh token) và được sử dụng trong các client công khai. Sơ đồ hoạt động:\n\t+----------+ | Resource | | Owner | | | +----------+ ^ | (B) +----|-----+ Client Identifier +---------------+ | -+----(A)-- \u0026amp; Redirection URI ---\u0026gt;| | | User- | | Authorization | | Agent -|----(B)-- User authenticates --\u0026gt;| Server | | | | | | |\u0026lt;---(C)--- Redirection URI ----\u0026lt;| | | | with Access Token +---------------+ | | in Fragment | | +---------------+ | |----(D)--- Redirection URI ----\u0026gt;| Web-Hosted | | | without Fragment | Client | | | | Resource | | (F) |\u0026lt;---(E)------- Script ---------\u0026lt;| | | | +---------------+ +-|--------+ | | (A) (G) Access Token | | ^ v +---------+ | | | Client | | | +---------+ Note: Đường thẳng minh họa các bước (A) và (B) được chia thành 2 phần vì chúng được chuyển thông qua user-agent. Figure 4: Implicit Grant Flow  (A) client khởi tạo luồng chứng thực bằng việc chuyển hướng user-agent của resource owner tới authentication endpoint. Client gửi kèm theo đó là định danh client, phạm vi/giới hạn yêu cầu, trạng thái hiện tại và URI chuyển hướng sau khi được ủy quyền. (B) Server ủy quyền sẽ xác thực người dùng, và hỏi người dùng có chấp nhận ủy quyền hay từ chối yêu cầu từ client. (C) giả sử resource owner được cấp quyền truy cập, server ủy quyền sẽ chuyển hướng user-agent đến redirection URI trong bước (A) kèm theo access token trong URI fragment(phần sau dấu # trên URL) (D) user-agent giữ lại thông tin về access token và chuyển hướng tới redirection URI của ứng dụng web. (E) ứng dụng web của client trả về một trag web với khả lấy và sử dụng access token trên user-agent. (F) user-agent thực thi các script từ ứng dụng web để lấy access token . (G) user-agent chuyển access token cho client sử dụng.  4.2.1 Yêu cầu ủy quyền: Client tạo một request với các tham số sau, sử dụng định dạng application/x-www-form-urlencoded.\n response_type [REQUIRED] giá trị phải là token client_id [REQUIRED] định đanh của client redirect_uri [OPTIONAL] (đã nói ở phần trước). scope [OPTIONAL] (đã nói ở phần trước). state [RECOMMENDED] (giống như authorization code grant)  Ví dụ:\n\tGET /authorize?response_type=token\u0026amp;client_id=s6BhdRkqt3\u0026amp;state=xyz \u0026amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1 Host: server.example.com Server ủy quyền sẽ kiểm tra request để đảm bảo các tham số đầy đủ và hợp lệ. Nếu tất cả thông tin đều hợp lệ thì server ủy quyền sẽ chứng thực resource owner và hỏi việc cấp quyền từ resource owner. Sau khi hoàn tất, server sẽ chuyển thông tin về cho client thông qua redirection URI\n4.2.2 Access token trả về Nếu resource owner chấp nhận yêu cầu ủy quền thì server sẽ trả về trong redirection URI với các tham số sau:\n access_token [REQUIRED] access token cấp phát bởi server token_type [REQUIRED] loại token được cấp phát. Trình bày trong phần 7 expired_in [RECOMMENDED] thời gian sống của access token tính theo giây scope [OPTIONAL] tùy chọn nếu giống với scope trong request, bắt buộc trả về trong trường hợp ngược lại. state bắt buộc nếu trong request có gửi kèm tham số state  Server không được trả về refresh_token\nVí dụ\n\tHTTP/1.1 302 Found Location: http://example.com/cb# access_token=2YotnFZFEjr1zCsicMWpAA \u0026amp;state=xyz\u0026amp;token_type=example\u0026amp;expires_in=3600 4.2.3 Lỗi trả về Nếu quá trình xin ủy quyền thất bại thì server sẽ trả về các tham số sau trong thông qua redirect URI\n error [REQUIRED] một chuỗi ký tự ASCII chứa mã lỗi trong những chuỗi sau: - invalid_request request thiếu tham số hoặc các tham số không hợp lệ. - unauthorized_client client không được ủy quyền đối với phương pháp này. - access_denied rresource ơnowner từ chối ủy quyền cho client. - unsupported_response_typeserver ủy quyền không hỗ trợ phương thức ủy quyền này. - invalid_scope quyền hạn yêu cầu không hợp lệ, sai định đạng. - server_error lỗi server không thể tiếp tục quá trình xin cấp ủy quyền. - temporarily_unavailable server tạm thời không thể xử lý yêu cầu xin cấp ủy quyền. error_description [OPTIONAL] mô tả chi tiết của lỗi xảy ra. error_uri một URI dẫn tới mội trang web chứa thông tin chi tiết về lỗi xảy ra. state bắt buộc phải có nếu trong request có gửi kèm tham số state.  Ví dụ:\n HTTP/1.1 302 Found Location: https://client.example.com/cb# error=access_denied\u0026amp;state=xyz 4.3 Cấp quyền sử dụng thông tin đăng nhập của resource owner. Chỉ nên sử dụng khi client và resource owner có mối quan hệ tin tưởng lẫn nhau.\nLuồng xử lý:\n +----------+ | Resource | | Owner | | | +----------+ v | Resource Owner (A) Password Credentials | v +---------+ +---------------+ | |\u0026gt;--(B)---- Resource Owner -------\u0026gt;| | | | Password Credentials | Authorization | | Client | | Server | | |\u0026lt;--(C)---- Access Token ---------\u0026lt;| | | | (w/ Optional Refresh Token) | | +---------+ +---------------+ Figure 5: Resource Owner Password Credentials Flow  (A) resource owner cung cấp thông tin username, password cho client. (B) Client yêu cầu server ủy quyền cấp access token cho nó, kèm theo đó là thông tin đăng nhập của resource owner. Đồng thời server ủy quyền cũng chứng thực client. (C) server ủy quyền kiểm tra tất cả các thông tin, nếu hợp lệ nó sẽ tạo access token và trả về cho client.  4.3.1 Yêu cầu access token Client sau khi lấy được thông tin đăng nhập của resource owner , tạo một request kèm các thông số sau, sử dụng format \u0026quot;application/x-www-form-urlencoded\u0026quot;\n grant_type [REQUIRED] giá trị phải là \u0026quot;password\u0026quot;. user_name [REQUIRED] username của resource owner. password [REQUIRED] password của resource owner. scope [OPOPTIONAL] phạm vi quyền hạn được ủy quyền.  Ví dụ:\n1 2 3 4 5 6  POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded grant_type=password\u0026amp;username=johndoe\u0026amp;password=A3ddj3w   4.3.2 Kết quả access token Nếu quá trình xin ủy quyền thực hiện thành công. Server ủy quyền tạo ra access token và có thể cả refresh token và trả về cho client\nVí dụ: cấp phát thành công\n1 2 3 4 5 6 7 8 9 10 11 12  HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;:\u0026#34;example\u0026#34;, \u0026#34;expires_in\u0026#34;:3600, \u0026#34;refresh_token\u0026#34;:\u0026#34;tGzv3JOkF0XG5Qx2TlKWIA\u0026#34;, \u0026#34;example_parameter\u0026#34;:\u0026#34;example_value\u0026#34; }   4.4 Cấp quyền bằng thông tin chứng thực của client Client có thể yêu cầu cấp access token sử dung thông tin chứng thực của chính nó. Kiểu ủy quyền này chỉ được sử dụng cho confidential client.\nLuồng xử lý:\n +---------+ +---------------+ | | | | | |\u0026gt;--(A)- Client Authentication ---\u0026gt;| Authorization | | Client | | Server | | |\u0026lt;--(B)---- Access Token ---------\u0026lt;| | | | | | +---------+ +---------------+ Figure 6: Client Credentials Flow  (A) client chứn thực nó với server ủy quyền và yêu cầu cấp access token từ token endpoint. (B) server ủy quyền chứng thực client, nếu hợp lệ, cấp một access token.  4.4.1 Yêu cầu cấp Access token Client gửi tạo một request với các tham số sau, sử dụng format \u0026quot;application/x-www-form-urlencoded\u0026quot;:\n grant_type [REREQUIRED] giá trị bắt buộc là client_credentials. scope [OPTIONAL] phạm vi quyền hạn được ủy quyền.  Ví dụ:\n POST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded grant_type=client_credentials 4.4.2 Kết quả access token Nếu quá trình chứng thực thành công thì server trả về cho client access token nhưng không nên gửi refresh token. Ví dụ:\n1 2 3 4 5 6 7 8 9 10 11  HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;:\u0026#34;example\u0026#34;, \u0026#34;expires_in\u0026#34;:3600, \u0026#34;example_parameter\u0026#34;:\u0026#34;example_value\u0026#34; }   4.5 Mở rộng kiểu cấp ủy quyền Client sử dụng kiểu cấp ủy quyền mở rộng bằng cách thay đổi giá trị của tham số grant_type trong request gửi tới token endpoint và thêm các tham số khác nếu cần thiết.\nPHẦN NÀY KHÔNG DỊCH CHI TIẾT\n5 Cấp phát access token 5.1 Kết quả trả về nếu thành công Các thông tin trả về được chứa trong body của gói tin HTTP trả về với mã lỗi 200. Các tham số:\n access_token [REQUIRED] access token được cấp. token_type [REQUIRED] loại token được cấp phát. xem phần 7 expires_in [RECOMMENDED] thời gian sống của access token. refresh_token [OPTIONAL] token dùng để xin cấp lại access token khi hết hạn. scope [OPTIONAL] nếu scope giống với trong request. [REQUIRED] nếu khác với trong request.  Các tham số được chứa trong thân của của HTTP response có định dạng \u0026quot;application/json\u0026quot; Server ủy quyền phải kèm theo header \u0026ldquo;Cache-Control\u0026rdquo; trong gói response với giá trị là \u0026ldquo;no-store\u0026rdquo;\nVí dụ:\n1 2 3 4 5 6 7 8 9 10 11 12  HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;access_token\u0026#34;:\u0026#34;2YotnFZFEjr1zCsicMWpAA\u0026#34;, \u0026#34;token_type\u0026#34;:\u0026#34;example\u0026#34;, \u0026#34;expires_in\u0026#34;:3600, \u0026#34;refresh_token\u0026#34;:\u0026#34;tGzv3JOkF0XG5Qx2TlKWIA\u0026#34;, \u0026#34;example_parameter\u0026#34;:\u0026#34;example_value\u0026#34; }   Client phải bỏ qua các tham số khác không được xách định ở trên.\n5.2 Lỗi trả về Nếu quá trình xin ủy quyền thất bại thì server sẽ trả về các tham số sau trong thông qua redirect URI\n error [REQUIRED] một chuỗi ký tự ASCII chứa mã lỗi trong những chuỗi sau: - invalid_request request thiếu tham số hoặc các tham số không hợp lệ. - invalid_client việc chứng thực client thất bại. - invalid_grant phương pháp thực hiện việc cấp quền hoặc refresh token không hợp lệ, hết hạn, bị hủy bỏ, redirection URI không đúng. - unauthorized_client client không được ủy quyền đối với phương pháp này. - unsupported_response_typeserver ủy quyền không hỗ trợ phương thức ủy quyền này. - invalid_scope quyền hạn yêu cầu không hợp lệ, sai định đạng. error_description [OPTIONAL] mô tả chi tiết của lỗi xảy ra. error_uri một URI dẫn tới mội trang web chứa thông tin chi tiết về lỗi xảy ra.  Các tham số này được chứa trong body của response sử dụng loại media \u0026quot;application/json\u0026quot;\nVí dụ:\n1 2 3 4 5 6 7 8  HTTP/1.1 400 Bad Request Content-Type: application/json;charset=UTF-8 Cache-Control: no-store Pragma: no-cache { \u0026#34;error\u0026#34;:\u0026#34;invalid_request\u0026#34; }   6 Làm mới access token Client gửi request tới token endpoint với các tham số sau sử dụng format \u0026quot;application/x-www-form-urlencoded\u0026quot;:\n grant_type [REQUIRED] giá trị phải là refresh_token. refresh_token [REQUIRED] chuỗi refresh token. scope [OPTIONAL] phạm vi quyền hạn truy cập, các quyền ở đây phải là những quyền nằm trong scope lúc yêu cầu cấp access token. Nếu không có tham số scope thì mặc định phạm vi quyền hạn sẽ giống như lúc yêu cầu cấp phát access token.  Ví dụ:\n\tPOST /token HTTP/1.1 Host: server.example.com Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW Content-Type: application/x-www-form-urlencoded grant_type=refresh_token\u0026amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA Server ủy quyền sẽ:\n Chứng thực client. Kiểm tra refresh token có đúng là được cấp cho client hay không. Kiểm tra refresh token có hợp lệ hay không.  Nếu tất cả các thông tin đều hợp lệ thì server ủy quyền sẽ cấp token mới cho client. Server có thể tạo refresh token mới, khi đó refresh token cũ sẽ không còn hợp lệ.\n7. Truy cập vào tài nguyên được bảo vệ Client truy cập vào tài nguyên được bảo vệ bằng cách cung cấp access token cho resource server. Resource servẻ phải kiểm tra access token để đảm bảo rằng nó còn hiệu lực và nằm trong phạm vi truy cập.\n7.1 Các loại access token Loại của access token được trả về cùng với access token khi cấp phát thành công. Có 2 loại access token:\n bearer mac ở đây không nói chi tiết về 2 loại token này. Tham khảo RFC6750 và OAuth-HTTP-MAC  7.2 Trả lỗi Nếu yêu cầu truy xuất tài nguyên thất bại, resource server nên thông báo client lỗi đã xảy ra\n8. Mở rộng giao thức: (không dịch) 9. Ứng dụng native:(không dịch) 10. Các nguy cơ bảo mật. 10.1 Chứng thực client 10.2 Mạo danh client  Một client nguy hiểm có thể mạo danh một client khác và lấy quyền truy cập tới tài nguyên được bảo vệ nếu client bị mạo danh thất bại hoặc không thể giữ bí mật các thông tinh chứng thực của nó. Server phải chứng thực client bất cứ khi nào có thể. Yêu cầu client đăng ký redirection URI để nhận kết quả ủy quyền. Server ủy quyền nên cung cấp cho người dùng thông tin về client và quyền hạn mà client yêu cầu. Server ủy quyền không nên tự động lặp lại việc ủy quyền mà không xác thực client hoặc dựa trên các cách khác để đảm bảo request đến từ cùng client  10.3 Access token  Access token phải được giữ bí mật trong quá trình lưu trữ và truyền tải. Và chỉ chia sẻ giữa server ủy quyền, resource server và client sở hữu nó. Access token chỉ được truyền tải qua giao thức TLS. Khi sử dụng kiểu cấp ủy quyền implicit, access token được gắn vào URI nên dễ dàng bị đánh cắp bởi các bên/ứng dụng khác. Server ủy quyền phải đảm bảo rằng access token không thể được tạo ra, thay đổi hoặc đoán được bởi một bên nào khác không được chứng thực. Client nên yêu cầu cấp access token với phạm vi truy cập tối thiểu cần thiết cho nó.  10.4 Refresh token  Server ủy quyền có thể cấp refresh token cho ứng dụng web hoặc ứng dụng native. Refresh token phải được giữ bí mật trong lưu trữ và truyền tải. Và chỉ được chia sẻ giữa server ủy quyền và client được cấp phát. refresh token phải được truyền tải qua giao thức TLS. Server ủy quyền phải kiểm tra liệu refresh token có phải được cấp phát cho client hay không. Trong trường hợp không thể chứng thực client, server nên sử dụng các cách khác để phát hiện việc lạm dụng refresh token. Server ủy quyền phải đảm bảo rằng refresh token không thể được tạo ra, thay đổi hoặc đoán được bởi một bên nào khác không được chứng thực.  10.5 Authorization code   Việc truyền tải authorization code nên được thực hiện thông qua một kênh bảo mật. Client nên sử dụng giao thức TLS cho redirection URI. Authorization code được truyền thông qua user-agent nên nó có thể bị bắt lại ở user agent.\n  Authorization code phải có thời gian sống ngắn và chỉ được dùng một lần. Nếu server ủy quyền nhận thấy authorization code được sử dụng lại nhiều lần, server nên hủy tất cả các access token đã cấp phát dựa trên authorization code này.\n  Nếu có thể, server ủy quyền nên chứng thực clien và kiểm tra authorization code có được cấp phát cho đúng client hay không.\n  10.7 Authorization Code Redirection URI Manipulation  Khi sử dụng phương thức cấp quyền authorization code, client xác định URI chuyển hướng băng tham số redirect_uri. Nếu kẻ tấn công có thể thay đổi giá trị của redirect_uri nó có thể làm cho server chuyển hướng kết quả tới URI của kẻ tấn công. Kẻ tấn côn có thể tạo tài khoản trên một server hợp lệ và khởi tạo luồng cấp ủy quyền. Khi user-agent của kẻ tấn công đang request tới server ủy quyền để yêu cầu cấp quyền truy cập, hắn thay thế URI của client hợp pháp và thay bằng URI của hắn. Sau đó kẻ tấn công lừa cho nạn nhân sử dụng link đã được thay đổi để cấp quyền truy cập cho client hợp lệ.  Một khi server ủy quyền hoàn thành việc cấp ủy quyền, nạn nhân sau đó sẽ được chuyển hướng tới một trang khác của kẻ tấn công cùng với authorization code. Sau đó attacker gửi authorization code tới client. client sử dụng thông tin đó để cấp quyền truy cập cho account của kẻ tấn công, và hắn có thể sử dụng tài khoản của mình để truy cập vào tài nguyên được bảo vệ của nan nhân thông qua client.\nĐể ngăn chặn kiểu tấn công như vậy: - Server ủy quyền phải đảm bảo rằng redirection URI được sử dụng để lấy code ủy quyền phải giống với redirection URI khi đổi authorization code lấy access token. - Server ủy quyền yêu cầu public client phải đăng ký redirection URI và confidential client cũng nên đăng ký redirection URI. server sẽ kiểm tra URI trong request có đúng với URI đã đăng ký hay không.\n10.7 Resource Owner Password Credentials  Kiểu cấp quyền này có nhiều nguy cơ bị tấn công hơn so với những kiểu khác bởi vì nó sử dụng username và password là điều mà giao thức oauth2 muốn tránh khỏi.Client có thể lạm dụng hoặc để lộ mậu khẩu. Thêm vào đó, resource owner không được tham gia vào quá trình cấp quyền nên client có thể yêu cầu cấp phạm vi quyền hạn lớn hơn. Server ủy quyền nên xem xét thời gian sống và và phạm vi(scope) của access token trong kiểu cấp quyền này. Server ủy quyền và client nên hạn chế sử dụng kiểu cấp quyền này và sử dụng kiểu ủy quyền khác bất cứ khi nào có thể.  10.8 Request Confidentiality  access token, refresh token , resource owner password, và client credential KHÔNG ĐƯỢC truyền tại dưới dạng text rõ ràng (không được hash hay mã hóa). Authorization code KHÔNG NÊN truyền dưới dạng text rõ ràng. state và scope không nên chứa các thông tin nhạy cảm ủa client hoặc resource owner dưới dạng text rõ ràng bởi vì chúng có thể được truyền tải qua một kênh không an toàn.  10.9 Ensuring Endpoint Authenticity Để ngăn chặn kiểu tấn công man-in-the-middle, server ủy quyền phải yêu cầu sử dụng kênh truyền TLS.\n10.10 Credentials-Guessing Attacks  Server ủy quyền phải ngăn chặn kẻ tấn công đoán access token, mật khẩu của resource owner và thông tin đăng nhập của client. Khả năng kẻ tấn công đoán ra access token PHẢI nhỏ hơn hoặc bằng 2^(-128) và NÊN nhỏ hơn hoặc bằng 2^(-160)  10.11 Phishing Attacks 10.12 Cross-Site Request Forgery   Là kiểu tấn công trong đó kẻ tấn công làm cho user-agent của người dùng chuyển hướng theo một URI nguy hiể tới server đang được tin tưởng (thông thường được thiết lập qua một session cookie hợp lệ).\n  Tấn công CSRF dựa trên redirection URI cho phép kẻ tấn công thay thế bằng authorization code hoặc access token của hắn. Kết quả là client sẽ sử dụng access token liên kết với protected resource của kẻ tấn công thay vì của nạn nhân (Ví dụ như lưu thông tin tín dụng của nạn nhân vào tài khoản của kẻ tấn công).\n  Client phải hỗ trợ ngăn chặn CSRF đối với redirection URI của nó. Việc này có thể thực hiện bằng việc yêu cầu mọi request gửi tới redirection URI endpoint phải kèm theo một giá trị gắn request với trạng thái chứng thực của user-agent . Client nên tạo tham số state trong request gửi tới server ủy quyền.\n  Sâu khi cấp quyền, server trả về cho client kết quả kèm theo state của request. Thông tin này cho phép client kiểm tra tính hợp lệ của request.\n  Tấn công CSRF trên authorization endpoint của server ủy quyền có thể dẫn tới kết quả là kẻ tấn công lấy được ủy quyền của user cho một client nguy hiểm mà user không hề biết.\n  Server ủy quyền phải hỗ trợ việc ngăn chặn CSRF đối với authorization enpoint của nó và đảm bảo rằng client nguy hiểm không thể nhận được ủy quyền mà không có sự chấp thuận của resource owner.\n  10.13 Clickjacking  Đối với tấn công Clickjacking, kẻ tấn công đăng ký một client hợp lệ và tạo một website nguy hiểm để tả authorizatin endpoint của server ủy quyền trong một iframe trong suôt, và tạo các button tại vị trí các button trên trang của server ủy quyền. Khi người dùng click lên các button do kẻ tấn công tạo ra, họ đã vô tình click lên cac button vô hình trên trang cấp quyền(ví dụ như nút Authorize). Điều này giúp kẻ tấn công đánh lừa người dùng cấp quyền truy cập cho hắn mà người dùng không hề hay biết. Để ngăn chặn kiểu tấn công này, các ứng dụng native nên sử dụng các trình duyện bên ngoài thay vì nhúng trình duyệt bên trong ứng dụng, việc chặn các iframe có thể được thực hiện bằng việc server ủy quyền sử dụng \u0026quot;x-frame-options\u0026quot; header. Header này có nhận 1 trong hai giá trị deny hoặc \u0026lsquo;sameorigin\u0026rsquo;. Thiết lập này ngăn việc sử dụng iframe hoặc chặn iframe từ các trang không cùng domain.  10.14 Code Injection and Input Validation  Tấn công code injection xảy ra khi các biến bên ngoài hoặc input nhận vào và được sử dụng mà không được khử độc (:) sanitize) và do đó làm thay đổi logic của ứng dụng. Việc này cho phép kẻ tấn công lấy được quyền truy cập vào device mà ứng dụng đang chạy hoặc dữ liệu ứng dụng, gây từ chối dịch vụ hoặc là nhiều tác động nguy hiểm khác. Server ủy quyền và client nên sanitize(khử độc, khử trùng, khử) các giá trị nhận được, đặc biệt là tham số state và redirect_uri.  10.15 Open Redirectors  Server ủy quyền, authorization endpoint và client redirection endpoint có thể được cấu hình không đúng tạo nên open redirector. Open redirection là một endpoint sử dụng các tham số và chuyển hướng tự động tới các vị trí được xác định trong các tham số mà không kiểm tra trước. Open redirection có thể được sử dụng trong tấn công phishing, hoặc bởi kẻ tấn công để khiến người dùng truy cập vào các trang web nguy hiểm bằng cách sử dụng redirection URI. Ngoài ra nếu server ủy quyền cho phép client đăng ký 1 phần của redirection URI, kẻ tấn công có thể sử dụng open redirector để tạo ra các URI qua mặt được việc kiểm tra của server ủy quyền và server sẽ gửi authorization code hoặc access token tới redirection URI do kẻ tấn công quản lý.  10.16 isuse of Access Token to Impersonate Resource Owner in Implicit Flow  Đối với implicit thì không thể biết được access token đang được cấp phát cho client nào. resource owner có thể cấp quyền cho client của kẻ tấn công. Kẻ tấn công cũng có thể lấy trộm token thông qua một số cơ chế khác. Sau đó kẻ tấn công có thể giả mạo resource owner bằng cách cung cấp access token cho client hợp lệ. Kẻ tấn công cũng có thể thay thế access token mà server ủy quyền trả về bằng access token được cấp cho hắn trước đó.  \u0026mdash;- CÁC PHẦN CÒN LẠI KHÔNG DỊCH\u0026mdash;-\n","date":"21","image":null,"permalink":"https://bluzky.github.io/blog/2018-01-21-tim-hieu-oauth/","tags":["others","protocol","oauth2"],"title":"Tìm hiểu về Oauth / Oauth hoạt động như thế nào?"},{"categories":null,"contents":"1. What is Rabbit MQ?  Rabbit MQ is an server application, it is a message broker which implement AMQP (Advanced Message Queue Protocol). It works like a post service, which take the message from sender and dispatch that message to the receiver.\n Some terminologies:\n Producer: send message to queue Queue: hold all message added by producer and dispatch those message to a consumer Consumer: receive message from  2. What is Rabbit MQ used for? RabbitMQ is a message broker server that receive and dispatch/distribute messages to back end services that handle/process heavy tasks. It helps to build a big system can handle large amount of request\n3. Features list Reliability\nRabbitMQ offers a variety of features to let you trade off performance with reliability, including persistence, delivery acknowledgements, publisher confirms, and high availability.\nFlexible Routing\nMessages are routed through exchanges before arriving at queues. RabbitMQ features several built-in exchange types for typical routing logic. For more complex routing you can bind exchanges together or even write your own exchange type as a plugin.\nClustering\nSeveral RabbitMQ servers on a local network can be clustered together, forming a single logical broker.\nFederation\nFor servers that need to be more loosely and unreliably connected than clustering allows, RabbitMQ offers a federation model.\nHighly Available Queues\nQueues can be mirrored across several machines in a cluster, ensuring that even in the event of hardware failure your messages are safe.\nMulti-protocol\nRabbitMQ supports messaging over a variety of messaging protocols.\nMany Clients\nThere are RabbitMQ clients for almost any language you can think of.\nManagement UI\nRabbitMQ ships with an easy-to use management UI that allows you to monitor and control every aspect of your message broker.\nTracing\nIf your messaging system is misbehaving, RabbitMQ offers tracing support to let you find out what\u0026rsquo;s going on.\n3.Bis. Implement models 1. Supported Model   Default exchange\nMessage from Producer will be pushed directly to message queue and Consumber will receive message on the same queue. Producer and Consumer must know the name of the queue\n  Fanout exchange\nEvery message is pushed to Fanout exchange,it will be pushed to all all queues which subscribe this Exchange\n  Direct exachange\nIf a Consumer only want to filter received message, it will bind to one or many routing_key. When Exchange have new message, it will append that message to all queue which subscribe same routing_key with message. If message\u0026rsquo;s routing key does not match any subscriber, it will be discarded\n  Topic exchange\nThis type of exchange allow more complicated filter, it use pattern to filter topic. Topic string format contains many words and separate by dot [.] # to replace 0 or many words * to replace exactly one word Example:\npublish topic: kern.logs.error, security.log.warning pattern: *.*.error, kern.#\n  Headers exchange\n  2. Direct message:  Producer send message directy to message queue To send message direct to queue, set exchange name to empty string Many consumer can subcribe same queue. Message will be dispatched using FIFO rule\n Producer\n1 2 3  channel.basic_publish(exchange=\u0026#39;\u0026#39;, routing_key=\u0026#39;routing_name\u0026#39;, body=\u0026#39;message_content\u0026#39;)   Consumer\n1 2 3  channel.basic_consume(callback, # callback function to handle message queue=\u0026#39;queue_name\u0026#39; no_ack=True)   mermaid.initialize({ theme: 'forest' })  graph LR; A((Producer))--Q[queue]; Q -- C((Consumer 1)); Q -- C2((Consumer 2)); Q -- C3(( ......));  3. Publish message via Exchange(publish/subcribe) Exchange: acts like an agent, it receives messages from Producer and pushes them to appropriate queue. The idea of exchange is to separate Producer from queues. Producers do not need to know about queues, it simply sends message to exchange, and Exchanges will know how/ which queue to append message to or discard them.\n Routing key comes with publish and subscribe. Instead of knowing name of queue, producer now only need know routing key, it sends messages to Exchange with routing key. Each time Exchange receives a message, it will check message\u0026rsquo;s routing key and push that message to all Consumer which subscribe that routing key.\n mermaid.initialize({ theme: 'forest' })  graph LR; P1((P1))--E(Exchange); P2((P2))--E; E--|Black|Q1[Queue1]; E--|Green|Q2[Queue2]; E--|Blue|Q2[Queue2]; Q1--C1((C1)); Q2--C2((C2));  Producer\n1 2 3 4 5 6 7 8 9  # firs we need to declare an exchange # four types of exchange: fanout, headers, topic, direct channel.exchange_declare(exchange=\u0026#39;exchange_name\u0026#39;, type=\u0026#39;exchange_type\u0026#39;) .... channel.basic_publish(exchange=\u0026#39;exchange_name\u0026#39;, routing_key=\u0026#39;channel_name\u0026#39;, body=\u0026#39;message_content\u0026#39;) ....   Consumer\n1 2 3 4 5 6 7 8 9 10  channel.exchange_declare(exchange=\u0026#39;exchange_name\u0026#39;, type=\u0026#39;exchange_type\u0026#39;) .... # need to bind queue to a specific exchange channel.queue_bind(exchange=\u0026#39;exchange_name\u0026#39;, queue=\u0026#39;queue_name\u0026#39;) .... channel.basic_consume(callback, queue=\u0026#39;queue_name\u0026#39;, no_ack=True)    RPC\n Client send request to Server, Method is defined at server and Client should know exactly which function server has. Client push request to a queue and server subscribe this queue Server push result to another queue and clien subscribe this queue\n mermaid.initialize({ theme: 'forest' })  graph LR C((Client))--Q1[request queue] Q1-- S((Server)) Q2[result queue] --C S-- Q2 style C fill:orange style S fill:pink    ##4. Use case\n Sound cloud  ##5. References\n Install instruction Tutorial page ==AMQP concept== ##6. Conclusion  ","date":"21","image":null,"permalink":"https://bluzky.github.io/blog/2018-01-21-what-is-rabbit-mq/","tags":["others","tech"],"title":"What is Rabbit MQ?"}]