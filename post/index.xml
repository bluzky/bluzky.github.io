<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Bluz is Orange</title>
    <link>http://bluzky.github.io/post/</link>
    <description>Recent content in Posts on Bluz is Orange</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 18 May 2018 01:05:50 +0700</lastBuildDate>
    
	<atom:link href="http://bluzky.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Sử dụng ETS để tăng tốc ứng dụng với Phoenix</title>
      <link>http://bluzky.github.io/2018/05/s%E1%BB%AD-d%E1%BB%A5ng-ets-%C4%91%E1%BB%83-t%C4%83ng-t%E1%BB%91c-%E1%BB%A9ng-d%E1%BB%A5ng-v%E1%BB%9Bi-phoenix/</link>
      <pubDate>Fri, 18 May 2018 01:05:50 +0700</pubDate>
      
      <guid>http://bluzky.github.io/2018/05/s%E1%BB%AD-d%E1%BB%A5ng-ets-%C4%91%E1%BB%83-t%C4%83ng-t%E1%BB%91c-%E1%BB%A9ng-d%E1%BB%A5ng-v%E1%BB%9Bi-phoenix/</guid>
      <description>Bài viết này sẽ hướng dẫn các bạn sử dụng ETS như là bộ nhớ cache để tăng tốc các ứng dụng web Phoenix
 Dành cho các bạn chưa biết:
 ETS (Erlang Term Storage) là cơ sở dữ liệu dạng key-value lưu trữ trên RAM, tương tự như Memcache và Redis, với ưu điểm là tốc độ truy xuất cực nhanh. Đọc thêm về ETS Cache là việc lưu lại các kết quả xử lý của request vào bộ nhớ và trả về cho các request sau mà không cần phải tính toán lại -&amp;gt; giảm response time.</description>
    </item>
    
    <item>
      <title>Elixir - Lưu trữ dữ liệu trên RAM với ETS</title>
      <link>http://bluzky.github.io/2018/05/elixir-l%C6%B0u-tr%E1%BB%AF-d%E1%BB%AF-li%E1%BB%87u-tr%C3%AAn-ram-v%E1%BB%9Bi-ets/</link>
      <pubDate>Sat, 12 May 2018 14:28:22 +0700</pubDate>
      
      <guid>http://bluzky.github.io/2018/05/elixir-l%C6%B0u-tr%E1%BB%AF-d%E1%BB%AF-li%E1%BB%87u-tr%C3%AAn-ram-v%E1%BB%9Bi-ets/</guid>
      <description>ETS là gì? Có lẽ các bạn đã nghe qua về redis hoặc memcache, hoặc là cả hai. Còn nếu bạn chưa nghe tới bao giờ thì đó là những cơ sở dữ liệu lưu trữ trên RAM với ưu điểm là tốc độ truy xuất cực kỳ nhanh. ETS - Erlang Term Service - cũng là một CSDL lưu trữ trên RAM (in-ram DB) nhưng khác ở chỗ là ETS có sẵn khi cài Elixir/Erlang và bạn chẳng phải mất công cài đặt, cấu hình như 2 anh trên kia, nhà trồng được việc gì phải ngại.</description>
    </item>
    
    <item>
      <title>Test Facebook bot trên localhost với ngrok</title>
      <link>http://bluzky.github.io/2018/05/test-facebook-bot-tr%C3%AAn-localhost-v%E1%BB%9Bi-ngrok/</link>
      <pubDate>Tue, 08 May 2018 20:56:31 +0700</pubDate>
      
      <guid>http://bluzky.github.io/2018/05/test-facebook-bot-tr%C3%AAn-localhost-v%E1%BB%9Bi-ngrok/</guid>
      <description>Trong quá trình tìm hiểu về lập trình chat bot sử dụng các API của Facebook Messenger thì việt test chat bot trên localhost là một trở ngại.
Khi tạo một subscription cho app chat bot, Facebook sẽ gửi một request đến server mà chat bot đang chạy để xác nhận có đúng là chat bot của bạn không. Cũng như sau đó, tất cả những tin nhắn của nguời dùng sẽ đuợc gửi tới chat bot thông qua callback url.</description>
    </item>
    
    <item>
      <title>Chạy server Phoenix với SSL trên localhost</title>
      <link>http://bluzky.github.io/2018/05/ch%E1%BA%A1y-server-phoenix-v%E1%BB%9Bi-ssl-tr%C3%AAn-localhost/</link>
      <pubDate>Wed, 02 May 2018 22:42:14 +0700</pubDate>
      
      <guid>http://bluzky.github.io/2018/05/ch%E1%BA%A1y-server-phoenix-v%E1%BB%9Bi-ssl-tr%C3%AAn-localhost/</guid>
      <description>Từ tháng 04/2018 tất cả các app mới tạo trên Facebook chỉ chấp nhận callback url có sử dụng SSL. Đây là những bước đơn giản để có thể sử dụng giao thức https trên localhost đối với Phoenix
 1. Tạo chứng chỉ
Run command
openssl genrsa 1024 &amp;gt; app.key &amp;amp;&amp;amp; openssl req -new -x509 -nodes -sha1 -days 365 -key ~/app.key &amp;gt; ~/app.cert  2. Copy file
app.key and app.</description>
    </item>
    
    <item>
      <title>Memcache là gì?</title>
      <link>http://bluzky.github.io/2018/05/memcache-l%C3%A0-g%C3%AC/</link>
      <pubDate>Tue, 01 May 2018 23:05:10 +0700</pubDate>
      
      <guid>http://bluzky.github.io/2018/05/memcache-l%C3%A0-g%C3%AC/</guid>
      <description>1. Memcache  Memcache là một cơ sở dữ liệu dạng key-value, các dữ liệu đuợc ghi nhớ trên RAM giúp tối ưu thời gian truy xuất.
 2. Đặc điểm  Dữ liệu lưu trữ dạng key-value Value là dữ liệu dạng string Kích thuớc của Value giới hạn là 1MB Dữ liệu sẽ bị mất khi tắt máy/ tắt memcache Truy xuất dữ liệu nhanh  3. Ứng dụng Memcache thường đuợc dùng đễ cache dữ liệu trên các web server giúp giảm thời gian xử lý các request giống nhau, thay vào đó chỉ cần đọc dữ liệu từ bộ nhớ và trả về ngay lập tức.</description>
    </item>
    
    <item>
      <title>Terminal tips - Một số command hay dùng</title>
      <link>http://bluzky.github.io/2018/04/terminal-tips-m%E1%BB%99t-s%E1%BB%91-command-hay-d%C3%B9ng/</link>
      <pubDate>Tue, 24 Apr 2018 21:43:25 +0700</pubDate>
      
      <guid>http://bluzky.github.io/2018/04/terminal-tips-m%E1%BB%99t-s%E1%BB%91-command-hay-d%C3%B9ng/</guid>
      <description>Khi chuyển qua dùng các hệ điều hành Unix và Mac, việc sử dụng các command line là một phần không thể thiếu, đặc biệt là các công việc liên quan tới Web dev và devops.
Tuy nhiên phần lớn là đụng tới đâu cần thì mới search, hoặc là do xài quen rồi nên cũng lười tìm cách làm khác. Chỉ cần dành 1 phút để đọc qua bài viết này, các bạn sẽ thực sự bất ngờ vì có những thứ cool đến không ngờ.</description>
    </item>
    
    <item>
      <title>Finite state machine trong lập trình</title>
      <link>http://bluzky.github.io/2018/04/finite-state-machine-trong-l%E1%BA%ADp-tr%C3%ACnh/</link>
      <pubDate>Fri, 13 Apr 2018 22:32:22 +0700</pubDate>
      
      <guid>http://bluzky.github.io/2018/04/finite-state-machine-trong-l%E1%BA%ADp-tr%C3%ACnh/</guid>
      <description>1. Tìm hiểu về FSM  FSM(Finite state machine) - Máy trạng thái hữu hạn là một mô hình toán học biểu diễn trạng thái của hệ, trong đó số trạng thái là hữu hạn. Từ mỗi trạng thái, máy có thể chuyển đổi qua 1 số trạng thái cố định khác, dựa trên các sự kiện, input.
 Fsm được biểu diễn như 1 đồ thị có hướng.</description>
    </item>
    
    <item>
      <title>Tìm hiểu về công nghệ Blockchain</title>
      <link>http://bluzky.github.io/2018/04/t%C3%ACm-hi%E1%BB%83u-v%E1%BB%81-c%C3%B4ng-ngh%E1%BB%87-blockchain/</link>
      <pubDate>Wed, 11 Apr 2018 20:53:06 +0700</pubDate>
      
      <guid>http://bluzky.github.io/2018/04/t%C3%ACm-hi%E1%BB%83u-v%E1%BB%81-c%C3%B4ng-ngh%E1%BB%87-blockchain/</guid>
      <description>Từ cơn sốt tiền ảo, công nghệ Blockchain được tung hô và được xem như là công nghệ sẽ làm thay đổi tương lại, thậm chí đến cả công ty thực phẩm thêm chữ Blockchain vào tên sản phẩm cũng đủ làm giá cổ phiếu tăng mấy chục lần. Vậy Blockchain là gì và nó có thực sự là thứ sẽ làm thay đổi tương lai công nghệ? Để trả lời thắc mắc của chính mình, tôi đã dành thời gian để tìm hiểu về Blockchain.</description>
    </item>
    
    <item>
      <title>Thiết lập và quản lý mục tiêu theo phương pháp OKR</title>
      <link>http://bluzky.github.io/2018/02/thi%E1%BA%BFt-l%E1%BA%ADp-v%C3%A0-qu%E1%BA%A3n-l%C3%BD-m%E1%BB%A5c-ti%C3%AAu-theo-ph%C6%B0%C6%A1ng-ph%C3%A1p-okr/</link>
      <pubDate>Fri, 09 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>http://bluzky.github.io/2018/02/thi%E1%BA%BFt-l%E1%BA%ADp-v%C3%A0-qu%E1%BA%A3n-l%C3%BD-m%E1%BB%A5c-ti%C3%AAu-theo-ph%C6%B0%C6%A1ng-ph%C3%A1p-okr/</guid>
      <description>Vừa mới hoàn thành các chức năng cơ bản cho hệ thống OKR nội bộ công ty. Sau quá trình tìm hiểu các phương pháp áp dụng OKR vào trong một tổ chức, mình thấy nó rất là hay và đơn giản, dễ áp dụng. Ngoài việc áp dụng cho công ty, có thể áp dụng các nguyên tắc của OKR để thiết lập kế hoạch cá nhân.</description>
    </item>
    
    <item>
      <title>Dùng MAP, FILTER và REDUCE để xử lý danh sách / list trong Python</title>
      <link>http://bluzky.github.io/2018/01/d%C3%B9ng-map-filter-v%C3%A0-reduce-%C4%91%E1%BB%83-x%E1%BB%AD-l%C3%BD-danh-s%C3%A1ch-/-list-trong-python/</link>
      <pubDate>Sun, 21 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://bluzky.github.io/2018/01/d%C3%B9ng-map-filter-v%C3%A0-reduce-%C4%91%E1%BB%83-x%E1%BB%AD-l%C3%BD-danh-s%C3%A1ch-/-list-trong-python/</guid>
      <description>1. Giới thiệu  List là một trong những kiểu dữ liệu được sử dụng rất nhiều trong python. Các thao tác thường được thực hiện trên list: xử lý từng phần tử trong list, lọc lấy một số phần tử thỏa điều kiện, tính toán dựa trên tất cả các phần tử của list( vd tính tổng) và trả về kết quả. Để đơn giản việc xử lý List, Python hỗ trợ một số hàm có sẵn để thực hiện các tác vụ trên gồm map(), filter(), reduce()  2.</description>
    </item>
    
    <item>
      <title>Python decorator là gì? dùng khi nào</title>
      <link>http://bluzky.github.io/2018/01/python-decorator-l%C3%A0-g%C3%AC-d%C3%B9ng-khi-n%C3%A0o/</link>
      <pubDate>Sun, 21 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://bluzky.github.io/2018/01/python-decorator-l%C3%A0-g%C3%AC-d%C3%B9ng-khi-n%C3%A0o/</guid>
      <description>1. Decorator là gì?  Decorator là một mẫu thiết kế (Design pattern) thường được dùng để thay đổi hành vi, chức năng của hàm(function) hoặc lớp (class) mà không cần phải thay đổi code của hàm hoặc lớp. Tham khảo Python hỗ trợ cú pháp (syntax) cho Decorator từ version 2.4 Về cơ bản Decorator giống như một lớp vỏ bọc (wrapper), nó thay đổi hành vi(behavior) của code trước và sau khi gọi hàm chính (hàm được decorate).</description>
    </item>
    
    <item>
      <title>Truyền tham số động trong python (*args | **kwargs)?</title>
      <link>http://bluzky.github.io/2018/01/truy%E1%BB%81n-tham-s%E1%BB%91-%C4%91%E1%BB%99ng-trong-python-args-kwargs/</link>
      <pubDate>Sun, 21 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://bluzky.github.io/2018/01/truy%E1%BB%81n-tham-s%E1%BB%91-%C4%91%E1%BB%99ng-trong-python-args-kwargs/</guid>
      <description>Thực sự thì không nhất thiết phải là *args và **kwargs. điều quan trọng là tham số có 1 dấu sao * hay là 2 dấu sao **. Đặt tên tham số là *var hay **vars hay bất cứ thứ gì bạn muốn. Nhưng để dễ hiểu thì nên dùng tên chuẩn là *args và **kwargs
1. *args và **kwargs dùng để làm gì?  Khi khai báo 1 hàm, sử dụng *args và **kwargs cho phép bạn truyền vào bao nhiêu tham số cũng được mà không cần biết trước số lượng.</description>
    </item>
    
    <item>
      <title>Tìm hiểu về Oauth / Oauth hoạt động như thế nào?</title>
      <link>http://bluzky.github.io/2018/01/t%C3%ACm-hi%E1%BB%83u-v%E1%BB%81-oauth-/-oauth-ho%E1%BA%A1t-%C4%91%E1%BB%99ng-nh%C6%B0-th%E1%BA%BF-n%C3%A0o/</link>
      <pubDate>Sun, 21 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://bluzky.github.io/2018/01/t%C3%ACm-hi%E1%BB%83u-v%E1%BB%81-oauth-/-oauth-ho%E1%BA%A1t-%C4%91%E1%BB%99ng-nh%C6%B0-th%E1%BA%BF-n%C3%A0o/</guid>
      <description>1. Oauthh 2 và các khái niệm 1.1 Oauth 2 là gì: Oauth 2 là bản nâng cấp của giao thức chứng thực Oauth 1.0
1.2 Các Role (vai trò) trong mô hình oauth  resource owner là đối tượng có khả năng cấp quyền truy cập tới tài nguyên (resource) được bảo vệ Resource server là một server lưu trữ các tài nguyên, có khả năng xử lý các yêu cầu truy cập tới tài nguyên được bảo vệ.</description>
    </item>
    
    <item>
      <title>What is Rabbit MQ?</title>
      <link>http://bluzky.github.io/2018/01/what-is-rabbit-mq/</link>
      <pubDate>Sun, 21 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>http://bluzky.github.io/2018/01/what-is-rabbit-mq/</guid>
      <description>1. What is Rabbit MQ?  Rabbit MQ is an server application, it is a message broker which implement AMQP (Advanced Message Queue Protocol). It works like a post service, which take the message from sender and dispatch that message to the receiver.
 Some terminologies:
 Producer: send message to queue Queue: hold all message added by producer and dispatch those message to a consumer Consumer: receive message from  2.</description>
    </item>
    
  </channel>
</rss>